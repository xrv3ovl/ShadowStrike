/*
 * ShadowStrike - Enterprise NGAV/EDR Platform
 * Copyright (C) 2026 ShadowStrike Security
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
/*++
    ShadowStrike Next-Generation Antivirus
    Module: Trace.c

    Purpose: Enterprise-grade WPP tracing runtime configuration and management.

    This is the SOLE implementation file for all WPP runtime APIs declared
    in WppConfig.h.  WPP preprocessor directives live in Trace.h.

    Architecture:
    - Global trace configuration with atomic/interlocked updates
    - Lock-free statistics via InterlockedXxx operations
    - Monotonic sequence numbers for trace ordering
    - Approximate per-second rate limiting (documented as best-effort)
    - Session GUIDs for trace session correlation

    Copyright (c) 2026 ShadowStrike Security. All rights reserved.
--*/

#include <ntddk.h>
#include <wdm.h>
#include <ntstrsafe.h>
#include "Trace.h"
#include "WppConfig.h"

//
// WPP Tracing — include TMH file generated by WPP preprocessor.
// Must come after Trace.h.
//
#if defined(WPP_TRACING)
#include "Trace.tmh"
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, WppTraceInitialize)
#pragma alloc_text(PAGE, WppTraceShutdown)
#endif

// ============================================================================
// INTERNAL CONSTANTS
// ============================================================================

#define TRACE_SIGNATURE             'ECRT'
#define TRACE_MAX_RATE_LIMIT        1000000     // 1M traces/sec max
#define TRACE_DEFAULT_RATE_LIMIT    100000      // 100K traces/sec default
#define TRACE_RATE_RESET_100NS      10000000LL  // 1 second in 100ns units

#define TRACE_CORRELATION_EPOCH     0x0001000000000000ULL
#define TRACE_SEQUENCE_MASK         0x0000FFFFFFFFFFFFULL

// ============================================================================
// COMPILE-TIME CHECKS
// ============================================================================

static const PCSTR g_ComponentNames[] = {
    "Unknown",
    "Core",
    "Filter",
    "Scan",
    "Communication",
    "Process",
    "Registry",
    "Network",
    "SelfProtection",
    "Cache",
    "Memory",
    "Thread",
    "Image",
    "Behavior",
    "ETW",
    "Crypto",
    "Sync"
};
C_ASSERT(ARRAYSIZE(g_ComponentNames) == WppComponent_Max);

static const PCSTR g_LevelNames[] = {
    "NONE",
    "CRITICAL",
    "ERROR",
    "WARNING",
    "INFO",
    "VERBOSE",
    "SECURITY",
    "AUDIT",
    "DEBUG",
    "PERF"
};
C_ASSERT(ARRAYSIZE(g_LevelNames) == WPP_LEVEL_NAME_COUNT);

// ============================================================================
// GLOBAL STATE
// ============================================================================

static WPP_TRACE_CONFIG g_TraceConfig = {0};
static volatile LONG g_TraceInitialized = 0;
static PDRIVER_OBJECT g_DriverObject = NULL;
static volatile LONG64 g_CorrelationCounter = 0;

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

static BOOLEAN
TracepCheckRateLimit(
    VOID
    );

static VOID
TracepGenerateSessionGuid(
    _Out_ PGUID SessionGuid
    );

// ============================================================================
// INITIALIZATION AND SHUTDOWN
// ============================================================================

_Use_decl_annotations_
NTSTATUS
WppTraceInitialize(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    LARGE_INTEGER SystemTime;

    PAGED_CODE();

    if (DriverObject == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Atomic init guard — only one thread can initialize.
    //
    if (InterlockedCompareExchange(&g_TraceInitialized, 1, 0) != 0) {
        return STATUS_ALREADY_REGISTERED;
    }

    g_DriverObject = DriverObject;

    //
    // Initialize WPP infrastructure.
    //
#if defined(WPP_TRACING)
    WPP_INIT_TRACING(DriverObject, RegistryPath);
#else
    UNREFERENCED_PARAMETER(RegistryPath);
#endif

    //
    // Zero and populate configuration.
    //
    RtlZeroMemory(&g_TraceConfig, sizeof(WPP_TRACE_CONFIG));

    g_TraceConfig.TracingEnabled          = TRUE;
    g_TraceConfig.DebugTracingEnabled     = FALSE;
    g_TraceConfig.PerfTracingEnabled      = FALSE;
    g_TraceConfig.SecurityTracingEnabled  = TRUE;

    g_TraceConfig.MinimumLevel = TRACE_LEVEL_INFORMATION;
    g_TraceConfig.MaximumLevel = TRACE_LEVEL_VERBOSE;

    g_TraceConfig.EnabledFlags  = TRACE_FLAG_ALL;
    g_TraceConfig.DisabledFlags = 0;

    g_TraceConfig.MaxTracesPerSecond  = TRACE_DEFAULT_RATE_LIMIT;
    g_TraceConfig.CurrentSecondTraces = 0;

    KeQuerySystemTime(&SystemTime);
    g_TraceConfig.CurrentSecondStart = SystemTime.QuadPart;

    g_TraceConfig.TotalTraces   = 0;
    g_TraceConfig.DroppedTraces = 0;
    g_TraceConfig.ErrorCount    = 0;
    g_TraceConfig.SequenceNumber = 0;

    TracepGenerateSessionGuid(&g_TraceConfig.SessionGuid);

    //
    // Seed correlation counter with timestamp bits.
    //
    g_CorrelationCounter = (LONG64)(SystemTime.QuadPart & TRACE_SEQUENCE_MASK);

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "[ShadowStrike/Trace] WPP Tracing initialized. Session: "
        "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n",
        g_TraceConfig.SessionGuid.Data1,
        g_TraceConfig.SessionGuid.Data2,
        g_TraceConfig.SessionGuid.Data3,
        g_TraceConfig.SessionGuid.Data4[0],
        g_TraceConfig.SessionGuid.Data4[1],
        g_TraceConfig.SessionGuid.Data4[2],
        g_TraceConfig.SessionGuid.Data4[3],
        g_TraceConfig.SessionGuid.Data4[4],
        g_TraceConfig.SessionGuid.Data4[5],
        g_TraceConfig.SessionGuid.Data4[6],
        g_TraceConfig.SessionGuid.Data4[7]
    );

    return STATUS_SUCCESS;
}

_Use_decl_annotations_
VOID
WppTraceShutdown(
    PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();

    if (DriverObject == NULL) {
        return;
    }

    if (InterlockedCompareExchange(&g_TraceInitialized, 0, 1) != 1) {
        return;
    }

    DbgPrintEx(
        DPFLTR_IHVDRIVER_ID,
        DPFLTR_INFO_LEVEL,
        "[ShadowStrike/Trace] Shutting down. Total: %lld, Dropped: %lld, Errors: %lld\n",
        g_TraceConfig.TotalTraces,
        g_TraceConfig.DroppedTraces,
        g_TraceConfig.ErrorCount
    );

    g_TraceConfig.TracingEnabled = FALSE;

#if defined(WPP_TRACING)
    WPP_CLEANUP(DriverObject);
#else
    UNREFERENCED_PARAMETER(DriverObject);
#endif

    g_DriverObject = NULL;
    RtlZeroMemory(&g_TraceConfig, sizeof(WPP_TRACE_CONFIG));
}

_Use_decl_annotations_
BOOLEAN
WppTraceIsEnabled(
    VOID
    )
{
    return (g_TraceInitialized != 0) && g_TraceConfig.TracingEnabled;
}

// ============================================================================
// RUNTIME CONFIGURATION
// ============================================================================

_Use_decl_annotations_
VOID
WppSetMinimumLevel(
    UCHAR Level
    )
{
    if (!g_TraceInitialized) {
        return;
    }

    if (Level > TRACE_LEVEL_RESERVED) {
        Level = TRACE_LEVEL_RESERVED;
    }

    //
    // Single-byte aligned write — naturally atomic on x86/x64.
    //
    g_TraceConfig.MinimumLevel = Level;
}

_Use_decl_annotations_
UCHAR
WppGetMinimumLevel(
    VOID
    )
{
    if (!g_TraceInitialized) {
        return TRACE_LEVEL_NONE;
    }

    return g_TraceConfig.MinimumLevel;
}

_Use_decl_annotations_
VOID
WppSetTraceFlags(
    ULONG Flags,
    BOOLEAN Enable
    )
{
    if (!g_TraceInitialized) {
        return;
    }

    if (Enable) {
        InterlockedOr((volatile LONG*)&g_TraceConfig.EnabledFlags, (LONG)Flags);
        InterlockedAnd((volatile LONG*)&g_TraceConfig.DisabledFlags, ~(LONG)Flags);
    } else {
        InterlockedAnd((volatile LONG*)&g_TraceConfig.EnabledFlags, ~(LONG)Flags);
        InterlockedOr((volatile LONG*)&g_TraceConfig.DisabledFlags, (LONG)Flags);
    }
}

_Use_decl_annotations_
ULONG
WppGetTraceFlags(
    VOID
    )
{
    if (!g_TraceInitialized) {
        return 0;
    }

    return g_TraceConfig.EnabledFlags & ~g_TraceConfig.DisabledFlags;
}

_Use_decl_annotations_
VOID
WppSetRateLimit(
    ULONG MaxTracesPerSecond
    )
{
    LARGE_INTEGER CurrentTime;

    if (!g_TraceInitialized) {
        return;
    }

    if (MaxTracesPerSecond > TRACE_MAX_RATE_LIMIT) {
        MaxTracesPerSecond = TRACE_MAX_RATE_LIMIT;
    }

    g_TraceConfig.MaxTracesPerSecond = MaxTracesPerSecond;

    //
    // Reset window.
    //
    KeQuerySystemTime(&CurrentTime);
    InterlockedExchange64(&g_TraceConfig.CurrentSecondStart, CurrentTime.QuadPart);
    InterlockedExchange(&g_TraceConfig.CurrentSecondTraces, 0);
}

// ============================================================================
// CORRELATION API
// ============================================================================

_Use_decl_annotations_
UINT64
WppGenerateCorrelationId(
    VOID
    )
{
    LONG64 Sequence;

    Sequence = InterlockedIncrement64(&g_CorrelationCounter);

    return TRACE_CORRELATION_EPOCH | ((UINT64)Sequence & TRACE_SEQUENCE_MASK);
}

_Use_decl_annotations_
NTSTATUS
WppCreateTraceContext(
    PWPP_TRACE_CONTEXT Context,
    WPP_COMPONENT_ID ComponentId,
    UINT64 ParentCorrelationId
    )
{
    LARGE_INTEGER CurrentTime;

    if (Context == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (ComponentId >= WppComponent_Max) {
        ComponentId = WppComponent_Unknown;
    }

    RtlZeroMemory(Context, sizeof(WPP_TRACE_CONTEXT));

    Context->CorrelationId       = WppGenerateCorrelationId();
    Context->ParentCorrelationId = ParentCorrelationId;
    Context->ProcessId           = (UINT32)(ULONG_PTR)PsGetCurrentProcessId();
    Context->ThreadId            = (UINT32)(ULONG_PTR)PsGetCurrentThreadId();
    Context->ComponentId         = (UINT32)ComponentId;
    Context->SubComponentId      = 0;

    KeQuerySystemTime(&CurrentTime);
    Context->StartTimestamp = (UINT64)CurrentTime.QuadPart;
    Context->EndTimestamp   = 0;
    Context->CustomData     = NULL;
    Context->CustomDataSize = 0;

    return STATUS_SUCCESS;
}

_Use_decl_annotations_
VOID
WppCompleteTraceContext(
    PWPP_TRACE_CONTEXT Context
    )
{
    LARGE_INTEGER CurrentTime;

    if (Context == NULL) {
        return;
    }

    KeQuerySystemTime(&CurrentTime);
    Context->EndTimestamp = (UINT64)CurrentTime.QuadPart;
}

// ============================================================================
// STATISTICS API
// ============================================================================

_Use_decl_annotations_
NTSTATUS
WppGetStatistics(
    PUINT64 TotalTraces,
    PUINT64 DroppedTraces,
    PUINT64 ErrorCount
    )
{
    if (!g_TraceInitialized) {
        if (TotalTraces != NULL)  *TotalTraces  = 0;
        if (DroppedTraces != NULL) *DroppedTraces = 0;
        if (ErrorCount != NULL)   *ErrorCount   = 0;
        return STATUS_NOT_FOUND;
    }

    if (TotalTraces != NULL) {
        *TotalTraces = (UINT64)InterlockedCompareExchange64(
            &g_TraceConfig.TotalTraces, 0, 0);
    }
    if (DroppedTraces != NULL) {
        *DroppedTraces = (UINT64)InterlockedCompareExchange64(
            &g_TraceConfig.DroppedTraces, 0, 0);
    }
    if (ErrorCount != NULL) {
        *ErrorCount = (UINT64)InterlockedCompareExchange64(
            &g_TraceConfig.ErrorCount, 0, 0);
    }

    return STATUS_SUCCESS;
}

_Use_decl_annotations_
VOID
WppResetStatistics(
    VOID
    )
{
    LARGE_INTEGER CurrentTime;

    if (!g_TraceInitialized) {
        return;
    }

    InterlockedExchange64(&g_TraceConfig.TotalTraces, 0);
    InterlockedExchange64(&g_TraceConfig.DroppedTraces, 0);
    InterlockedExchange64(&g_TraceConfig.ErrorCount, 0);
    InterlockedExchange64(&g_TraceConfig.SequenceNumber, 0);

    KeQuerySystemTime(&CurrentTime);
    InterlockedExchange64(&g_TraceConfig.CurrentSecondStart, CurrentTime.QuadPart);
    InterlockedExchange(&g_TraceConfig.CurrentSecondTraces, 0);
}

// ============================================================================
// EXTENDED TRACING API
// ============================================================================

BOOLEAN
WppShouldTrace(
    _In_ UCHAR Level,
    _In_ ULONG Flags
    )
{
    ULONG EffectiveFlags;

    if (!g_TraceInitialized || !g_TraceConfig.TracingEnabled) {
        return FALSE;
    }

    if (Level < g_TraceConfig.MinimumLevel) {
        return FALSE;
    }

    if (Level > g_TraceConfig.MaximumLevel) {
        return FALSE;
    }

    EffectiveFlags = g_TraceConfig.EnabledFlags & ~g_TraceConfig.DisabledFlags;
    if ((Flags & EffectiveFlags) == 0) {
        return FALSE;
    }

    if (!TracepCheckRateLimit()) {
        InterlockedIncrement64(&g_TraceConfig.DroppedTraces);
        return FALSE;
    }

    return TRUE;
}

VOID
WppRecordTrace(
    VOID
    )
{
    if (g_TraceInitialized) {
        InterlockedIncrement64(&g_TraceConfig.TotalTraces);
        InterlockedIncrement64(&g_TraceConfig.SequenceNumber);
    }
}

VOID
WppRecordError(
    VOID
    )
{
    if (g_TraceInitialized) {
        InterlockedIncrement64(&g_TraceConfig.ErrorCount);
    }
}

UINT64
WppGetSequenceNumber(
    VOID
    )
{
    if (!g_TraceInitialized) {
        return 0;
    }
    return (UINT64)InterlockedCompareExchange64(
        &g_TraceConfig.SequenceNumber, 0, 0);
}

NTSTATUS
WppGetSessionGuid(
    _Out_ PGUID SessionGuid
    )
{
    if (SessionGuid == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!g_TraceInitialized) {
        RtlZeroMemory(SessionGuid, sizeof(GUID));
        return STATUS_NOT_FOUND;
    }

    RtlCopyMemory(SessionGuid, &g_TraceConfig.SessionGuid, sizeof(GUID));
    return STATUS_SUCCESS;
}

// ============================================================================
// CONDITIONAL TRACING HELPERS
// ============================================================================

VOID
WppSetDebugTracing(
    _In_ BOOLEAN Enable
    )
{
    if (!g_TraceInitialized) {
        return;
    }

    g_TraceConfig.DebugTracingEnabled = Enable;
    g_TraceConfig.MaximumLevel = Enable ? TRACE_LEVEL_DEBUG : TRACE_LEVEL_VERBOSE;
}

VOID
WppSetPerfTracing(
    _In_ BOOLEAN Enable
    )
{
    if (!g_TraceInitialized) {
        return;
    }

    g_TraceConfig.PerfTracingEnabled = Enable;
    WppSetTraceFlags(TRACE_FLAG_PERF, Enable);
}

VOID
WppSetSecurityTracing(
    _In_ BOOLEAN Enable
    )
{
    if (!g_TraceInitialized) {
        return;
    }

    g_TraceConfig.SecurityTracingEnabled = Enable;
    WppSetTraceFlags(TRACE_FLAG_SECURITY_ALL, Enable);
}

BOOLEAN
WppIsDebugTracingEnabled(
    VOID
    )
{
    return g_TraceInitialized ? g_TraceConfig.DebugTracingEnabled : FALSE;
}

BOOLEAN
WppIsPerfTracingEnabled(
    VOID
    )
{
    return g_TraceInitialized ? g_TraceConfig.PerfTracingEnabled : FALSE;
}

BOOLEAN
WppIsSecurityTracingEnabled(
    VOID
    )
{
    return g_TraceInitialized ? g_TraceConfig.SecurityTracingEnabled : FALSE;
}

// ============================================================================
// FUNCTIONS ABSORBED FROM WppConfig.c
// ============================================================================

NTSTATUS
WppGetConfiguration(
    _Out_ PWPP_TRACE_CONFIG Config
    )
{
    if (Config == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!g_TraceInitialized) {
        RtlZeroMemory(Config, sizeof(WPP_TRACE_CONFIG));
        return STATUS_NOT_FOUND;
    }

    //
    // Snapshot — individual fields may be stale by the time copy completes,
    // but this is acceptable for a diagnostic/config dump.
    //
    RtlCopyMemory(Config, &g_TraceConfig, sizeof(WPP_TRACE_CONFIG));

    return STATUS_SUCCESS;
}

UINT64
WppGetElapsedMicroseconds(
    _In_ PWPP_TRACE_CONTEXT Context
    )
{
    if (Context == NULL) {
        return 0;
    }

    if (Context->EndTimestamp == 0 || Context->StartTimestamp == 0) {
        return 0;
    }

    if (Context->EndTimestamp < Context->StartTimestamp) {
        return 0;
    }

    return (Context->EndTimestamp - Context->StartTimestamp) / 10;
}

NTSTATUS
WppFormatCorrelationId(
    _In_ UINT64 CorrelationId,
    _Out_writes_(BufferSize) PWCHAR Buffer,
    _In_ SIZE_T BufferSize
    )
{
    if (Buffer == NULL || BufferSize < 20) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    return RtlStringCchPrintfW(Buffer, BufferSize, L"%016I64X", CorrelationId);
}

// ============================================================================
// FORMATTING HELPERS
// ============================================================================

static ULONG
TracepSafeStrLenA(
    _In_ PCHAR Buffer,
    _In_ ULONG MaxChars
    )
{
    SIZE_T Length = 0;
    NTSTATUS Status;

    Status = RtlStringCchLengthA(Buffer, (size_t)MaxChars, &Length);
    if (!NT_SUCCESS(Status)) {
        return 0;
    }
    return (ULONG)Length;
}

ULONG
WppFormatStatus(
    _In_ NTSTATUS Status,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    NTSTATUS FormatStatus;

    if (Buffer == NULL || BufferSize == 0) {
        return 0;
    }

    FormatStatus = RtlStringCchPrintfA(Buffer, BufferSize, "0x%08X", Status);
    if (!NT_SUCCESS(FormatStatus)) {
        Buffer[0] = '\0';
        return 0;
    }

    return TracepSafeStrLenA(Buffer, BufferSize);
}

ULONG
WppFormatGuid(
    _In_ PGUID Guid,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    NTSTATUS Status;

    if (Guid == NULL || Buffer == NULL || BufferSize < 39) {
        return 0;
    }

    Status = RtlStringCchPrintfA(
        Buffer, BufferSize,
        "{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
        Guid->Data1, Guid->Data2, Guid->Data3,
        Guid->Data4[0], Guid->Data4[1],
        Guid->Data4[2], Guid->Data4[3],
        Guid->Data4[4], Guid->Data4[5],
        Guid->Data4[6], Guid->Data4[7]
    );

    if (!NT_SUCCESS(Status)) {
        Buffer[0] = '\0';
        return 0;
    }

    return TracepSafeStrLenA(Buffer, BufferSize);
}

ULONG
WppFormatHexDump(
    _In_reads_bytes_(DataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    PUCHAR Bytes;
    ULONG i;
    ULONG Offset = 0;
    ULONG MaxBytes;

    if (Data == NULL || Buffer == NULL || BufferSize < 3) {
        return 0;
    }

    Bytes = (PUCHAR)Data;

    MaxBytes = (BufferSize - 1) / 3;
    if (DataSize > MaxBytes) {
        DataSize = MaxBytes;
    }

    for (i = 0; i < DataSize && Offset + 3 < BufferSize; i++) {
        NTSTATUS Status = RtlStringCchPrintfA(
            Buffer + Offset,
            BufferSize - Offset,
            "%02X ",
            Bytes[i]
        );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        Offset += 3;
    }

    if (Offset > 0) {
        Buffer[Offset - 1] = '\0';
        Offset--;
    } else {
        Buffer[0] = '\0';
    }

    return Offset;
}

ULONG
WppFormatTimestamp(
    _In_ UINT64 Timestamp,
    _Out_writes_(BufferSize) PCHAR Buffer,
    _In_ ULONG BufferSize
    )
{
    LARGE_INTEGER Time;
    TIME_FIELDS TimeFields;
    NTSTATUS Status;

    if (Buffer == NULL || BufferSize < 24) {
        return 0;
    }

    Time.QuadPart = (LONGLONG)Timestamp;
    RtlTimeToTimeFields(&Time, &TimeFields);

    Status = RtlStringCchPrintfA(
        Buffer, BufferSize,
        "%04d-%02d-%02d %02d:%02d:%02d.%03d",
        TimeFields.Year, TimeFields.Month, TimeFields.Day,
        TimeFields.Hour, TimeFields.Minute, TimeFields.Second,
        TimeFields.Milliseconds
    );

    if (!NT_SUCCESS(Status)) {
        Buffer[0] = '\0';
        return 0;
    }

    return TracepSafeStrLenA(Buffer, BufferSize);
}

// ============================================================================
// NAME LOOKUP FUNCTIONS (moved from inline to avoid array duplication)
// ============================================================================

PCSTR
WppGetComponentName(
    _In_ WPP_COMPONENT_ID ComponentId
    )
{
    if ((ULONG)ComponentId >= WppComponent_Max) {
        return "Invalid";
    }

    return g_ComponentNames[ComponentId];
}

PCSTR
WppGetLevelName(
    _In_ UCHAR Level
    )
{
    if (Level >= ARRAYSIZE(g_LevelNames)) {
        return "UNKNOWN";
    }

    return g_LevelNames[Level];
}

// ============================================================================
// INTERNAL HELPER FUNCTIONS
// ============================================================================

/**
 * @brief Check and update rate limit.
 *
 * Best-effort: under extreme concurrency, slightly more traces than
 * MaxTracesPerSecond may be emitted during the window reset.
 * This is acceptable for a tracing subsystem.
 */
static BOOLEAN
TracepCheckRateLimit(
    VOID
    )
{
    LARGE_INTEGER CurrentTime;
    LONG64 WindowStart;
    LONG CurrentCount;

    if (g_TraceConfig.MaxTracesPerSecond == 0) {
        return TRUE;
    }

    KeQuerySystemTime(&CurrentTime);

    WindowStart = InterlockedCompareExchange64(
        &g_TraceConfig.CurrentSecondStart, 0, 0);

    if ((CurrentTime.QuadPart - WindowStart) >= TRACE_RATE_RESET_100NS) {
        //
        // Try to claim the window reset. Only one thread wins the CAS;
        // losers proceed with the old window (which is fine — approximate).
        //
        if (InterlockedCompareExchange64(
                &g_TraceConfig.CurrentSecondStart,
                CurrentTime.QuadPart,
                WindowStart) == WindowStart)
        {
            InterlockedExchange(&g_TraceConfig.CurrentSecondTraces, 0);
        }
    }

    CurrentCount = InterlockedIncrement(&g_TraceConfig.CurrentSecondTraces);

    if ((ULONG)CurrentCount > g_TraceConfig.MaxTracesPerSecond) {
        return FALSE;
    }

    return TRUE;
}

static VOID
TracepGenerateSessionGuid(
    _Out_ PGUID SessionGuid
    )
{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER PerfCounter;
    PUCHAR GuidBytes;

    if (SessionGuid == NULL) {
        return;
    }

    KeQuerySystemTime(&SystemTime);
    PerfCounter = KeQueryPerformanceCounter(NULL);

    GuidBytes = (PUCHAR)SessionGuid;
    RtlCopyMemory(GuidBytes, &SystemTime.QuadPart, 8);
    RtlCopyMemory(GuidBytes + 8, &PerfCounter.QuadPart, 8);

    GuidBytes[0] ^= (UCHAR)((ULONG_PTR)PsGetCurrentProcessId() & 0xFF);
    GuidBytes[1] ^= (UCHAR)(((ULONG_PTR)PsGetCurrentProcessId() >> 8) & 0xFF);

    SessionGuid->Data3 = (SessionGuid->Data3 & 0x0FFF) | 0x4000;
    SessionGuid->Data4[0] = (SessionGuid->Data4[0] & 0x3F) | 0x80;
}

// ============================================================================
// DIAGNOSTIC DUMP
// ============================================================================

VOID
WppDumpConfiguration(
    VOID
    )
{
    if (!g_TraceInitialized) {
        DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
            "[ShadowStrike/Trace] Not initialized\n");
        return;
    }

    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
        "============================================================\n"
        "ShadowStrike WPP Trace Configuration Dump\n"
        "============================================================\n");
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
        "Tracing Enabled: %s\n"
        "Debug Tracing: %s\n"
        "Perf Tracing: %s\n"
        "Security Tracing: %s\n",
        g_TraceConfig.TracingEnabled ? "Yes" : "No",
        g_TraceConfig.DebugTracingEnabled ? "Enabled" : "Disabled",
        g_TraceConfig.PerfTracingEnabled ? "Enabled" : "Disabled",
        g_TraceConfig.SecurityTracingEnabled ? "Enabled" : "Disabled");
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
        "Level: Min=%u (%s), Max=%u (%s)\n",
        g_TraceConfig.MinimumLevel,
        WppGetLevelName(g_TraceConfig.MinimumLevel),
        g_TraceConfig.MaximumLevel,
        WppGetLevelName(g_TraceConfig.MaximumLevel));
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
        "Flags: Enabled=0x%08X, Disabled=0x%08X, Effective=0x%08X\n",
        g_TraceConfig.EnabledFlags,
        g_TraceConfig.DisabledFlags,
        g_TraceConfig.EnabledFlags & ~g_TraceConfig.DisabledFlags);
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
        "Rate Limit: %u/sec (current: %ld)\n",
        g_TraceConfig.MaxTracesPerSecond,
        g_TraceConfig.CurrentSecondTraces);
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
        "Stats: Total=%lld, Dropped=%lld, Errors=%lld, Seq=%lld\n",
        g_TraceConfig.TotalTraces,
        g_TraceConfig.DroppedTraces,
        g_TraceConfig.ErrorCount,
        g_TraceConfig.SequenceNumber);
    DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_INFO_LEVEL,
        "Session: {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}\n"
        "============================================================\n",
        g_TraceConfig.SessionGuid.Data1,
        g_TraceConfig.SessionGuid.Data2,
        g_TraceConfig.SessionGuid.Data3,
        g_TraceConfig.SessionGuid.Data4[0],
        g_TraceConfig.SessionGuid.Data4[1],
        g_TraceConfig.SessionGuid.Data4[2],
        g_TraceConfig.SessionGuid.Data4[3],
        g_TraceConfig.SessionGuid.Data4[4],
        g_TraceConfig.SessionGuid.Data4[5],
        g_TraceConfig.SessionGuid.Data4[6],
        g_TraceConfig.SessionGuid.Data4[7]);
}
