/*
 * ShadowStrike - Enterprise NGAV/EDR Platform
 * Copyright (C) 2026 ShadowStrike Security
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
/**
 * ============================================================================
 * ShadowStrike Real-Time - EXPLOIT PREVENTION IMPLEMENTATION
 * ============================================================================
 *
 * @file ExploitPrevention.cpp
 * @brief Enterprise-grade exploit mitigation and prevention implementation.
 *
 * IMPLEMENTATION DETAILS:
 * - Uses Windows Process Mitigation Policies for OS-level protections (DEP, ASLR, CFG)
 * - Implements user-mode ROP detection via stack scanning and pivot detection
 * - Implements EAF (Export Address Filtering) using Hardware Breakpoints (Debug Registers)
 * - Implements Call Stack Walking for forensic analysis
 * - Thread-safe design using PIMPL and shared_mutex
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @copyright (c) 2026 ShadowStrike Security Suite. All rights reserved.
 * ============================================================================
 */

#include "pch.h"
#include "ExploitPrevention.hpp"
#include "../Utils/Logger.hpp"
#include "../Utils/SystemUtils.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/StringUtils.hpp"

#include <vector>
#include <mutex>
#include <shared_mutex>
#include <algorithm>
#include <thread>
#include <atomic>
#include <optional>
#include <unordered_map>
#include <unordered_set>
#include <tlhelp32.h>
#include <psapi.h>
#include <dbghelp.h>
#include <winternl.h> // For TEB/PEB access

#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "ntdll.lib")

// Define NTSTATUS constants if missing
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#endif

// Internal NT API definitions
typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    KAFFINITY AffinityMask;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

// Undocumented NtQueryInformationThread
typedef NTSTATUS (WINAPI *NtQueryInformationThreadPtr)(
    HANDLE ThreadHandle,
    THREADINFOCLASS ThreadInformationClass,
    PVOID ThreadInformation,
    ULONG ThreadInformationLength,
    PULONG ReturnLength
);

namespace ShadowStrike::RealTime {

    using namespace Utils;

    // ============================================================================
    // INTERNAL CONSTANTS
    // ============================================================================

    namespace {
        constexpr uint32_t CALL_STACK_CAPTURE_FRAMES = 64;
        constexpr size_t MAX_EVENT_HISTORY = 1000;
        constexpr uint32_t ROP_GADGET_CHECK_DEPTH = 64; // Increased depth

        // Context flags
        constexpr DWORD CONTEXT_DEBUG_REGISTERS = 0x00010010L; // CONTEXT_AMD64 | CONTEXT_DEBUG_REGISTERS
    }

    // ============================================================================
    // IMPLEMENTATION CLASS (PIMPL)
    // ============================================================================

    struct ExploitPrevention::Impl {
        // -------------------------------------------------------------------------
        // State
        // -------------------------------------------------------------------------

        mutable std::shared_mutex m_mutex;
        bool m_initialized = false;
        bool m_running = false;

        std::shared_ptr<Utils::ThreadPool> m_threadPool;
        ExploitPreventionConfig m_config;
        ExploitPreventionStats m_stats;

        // Policies
        std::unordered_map<std::wstring, MitigationPolicy> m_policies;

        // Process Status
        std::unordered_map<uint32_t, ProcessMitigationStatus> m_processStatus;

        // Event History
        std::vector<ExploitEvent> m_eventHistory;

        // Callbacks
        std::unordered_map<uint64_t, ExploitCallback> m_exploitCallbacks;
        std::unordered_map<uint64_t, EAFCallback> m_eafCallbacks;
        std::unordered_map<uint64_t, ROPCallback> m_ropCallbacks;
        std::unordered_map<uint64_t, MitigationCallback> m_mitigationCallbacks;
        uint64_t m_nextCallbackId = 1;

        // EAF State
        // Map PID -> Set of protected threads
        std::unordered_map<uint32_t, std::unordered_set<uint32_t>> m_eafProtectedThreads;
        // Map PID -> List of addresses to protect (Export Tables)
        std::unordered_map<uint32_t, std::vector<uintptr_t>> m_eafTargetAddresses;

        // API pointers
        NtQueryInformationThreadPtr m_NtQueryInformationThread = nullptr;

        // -------------------------------------------------------------------------
        // Initialization
        // -------------------------------------------------------------------------

        Impl() {
            HMODULE hNtdll = GetModuleHandleW(L"ntdll.dll");
            if (hNtdll) {
                m_NtQueryInformationThread = (NtQueryInformationThreadPtr)GetProcAddress(hNtdll, "NtQueryInformationThread");
            }
        }

        // -------------------------------------------------------------------------
        // Helper Methods
        // -------------------------------------------------------------------------

        [[nodiscard]] uint64_t GenerateEventId() {
            static std::atomic<uint64_t> id{ 1 };
            return id.fetch_add(1, std::memory_order_relaxed);
        }

        void LogEvent(const ExploitEvent& event) {
            std::unique_lock lock(m_mutex);
            m_eventHistory.push_back(event);
            if (m_eventHistory.size() > MAX_EVENT_HISTORY) {
                m_eventHistory.erase(m_eventHistory.begin());
            }
            m_stats.totalEvents++;

            if (event.actionTaken != ExploitAction::Allow) {
                m_stats.exploitsBlocked++;
            }
        }

        // -------------------------------------------------------------------------
        // Mitigation Logic (OS Policies)
        // -------------------------------------------------------------------------

        bool ApplyDEP(HANDLE hProcess, bool enable, bool permanent) {
            PROCESS_MITIGATION_DEP_POLICY policy = {};
            policy.Enable = enable ? 1 : 0;
            policy.Permanent = permanent ? 1 : 0;

            if (!SetProcessMitigationPolicy(ProcessDEPPolicy, &policy, sizeof(policy))) {
                // Failure might be expected if policy already permanently set
                return false;
            }
            return true;
        }

        bool ApplyASLR(HANDLE hProcess, bool enable, bool highEntropy, bool bottomUp, bool forceRelocate) {
            PROCESS_MITIGATION_ASLR_POLICY policy = {};
            policy.EnableForceRelocateImages = forceRelocate ? 1 : 0;
            policy.EnableHighEntropy = highEntropy ? 1 : 0;
            policy.EnableBottomUpRandomization = bottomUp ? 1 : 0;

            if (!SetProcessMitigationPolicy(ProcessASLRPolicy, &policy, sizeof(policy))) {
                return false;
            }
            return true;
        }

        bool ApplyCFG(HANDLE hProcess, bool enable, bool strict) {
            PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY policy = {};
            policy.EnableControlFlowGuard = enable ? 1 : 0;
            policy.EnableExportSuppression = strict ? 1 : 0;
            policy.StrictMode = strict ? 1 : 0;

            if (!SetProcessMitigationPolicy(ProcessControlFlowGuardPolicy, &policy, sizeof(policy))) {
                return false;
            }
            return true;
        }

        bool ApplyImageLoadPolicy(HANDLE hProcess, bool blockRemote, bool blockLowIntegrity) {
            PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
            policy.NoRemoteImages = blockRemote ? 1 : 0;
            policy.NoLowMandatoryLabelImages = blockLowIntegrity ? 1 : 0;

            if (!SetProcessMitigationPolicy(ProcessImageLoadPolicy, &policy, sizeof(policy))) {
                return false;
            }
            return true;
        }

        bool ApplyDynamicCodePolicy(HANDLE hProcess, bool disable) {
            PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
            policy.ProhibitDynamicCode = disable ? 1 : 0;

            if (!SetProcessMitigationPolicy(ProcessDynamicCodePolicy, &policy, sizeof(policy))) {
                return false;
            }
            return true;
        }

        // -------------------------------------------------------------------------
        // Advanced Detection Logic
        // -------------------------------------------------------------------------

        // Check if instruction at address is a RET
        bool IsInstructionRet(uint32_t pid, uintptr_t address) {
            uint8_t opcode = 0;
            if (Utils::ProcessUtils::ReadMemory(pid, address, &opcode, 1)) {
                // C3 = RET, C2 = RET n, CB = RETF, CA = RETF n
                return (opcode == 0xC3 || opcode == 0xC2 || opcode == 0xCB || opcode == 0xCA);
            }
            return false;
        }

        // Check if instruction at address is a CALL
        bool IsInstructionCall(uint32_t pid, uintptr_t address) {
             // Basic check for common CALL opcodes preceding the return address
             uint8_t buffer[7] = {0};
             // Check 5 bytes back (E8 rel32)
             if (Utils::ProcessUtils::ReadMemory(pid, address - 5, buffer, 5)) {
                 if (buffer[0] == 0xE8) return true;
             }
             // Check 2 bytes back (FF /2)
             if (Utils::ProcessUtils::ReadMemory(pid, address - 2, buffer, 2)) {
                 if (buffer[0] == 0xFF && (buffer[1] & 0x38) == 0x10) return true; // CALL r/m64
                 if (buffer[0] == 0xFF && (buffer[1] & 0x38) == 0x18) return true; // CALL m16:32/64
             }
             return false;
        }

        // Helper to get stack limits from TEB
        bool GetThreadStackLimits(HANDLE hThread, uintptr_t& stackBase, uintptr_t& stackLimit) {
            if (!m_NtQueryInformationThread) return false;

            THREAD_BASIC_INFORMATION tbi = {};
            ULONG returnLength = 0;
            NTSTATUS status = m_NtQueryInformationThread(hThread, (THREADINFOCLASS)0, &tbi, sizeof(tbi), &returnLength);

            if (status != STATUS_SUCCESS || !tbi.TebBaseAddress) {
                return false;
            }

            // TEB structure is OS version dependent but StackBase/Limit are usually at stable offsets
            // x64: StackBase at +0x08, StackLimit at +0x10
            // x86: StackBase at +0x04, StackLimit at +0x08

            // We'll read the NT_TIB from the start of TEB
            NT_TIB tib = {};
            // Need to read from the target process memory context
            // But we have the handle to thread... accessing TEB usually requires Process Handle
            // Simplified: Use the PID from thread ID to open process

            DWORD pid = ::GetProcessIdOfThread(hThread);
            if (pid == 0) return false;

            // Reading remote TEB
            if (Utils::ProcessUtils::ReadMemory(pid, (uintptr_t)tbi.TebBaseAddress, &tib, sizeof(tib))) {
                stackBase = (uintptr_t)tib.StackBase;
                stackLimit = (uintptr_t)tib.StackLimit;
                return true;
            }

            return false;
        }
    };

    // ============================================================================
    // SINGLETON
    // ============================================================================

    ExploitPrevention& ExploitPrevention::Instance() {
        static ExploitPrevention instance;
        return instance;
    }

    ExploitPrevention::ExploitPrevention() : m_impl(std::make_unique<Impl>()) {}
    ExploitPrevention::~ExploitPrevention() = default;

    // ============================================================================
    // LIFECYCLE
    // ============================================================================

    bool ExploitPrevention::Initialize() {
        return Initialize(nullptr, ExploitPreventionConfig::CreateDefault());
    }

    bool ExploitPrevention::Initialize(std::shared_ptr<Utils::ThreadPool> threadPool) {
        return Initialize(threadPool, ExploitPreventionConfig::CreateDefault());
    }

    bool ExploitPrevention::Initialize(
        std::shared_ptr<Utils::ThreadPool> threadPool,
        const ExploitPreventionConfig& config
    ) {
        std::unique_lock lock(m_impl->m_mutex);

        if (m_impl->m_initialized) {
            Logger::Warn("ExploitPrevention already initialized");
            return true;
        }

        m_impl->m_threadPool = threadPool;
        m_impl->m_config = config;

        // Add default policy
        m_impl->m_policies[config.defaultPolicy.name] = config.defaultPolicy;

        m_impl->m_initialized = true;
        Logger::Info("ExploitPrevention initialized");
        return true;
    }

    void ExploitPrevention::Shutdown() {
        Stop();
        std::unique_lock lock(m_impl->m_mutex);
        m_impl->m_policies.clear();
        m_impl->m_processStatus.clear();
        m_impl->m_eventHistory.clear();
        m_impl->m_initialized = false;
        Logger::Info("ExploitPrevention shutdown");
    }

    void ExploitPrevention::Start() {
        std::unique_lock lock(m_impl->m_mutex);
        if (!m_impl->m_initialized) return;

        m_impl->m_running = true;
        Logger::Info("ExploitPrevention started");

        // Start verification thread if configured
        if (m_impl->m_config.periodicVerification && m_impl->m_threadPool) {
            m_impl->m_threadPool->Enqueue([this]() {
                VerificationThread();
            });
        }
    }

    void ExploitPrevention::Stop() {
        std::unique_lock lock(m_impl->m_mutex);
        m_impl->m_running = false;
        Logger::Info("ExploitPrevention stopped");
    }

    bool ExploitPrevention::IsRunning() const noexcept {
        std::shared_lock lock(m_impl->m_mutex);
        return m_impl->m_running;
    }

    void ExploitPrevention::UpdateConfig(const ExploitPreventionConfig& config) {
        std::unique_lock lock(m_impl->m_mutex);
        m_impl->m_config = config;
        Logger::Info("ExploitPrevention configuration updated");
    }

    ExploitPreventionConfig ExploitPrevention::GetConfig() const {
        std::shared_lock lock(m_impl->m_mutex);
        return m_impl->m_config;
    }

    // ============================================================================
    // MITIGATION MANAGEMENT
    // ============================================================================

    bool ExploitPrevention::ApplyMitigations(uint32_t pid) {
        std::shared_lock lock(m_impl->m_mutex);
        const auto& policy = m_impl->m_config.defaultPolicy;
        return ApplyPolicy(pid, policy);
    }

    bool ExploitPrevention::ApplyPolicy(uint32_t pid, const MitigationPolicy& policy) {
        if (!IsRunning()) return false;

        Logger::Info("Applying mitigation policy '{}' to PID {}",
            Utils::StringUtils::WideToUtf8(policy.name), pid);

        HANDLE hProcess = ::OpenProcess(PROCESS_SET_INFORMATION | PROCESS_QUERY_INFORMATION, FALSE, pid);
        if (!hProcess) {
            Logger::Error("Failed to open process {} for mitigation. Error: {}", pid, ::GetLastError());
            return false;
        }

        bool success = true;

        // Apply Windows Mitigations
        if (policy.enableDEP) {
            if (!m_impl->ApplyDEP(hProcess, true, policy.depPermanent)) success = false;
        }

        if (policy.enableASLR) {
            if (!m_impl->ApplyASLR(hProcess, true, policy.enableHighEntropyASLR, true, true)) success = false;
        }

        if (policy.enableCFG) {
            if (!m_impl->ApplyCFG(hProcess, true, policy.cfgStrict)) success = false;
        }

        if (policy.blockRemoteImages || policy.blockLowIntegrityImages) {
            if (!m_impl->ApplyImageLoadPolicy(hProcess, policy.blockRemoteImages, policy.blockLowIntegrityImages)) success = false;
        }

        if (policy.disableDynamicCode) {
            if (!m_impl->ApplyDynamicCodePolicy(hProcess, true)) success = false;
        }

        ::CloseHandle(hProcess);

        // Apply Custom Mitigations (EAF, ROP)
        if (policy.enableEAF) {
            EnableEAF(pid);
        }

        // Update status tracking
        {
            std::unique_lock statusLock(m_impl->m_mutex);
            auto& status = m_impl->m_processStatus[pid];
            status.processId = pid;
            status.lastCheck = std::chrono::system_clock::now();
            status.dep = policy.enableDEP ? ExploitMitigationStatus::Enabled : ExploitMitigationStatus::Disabled;
            status.aslr = policy.enableASLR ? ExploitMitigationStatus::Enabled : ExploitMitigationStatus::Disabled;
            status.cfg = policy.enableCFG ? ExploitMitigationStatus::Enabled : ExploitMitigationStatus::Disabled;
            status.eaf = policy.enableEAF ? ExploitMitigationStatus::Enabled : ExploitMitigationStatus::Disabled;
        }

        m_impl->m_stats.mitigationsApplied++;
        m_impl->m_stats.processesWithMitigations++;

        return success;
    }

    bool ExploitPrevention::EnableMitigation(uint32_t pid, MitigationType mitigation) {
        // Map single mitigation to policy update
        MitigationPolicy tempPolicy;
        // Default everything to false/unaffected
        tempPolicy.enableDEP = false;
        tempPolicy.enableASLR = false;
        tempPolicy.enableCFG = false;
        tempPolicy.enableEAF = false;

        switch (mitigation) {
            case MitigationType::DEP: tempPolicy.enableDEP = true; break;
            case MitigationType::ASLR: tempPolicy.enableASLR = true; break;
            case MitigationType::CFG: tempPolicy.enableCFG = true; break;
            case MitigationType::EAF: tempPolicy.enableEAF = true; break;
            default: return false; // Not supported for single enable
        }

        // Note: This is an additive apply, it doesn't disable others
        return ApplyPolicy(pid, tempPolicy);
    }

    bool ExploitPrevention::DisableMitigation(uint32_t pid, MitigationType mitigation) {
        // Windows policies cannot generally be disabled once enabled (permanently)
        // Only custom mitigations like EAF can be disabled
        if (mitigation == MitigationType::EAF) {
            DisableEAF(pid);
            return true;
        }
        return false;
    }

    ProcessMitigationStatus ExploitPrevention::GetMitigationStatus(uint32_t pid) {
        std::shared_lock lock(m_impl->m_mutex);
        auto it = m_impl->m_processStatus.find(pid);
        if (it != m_impl->m_processStatus.end()) {
            return it->second;
        }
        return ProcessMitigationStatus{};
    }

    bool ExploitPrevention::VerifyMitigations(uint32_t pid) {
        HANDLE hProcess = ::OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);
        if (!hProcess) return false;

        PROCESS_MITIGATION_DEP_POLICY dep = {};
        if (GetProcessMitigationPolicy(hProcess, ProcessDEPPolicy, &dep, sizeof(dep))) {
            std::unique_lock lock(m_impl->m_mutex);
            m_impl->m_processStatus[pid].dep = dep.Enable ? ExploitMitigationStatus::Enabled : ExploitMitigationStatus::Disabled;
        }

        ::CloseHandle(hProcess);
        return true;
    }

    std::vector<ProcessMitigationStatus> ExploitPrevention::GetAllMitigationStatus() const {
        std::shared_lock lock(m_impl->m_mutex);
        std::vector<ProcessMitigationStatus> result;
        for (const auto& pair : m_impl->m_processStatus) {
            result.push_back(pair.second);
        }
        return result;
    }

    // ============================================================================
    // EAF/IAF MANAGEMENT
    // ============================================================================

    bool ExploitPrevention::EnableEAF(uint32_t pid) {
        // EAF: Set Hardware Breakpoints (Dr0-Dr3) on Export Address Tables of critical modules
        // 1. Identify target addresses (LoadLibrary, GetProcAddress in kernel32/ntdll)
        // 2. Snapshot threads
        // 3. Suspend threads -> SetThreadContext -> Resume

        std::unique_lock lock(m_impl->m_mutex);

        // Find critical modules
        std::vector<std::wstring> criticalModules = m_impl->m_config.eafProtectedModules;
        if (criticalModules.empty()) {
            // Defaults
            criticalModules = { L"kernel32.dll", L"ntdll.dll" };
        }

        std::vector<uintptr_t> targetAddrs;

        // For EAF we usually protect the EAT (Export Address Table) start
        // Finding EAT requires parsing PE header of the remote process module
        // Simplified here: We'll target the module Base Address + PE Header offset usually accessed

        // Get module bases
        auto modules = Utils::ProcessUtils::GetProcessModules(pid);
        for (const auto& modName : criticalModules) {
            for (const auto& mod : modules) {
                if (Utils::StringUtils::EqualIgnoreCase(mod.name, modName)) {
                    // Protect the PE header (DOS header -> NT header -> Optional Header -> Data Directory -> EAT)
                    // Shellcode scans this to find function addresses.
                    // Access to the PE header by non-image code is suspicious.
                    targetAddrs.push_back(mod.baseAddress + 0x3C); // e_lfanew
                }
            }
        }

        if (targetAddrs.empty()) {
            Logger::Warn("EAF: Could not find target modules for PID {}", pid);
            return false;
        }

        m_impl->m_eafTargetAddresses[pid] = targetAddrs;

        // Apply to all threads
        HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
        if (hSnapshot == INVALID_HANDLE_VALUE) return false;

        THREADENTRY32 te = {};
        te.dwSize = sizeof(te);

        if (Thread32First(hSnapshot, &te)) {
            do {
                if (te.th32OwnerProcessID == pid) {
                    HANDLE hThread = ::OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);
                    if (hThread) {
                        ::SuspendThread(hThread);

                        CONTEXT ctx = {};
                        ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
                        if (::GetThreadContext(hThread, &ctx)) {
                            // Set Dr0, Dr1...
                            for (size_t i = 0; i < std::min((size_t)4, targetAddrs.size()); i++) {
                                switch(i) {
                                    case 0: ctx.Dr0 = targetAddrs[i]; break;
                                    case 1: ctx.Dr1 = targetAddrs[i]; break;
                                    case 2: ctx.Dr2 = targetAddrs[i]; break;
                                    case 3: ctx.Dr3 = targetAddrs[i]; break;
                                }
                            }

                            // Enable breakpoints in Dr7
                            // L0=1 (local Dr0), L1=1 (local Dr1)...
                            // 16-17: R/W0 (00=exec, 01=write, 11=read/write) - we want Read/Write (3) or Read (not supported by x86 DR)
                            // Actually x86/x64 DR: 00=Exec, 01=Write, 11=Read/Write. Data Access.
                            // We set generic RW trap.

                            ctx.Dr7 = 0;
                            for (size_t i = 0; i < std::min((size_t)4, targetAddrs.size()); i++) {
                                ctx.Dr7 |= (1 << (i * 2)); // Local enable
                                ctx.Dr7 |= (3 << (16 + i * 4)); // R/W
                            }

                            ::SetThreadContext(hThread, &ctx);
                            m_impl->m_eafProtectedThreads[pid].insert(te.th32ThreadID);
                        }

                        ::ResumeThread(hThread);
                        ::CloseHandle(hThread);
                    }
                }
            } while (Thread32Next(hSnapshot, &te));
        }

        ::CloseHandle(hSnapshot);
        Logger::Info("EAF Enabled for PID {} on {} threads", pid, m_impl->m_eafProtectedThreads[pid].size());
        return true;
    }

    void ExploitPrevention::DisableEAF(uint32_t pid) {
        std::unique_lock lock(m_impl->m_mutex);
        auto it = m_impl->m_eafProtectedThreads.find(pid);
        if (it == m_impl->m_eafProtectedThreads.end()) return;

        for (uint32_t tid : it->second) {
            HANDLE hThread = ::OpenThread(THREAD_ALL_ACCESS, FALSE, tid);
            if (hThread) {
                ::SuspendThread(hThread);
                CONTEXT ctx = {};
                ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
                if (::GetThreadContext(hThread, &ctx)) {
                    ctx.Dr0 = 0; ctx.Dr1 = 0; ctx.Dr2 = 0; ctx.Dr3 = 0; ctx.Dr7 = 0;
                    ::SetThreadContext(hThread, &ctx);
                }
                ::ResumeThread(hThread);
                ::CloseHandle(hThread);
            }
        }
        m_impl->m_eafProtectedThreads.erase(it);
        m_impl->m_eafTargetAddresses.erase(pid);
        Logger::Info("EAF Disabled for PID {}", pid);
    }

    bool ExploitPrevention::EnableIAF(uint32_t pid) {
        return true; // Placeholder for similar logic on IAT
    }

    void ExploitPrevention::DisableIAF(uint32_t pid) {
    }

    void ExploitPrevention::AddEAFModule(const std::wstring& moduleName) {
        std::unique_lock lock(m_impl->m_mutex);
        m_impl->m_config.eafProtectedModules.push_back(moduleName);
    }

    void ExploitPrevention::RemoveEAFModule(const std::wstring& moduleName) {
        std::unique_lock lock(m_impl->m_mutex);
        auto& mods = m_impl->m_config.eafProtectedModules;
        mods.erase(std::remove(mods.begin(), mods.end(), moduleName), mods.end());
    }

    std::vector<std::wstring> ExploitPrevention::GetEAFModules() const {
        std::shared_lock lock(m_impl->m_mutex);
        return m_impl->m_config.eafProtectedModules;
    }

    // ============================================================================
    // DETECTION LOGIC
    // ============================================================================

    ROPDetectionResult ExploitPrevention::DetectROP(uint32_t pid, uint32_t threadId) {
        ROPDetectionResult result;

        HANDLE hThread = ::OpenThread(THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, threadId);
        if (!hThread) return result;

        CONTEXT ctx = {};
        ctx.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
        if (!::GetThreadContext(hThread, &ctx)) {
            ::CloseHandle(hThread);
            return result;
        }

#ifdef _WIN64
        uintptr_t sp = ctx.Rsp;
#else
        uintptr_t sp = ctx.Esp;
#endif

        // 1. Check Stack Pivot
        uintptr_t stackBase = 0, stackLimit = 0;
        if (m_impl->GetThreadStackLimits(hThread, stackBase, stackLimit)) {
            // Stack grows down: StackLimit < SP < StackBase
            if (sp < stackLimit || sp > stackBase) {
                result.stackPivot = true;
                result.originalStackPointer = stackBase; // Approximate
                Logger::Critical("Stack Pivot Detected in PID {}: SP={:x} outside [{:x}-{:x}]",
                    pid, sp, stackLimit, stackBase);
            }
        }
        ::CloseHandle(hThread);

        result.currentStackPointer = sp;

        // 2. Scan Stack for Gadgets
        const size_t stackScanSize = sizeof(uintptr_t) * ROP_GADGET_CHECK_DEPTH;
        std::vector<uint8_t> stackMem(stackScanSize);
        if (!Utils::ProcessUtils::ReadMemory(pid, sp, stackMem.data(), stackScanSize)) {
            return result;
        }

        uintptr_t* stackValues = reinterpret_cast<uintptr_t*>(stackMem.data());
        size_t ropGadgets = 0;

        for (size_t i = 0; i < ROP_GADGET_CHECK_DEPTH; i++) {
            uintptr_t addr = stackValues[i];

            // Filter nulls and small values
            if (addr < 0x10000) continue;

            // Heuristic 1: Address points to executable memory
            if (IsAddressExecutable(pid, addr)) {
                // Heuristic 2: Instruction before address is NOT a CALL (implies RET to RET)
                // A normal return address follows a CALL.
                // In ROP, gadgets are chained on stack, so the previous instruction executed was a RET,
                // and the current address is the next gadget. It was NOT placed there by a CALL instruction.
                if (!m_impl->IsInstructionCall(pid, addr)) {
                    // Heuristic 3: Instruction AT address is a RET (gadget) or leads to one
                    if (m_impl->IsInstructionRet(pid, addr)) {
                        ropGadgets++;
                        result.gadgetAddresses.push_back(addr);

                        // Get module for better reporting
                        std::wstring mod = GetModuleForAddress(pid, addr);
                        result.gadgetModules.push_back(mod);
                    }
                }
            }
        }

        if (ropGadgets >= ExploitPreventionConstants::MIN_ROP_CHAIN_LENGTH || result.stackPivot) {
            result.detected = true;
            result.gadgetCount = ropGadgets;
            result.confidence = result.stackPivot ? 100.0 : (ropGadgets * 10.0);
            if (result.confidence > 100.0) result.confidence = 100.0;

            Logger::Critical("Exploit Detected in PID {} Thread {}: ROP Gadgets={}, Pivot={}",
                pid, threadId, ropGadgets, result.stackPivot);

            m_impl->InvokeROPCallbacks(pid, result);
        }

        return result;
    }

    bool ExploitPrevention::DetectStackPivot(uint32_t pid, uint32_t threadId) {
        HANDLE hThread = ::OpenThread(THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, threadId);
        if (!hThread) return false;

        CONTEXT ctx = {};
        ctx.ContextFlags = CONTEXT_CONTROL;
        if (!::GetThreadContext(hThread, &ctx)) {
            ::CloseHandle(hThread);
            return false;
        }
#ifdef _WIN64
        uintptr_t sp = ctx.Rsp;
#else
        uintptr_t sp = ctx.Esp;
#endif

        uintptr_t stackBase = 0, stackLimit = 0;
        bool pivoted = false;

        if (m_impl->GetThreadStackLimits(hThread, stackBase, stackLimit)) {
            // Standard stack check
            if (sp < stackLimit || sp > stackBase) {
                pivoted = true;
            }
        }

        ::CloseHandle(hThread);
        return pivoted;
    }

    bool ExploitPrevention::ValidateAPICall(const APICallInfo& callInfo) {
        // Critical API validation logic
        if (!callInfo.returnAddressInCode) {
            Logger::Warn("API Call {} from non-executable memory (Shellcode?)", callInfo.apiName);
            return false;
        }

        // Caller validation (did this really come from the module it claims?)
        if (!callInfo.callerLegitimate) {
             Logger::Warn("API Call {} from illegitimate caller module", callInfo.apiName);
             return false;
        }

        return true;
    }

    bool ExploitPrevention::IsAddressInLegitimateModule(uint32_t pid, uintptr_t address) {
        return !GetModuleForAddress(pid, address).empty();
    }

    std::vector<uintptr_t> ExploitPrevention::CaptureCallStack(uint32_t pid, uint32_t threadId) {
        std::vector<uintptr_t> stack;

        HANDLE hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
        if (!hProcess) return stack;

        HANDLE hThread = ::OpenThread(THREAD_ALL_ACCESS, FALSE, threadId);
        if (!hThread) {
            ::CloseHandle(hProcess);
            return stack;
        }

        // Suspend to capture
        ::SuspendThread(hThread);

        CONTEXT ctx = {};
        ctx.ContextFlags = CONTEXT_FULL;
        if (::GetThreadContext(hThread, &ctx)) {
            STACKFRAME64 frame = {};
#ifdef _WIN64
            DWORD machineType = IMAGE_FILE_MACHINE_AMD64;
            frame.AddrPC.Offset = ctx.Rip;
            frame.AddrPC.Mode = AddrModeFlat;
            frame.AddrFrame.Offset = ctx.Rbp;
            frame.AddrFrame.Mode = AddrModeFlat;
            frame.AddrStack.Offset = ctx.Rsp;
            frame.AddrStack.Mode = AddrModeFlat;
#else
            DWORD machineType = IMAGE_FILE_MACHINE_I386;
            frame.AddrPC.Offset = ctx.Eip;
            frame.AddrPC.Mode = AddrModeFlat;
            frame.AddrFrame.Offset = ctx.Ebp;
            frame.AddrFrame.Mode = AddrModeFlat;
            frame.AddrStack.Offset = ctx.Esp;
            frame.AddrStack.Mode = AddrModeFlat;
#endif

            // Initialize symbols
            ::SymInitialize(hProcess, NULL, TRUE);

            for (size_t i = 0; i < CALL_STACK_CAPTURE_FRAMES; i++) {
                if (!::StackWalk64(machineType, hProcess, hThread, &frame, &ctx,
                    NULL, ::SymFunctionTableAccess64, ::SymGetModuleBase64, NULL)) {
                    break;
                }

                if (frame.AddrPC.Offset != 0) {
                    stack.push_back(static_cast<uintptr_t>(frame.AddrPC.Offset));
                } else {
                    break;
                }
            }

            ::SymCleanup(hProcess);
        }

        ::ResumeThread(hThread);
        ::CloseHandle(hThread);
        ::CloseHandle(hProcess);

        return stack;
    }

    // ============================================================================
    // EVENT HANDLING
    // ============================================================================

    ExploitAction ExploitPrevention::OnExploitDetected(const ExploitEvent& event) {
        Logger::Critical("EXPLOIT DETECTED: Type={} PID={} Process={}",
            ExploitTypeToString(event.exploitType), event.processId, Utils::StringUtils::WideToUtf8(event.processName));

        m_impl->LogEvent(event);

        // Determine action based on config
        ExploitAction action = m_impl->m_config.defaultAction;
        if (event.confidence >= m_impl->m_config.highConfidenceThreshold) {
            action = m_impl->m_config.highConfidenceAction;
        }

        // Invoke callbacks (observers might upgrade/downgrade action)
        ExploitAction cbAction = m_impl->InvokeExploitCallbacks(event);
        if (cbAction != ExploitAction::Allow) action = cbAction;

        if (action == ExploitAction::Terminate) {
            Logger::Info("Terminating process {} due to exploit detection", event.processId);
            Utils::ProcessUtils::TerminateProcess(event.processId);
            m_impl->m_stats.processesTerminated++;
        }

        return action;
    }

    // ============================================================================
    // STATISTICS & QUERIES
    // ============================================================================

    ExploitPreventionStats ExploitPrevention::GetStats() const {
        std::shared_lock lock(m_impl->m_mutex);
        return m_impl->m_stats;
    }

    void ExploitPrevention::ResetStats() {
        std::unique_lock lock(m_impl->m_mutex);
        m_impl->m_stats.Reset();
    }

    std::vector<ExploitEvent> ExploitPrevention::GetRecentEvents(size_t count) const {
        std::shared_lock lock(m_impl->m_mutex);
        std::vector<ExploitEvent> result;
        size_t available = m_impl->m_eventHistory.size();
        size_t copyCount = std::min(available, count);

        if (available > 0) {
            result.insert(result.end(),
                          m_impl->m_eventHistory.end() - copyCount,
                          m_impl->m_eventHistory.end());
        }
        return result;
    }

    // ============================================================================
    // CALLBACK REGISTRATION
    // ============================================================================

    uint64_t ExploitPrevention::RegisterExploitCallback(ExploitCallback callback) {
        std::unique_lock lock(m_impl->m_mutex);
        uint64_t id = m_impl->m_nextCallbackId++;
        m_impl->m_exploitCallbacks[id] = std::move(callback);
        return id;
    }

    bool ExploitPrevention::UnregisterExploitCallback(uint64_t callbackId) {
        std::unique_lock lock(m_impl->m_mutex);
        return m_impl->m_exploitCallbacks.erase(callbackId) > 0;
    }

    uint64_t ExploitPrevention::RegisterEAFCallback(EAFCallback callback) {
        std::unique_lock lock(m_impl->m_mutex);
        uint64_t id = m_impl->m_nextCallbackId++;
        m_impl->m_eafCallbacks[id] = std::move(callback);
        return id;
    }

    bool ExploitPrevention::UnregisterEAFCallback(uint64_t id) {
        std::unique_lock lock(m_impl->m_mutex);
        return m_impl->m_eafCallbacks.erase(id) > 0;
    }

    uint64_t ExploitPrevention::RegisterROPCallback(ROPCallback callback) {
        std::unique_lock lock(m_impl->m_mutex);
        uint64_t id = m_impl->m_nextCallbackId++;
        m_impl->m_ropCallbacks[id] = std::move(callback);
        return id;
    }

    bool ExploitPrevention::UnregisterROPCallback(uint64_t id) {
        std::unique_lock lock(m_impl->m_mutex);
        return m_impl->m_ropCallbacks.erase(id) > 0;
    }

    uint64_t ExploitPrevention::RegisterMitigationCallback(MitigationCallback callback) {
        std::unique_lock lock(m_impl->m_mutex);
        uint64_t id = m_impl->m_nextCallbackId++;
        m_impl->m_mitigationCallbacks[id] = std::move(callback);
        return id;
    }

    bool ExploitPrevention::UnregisterMitigationCallback(uint64_t id) {
        std::unique_lock lock(m_impl->m_mutex);
        return m_impl->m_mitigationCallbacks.erase(id) > 0;
    }

    // ============================================================================
    // PRIVATE INTERNAL METHODS
    // ============================================================================

    void ExploitPrevention::VerificationThread() {
        while (IsRunning()) {
            // Periodic background scan for ROP/Mitigation status
            std::vector<uint32_t> pidsToCheck;
            {
                std::shared_lock lock(m_impl->m_mutex);
                for (const auto& [pid, status] : m_impl->m_processStatus) {
                    pidsToCheck.push_back(pid);
                }
            }

            for (uint32_t pid : pidsToCheck) {
                // Get threads for this process
                HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
                if (hSnapshot != INVALID_HANDLE_VALUE) {
                    THREADENTRY32 te = {};
                    te.dwSize = sizeof(te);
                    if (Thread32First(hSnapshot, &te)) {
                        do {
                            if (te.th32OwnerProcessID == pid) {
                                // Run detection logic on threads
                                if (m_impl->m_config.enableROPDetection) {
                                    DetectROP(pid, te.th32ThreadID);
                                }
                            }
                        } while (Thread32Next(hSnapshot, &te));
                    }
                    ::CloseHandle(hSnapshot);
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(m_impl->m_config.verificationIntervalSec));
        }
    }

    ExploitAction ExploitPrevention::Impl::InvokeExploitCallbacks(const ExploitEvent& event) {
        ExploitAction finalAction = ExploitAction::Allow;
        for (const auto& [id, cb] : m_exploitCallbacks) {
            ExploitAction action = cb(event);
            if (action > finalAction) finalAction = action;
        }
        return finalAction;
    }

    ExploitAction ExploitPrevention::Impl::InvokeROPCallbacks(uint32_t pid, const ROPDetectionResult& result) {
        if (result.detected) {
            ExploitEvent event;
            event.eventId = GenerateEventId();
            event.timestamp = std::chrono::system_clock::now();
            event.processId = pid;
            event.exploitType = result.stackPivot ? ExploitType::StackPivot : ExploitType::ROPExecution;
            event.confidence = result.confidence;
            event.actionTaken = m_config.defaultAction;

            // Invoke generic callbacks too
            return InvokeExploitCallbacks(event);
        }
        return ExploitAction::Allow;
    }

    // ============================================================================
    // UTILITY FUNCTIONS implementation
    // ============================================================================

    [[nodiscard]] constexpr const char* MitigationTypeToString(MitigationType type) noexcept {
        switch(type) {
            case MitigationType::DEP: return "DEP";
            case MitigationType::ASLR: return "ASLR";
            case MitigationType::CFG: return "CFG";
            case MitigationType::EAF: return "EAF";
            case MitigationType::StackPivotDetection: return "StackPivotDetection";
            default: return "Unknown";
        }
    }

    [[nodiscard]] constexpr const char* ExploitTypeToString(ExploitType type) noexcept {
         switch(type) {
            case ExploitType::StackBufferOverflow: return "StackBufferOverflow";
            case ExploitType::HeapBufferOverflow: return "HeapBufferOverflow";
            case ExploitType::ROPExecution: return "ROPExecution";
            case ExploitType::ShellcodeExecution: return "ShellcodeExecution";
            case ExploitType::StackPivot: return "StackPivot";
            default: return "Unknown";
         }
    }

    [[nodiscard]] std::wstring GetModuleForAddress(uint32_t pid, uintptr_t address) noexcept {
        return Utils::ProcessUtils::GetModuleFromAddress(pid, address);
    }

    [[nodiscard]] bool IsAddressExecutable(uint32_t pid, uintptr_t address) noexcept {
        MEMORY_BASIC_INFORMATION mbi = {};
        if (Utils::ProcessUtils::VirtualQueryEx(pid, reinterpret_cast<LPCVOID>(address), &mbi, sizeof(mbi))) {
             return (mbi.Protect & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY));
        }
        return false;
    }

} // namespace ShadowStrike::RealTime
