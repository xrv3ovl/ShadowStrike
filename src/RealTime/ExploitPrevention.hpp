/**
 * ============================================================================
 * ShadowStrike Real-Time - EXPLOIT PREVENTION (The Aegis)
 * ============================================================================
 *
 * @file ExploitPrevention.hpp
 * @brief Enterprise-grade exploit mitigation and prevention.
 *
 * This module provides comprehensive exploit prevention capabilities including
 * memory corruption mitigations, shellcode prevention, and ROP protection.
 *
 * =============================================================================
 * CORE CAPABILITIES
 * =============================================================================
 *
 * 1. **Memory Corruption Mitigations**
 *    - DEP (Data Execution Prevention) enforcement
 *    - ASLR (Address Space Layout Randomization) verification
 *    - SEHOP (Structured Exception Handler Overwrite Protection)
 *    - Stack protection (canary verification)
 *    - Safe unlinking enforcement
 *    - Heap corruption detection
 *
 * 2. **Code Execution Prevention**
 *    - CFG (Control Flow Guard) enforcement
 *    - CET (Control-flow Enforcement Technology)
 *    - ACG (Arbitrary Code Guard)
 *    - ROP mitigation
 *    - JOP mitigation
 *    - Return address protection
 *
 * 3. **Shellcode Prevention**
 *    - EAF (Export Address Table Access Filtering)
 *    - IAF (Import Address Table Access Filtering)
 *    - Heap spray detection
 *    - Stack pivot detection
 *    - Suspicious memory execution
 *
 * 4. **API Abuse Prevention**
 *    - Critical API hooking
 *    - Dangerous API blocking
 *    - Call stack validation
 *    - API call chain analysis
 *
 * 5. **Vulnerability-Specific Protection**
 *    - UAF (Use-After-Free) detection
 *    - Type confusion detection
 *    - Integer overflow protection
 *    - Format string protection
 *    - Buffer overflow prevention
 *
 * =============================================================================
 * ARCHITECTURE
 * =============================================================================
 *
 * ```
 * ┌─────────────────────────────────────────────────────────────────────────────┐
 * │                          KERNEL MODE                                         │
 * ├─────────────────────────────────────────────────────────────────────────────┤
 * │                                                                              │
 * │  ┌─────────────────────────────────────────────────────────────────────┐   │
 * │  │                    Kernel Exploit Guard                              │   │
 * │  │                                                                       │   │
 * │  │  - Kernel ASLR                                                       │   │
 * │  │  - SMEP (Supervisor Mode Execution Prevention)                       │   │
 * │  │  - SMAP (Supervisor Mode Access Prevention)                          │   │
 * │  │  - Null page protection                                              │   │
 * │  │  - Pool integrity                                                    │   │
 * │  │                                                                       │   │
 * │  └─────────────────────────────────────────────────────────────────────┘   │
 * │                                                                              │
 * └───────────────────────────────────────────────────────────────────────────────┘
 *
 * ┌───────────────────────────────────────────────────────────────────────────────┐
 * │                           USER MODE                                           │
 * ├───────────────────────────────────────────────────────────────────────────────┤
 * │                                                                               │
 * │  ┌─────────────────────────────────────────────────────────────────────┐    │
 * │  │                    ExploitPrevention Engine                          │    │
 * │  │                                                                       │    │
 * │  │  ┌─────────────────────────────────────────────────────────────┐    │    │
 * │  │  │                   Mitigation Manager                         │    │    │
 * │  │  │  - Process mitigation policy (SetProcessMitigationPolicy)   │    │    │
 * │  │  │  - Child process policy                                      │    │    │
 * │  │  │  - System-wide policy                                        │    │    │
 * │  │  └─────────────────────────────────────────────────────────────┘    │    │
 * │  │                                                                       │    │
 * │  │  ┌────────────┐  ┌────────────┐  ┌────────────┐  ┌────────────┐    │    │
 * │  │  │   DEP      │  │   ASLR     │  │   CFG      │  │   CET      │    │    │
 * │  │  │ Enforcer   │  │ Verifier   │  │ Enforcer   │  │ Enforcer   │    │    │
 * │  │  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘  └─────┬──────┘    │    │
 * │  │        │               │               │               │           │    │
 * │  │  ┌─────┴───────────────┴───────────────┴───────────────┴─────┐    │    │
 * │  │  │                    EAF/IAF Engine                          │    │    │
 * │  │  │  - Hardware breakpoints on EAT/IAT access                  │    │    │
 * │  │  │  - Call stack validation                                   │    │    │
 * │  │  │  - Module origin verification                              │    │    │
 * │  │  └───────────────────────────────────────────────────────────┘    │    │
 * │  │                                                                       │    │
 * │  │  ┌───────────────────────────────────────────────────────────┐    │    │
 * │  │  │                   ROP/JOP Detection                        │    │    │
 * │  │  │  - Return address verification                             │    │    │
 * │  │  │  - Stack pivot detection                                   │    │    │
 * │  │  │  - Gadget chain detection                                  │    │    │
 * │  │  │  - Caller validation                                       │    │    │
 * │  │  └───────────────────────────────────────────────────────────┘    │    │
 * │  │                                                                       │    │
 * │  │  ┌───────────────────────────────────────────────────────────┐    │    │
 * │  │  │                   API Monitoring                           │    │    │
 * │  │  │  - VirtualAlloc/Protect monitoring                         │    │    │
 * │  │  │  - CreateThread monitoring                                 │    │    │
 * │  │  │  - LoadLibrary monitoring                                  │    │    │
 * │  │  │  - Syscall validation                                      │    │    │
 * │  │  └───────────────────────────────────────────────────────────┘    │    │
 * │  │                                                                       │    │
 * │  └─────────────────────────────────────────────────────────────────────┘    │
 * │                                                                               │
 * └───────────────────────────────────────────────────────────────────────────────┘
 * ```
 *
 * =============================================================================
 * EXPLOIT MITIGATION MATRIX
 * =============================================================================
 *
 * | Mitigation           | Exploit Type Prevented                             |
 * |----------------------|----------------------------------------------------|
 * | DEP                  | Stack/heap execution, classic shellcode            |
 * | ASLR                 | Fixed address attacks, return-to-libc              |
 * | CFG                  | Indirect call hijacking, vtable corruption         |
 * | CET                  | ROP, shadow stack manipulation                     |
 * | ACG                  | JIT spraying, dynamic code generation              |
 * | SEHOP                | SEH chain corruption                               |
 * | EAF                  | Shellcode API resolution                           |
 * | EAF+                 | ROP gadgets using API calls                        |
 * | Stack Pivot Detect   | Stack pivoting, ROP chain setup                    |
 * | Caller Check         | Shellcode calling critical APIs                    |
 * | Heap Hardening       | Heap overflow, use-after-free                      |
 *
 * =============================================================================
 * MITRE ATT&CK COVERAGE
 * =============================================================================
 *
 * | Technique | Description                          | Mitigation              |
 * |-----------|--------------------------------------|-------------------------|
 * | T1055     | Process Injection                    | Memory protection       |
 * | T1203     | Exploitation for Client Execution    | DEP, ASLR, CFG          |
 * | T1210     | Exploitation of Remote Services      | All mitigations         |
 * | T1211     | Exploitation for Defense Evasion     | EAF, Caller validation  |
 * | T1068     | Exploitation for Privilege Escalation| Kernel mitigations      |
 * | T1212     | Exploitation for Credential Access   | Memory protection       |
 *
 * @note Thread-safe for all public methods
 * @note Requires elevated privileges for process mitigation
 *
 * @see MemoryProtection for injection detection
 * @see BehaviorAnalyzer for exploit chain detection
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @copyright (c) 2026 ShadowStrike Security Suite. All rights reserved.
 */

#pragma once

#include <atomic>
#include <array>
#include <chrono>
#include <cstdint>
#include <functional>
#include <map>
#include <memory>
#include <mutex>
#include <optional>
#include <shared_mutex>
#include <span>
#include <string>
#include <string_view>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// Forward declarations
namespace ShadowStrike {
    namespace Utils {
        class ThreadPool;
    }
    namespace Core {
        namespace Engine {
            class BehaviorAnalyzer;
            class ThreatDetector;
        }
    }
}

namespace ShadowStrike {
namespace RealTime {

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

class ExploitPrevention;
struct ExploitEvent;
struct MitigationPolicy;
struct APICallInfo;

// ============================================================================
// CONSTANTS
// ============================================================================

namespace ExploitPreventionConstants {
    // -------------------------------------------------------------------------
    // Monitoring
    // -------------------------------------------------------------------------
    
    /// @brief Maximum monitored processes
    constexpr size_t MAX_MONITORED_PROCESSES = 10000;
    
    /// @brief Maximum call stack depth to analyze
    constexpr size_t MAX_CALL_STACK_DEPTH = 64;
    
    /// @brief Hardware breakpoint slots available
    constexpr size_t MAX_HW_BREAKPOINTS = 4;
    
    // -------------------------------------------------------------------------
    // Detection Thresholds
    // -------------------------------------------------------------------------
    
    /// @brief Stack pivot detection threshold (bytes from original)
    constexpr size_t STACK_PIVOT_THRESHOLD = 4096;
    
    /// @brief Minimum ROP gadget chain length for detection
    constexpr size_t MIN_ROP_CHAIN_LENGTH = 5;
    
    /// @brief Maximum allowed heap spray allocations per second
    constexpr size_t HEAP_SPRAY_THRESHOLD_PER_SEC = 100;
    
    // -------------------------------------------------------------------------
    // Risk Scores
    // -------------------------------------------------------------------------
    
    /// @brief DEP violation score
    constexpr double DEP_VIOLATION_SCORE = 90.0;
    
    /// @brief ROP detected score
    constexpr double ROP_DETECTION_SCORE = 85.0;
    
    /// @brief EAF trigger score
    constexpr double EAF_TRIGGER_SCORE = 70.0;
    
    /// @brief Stack pivot score
    constexpr double STACK_PIVOT_SCORE = 80.0;
    
    /// @brief Suspicious API call score
    constexpr double SUSPICIOUS_API_SCORE = 60.0;
}

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief Mitigation type.
 */
enum class MitigationType : uint16_t {
    /// @brief Unknown
    Unknown = 0,
    
    // -------------------------------------------------------------------------
    // Memory Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Data Execution Prevention
    DEP = 1,
    
    /// @brief Address Space Layout Randomization
    ASLR = 2,
    
    /// @brief High-entropy ASLR
    HighEntropyASLR = 3,
    
    /// @brief Force relocate images
    ForceRelocateImages = 4,
    
    /// @brief Bottom-up ASLR
    BottomUpASLR = 5,
    
    // -------------------------------------------------------------------------
    // Code Flow Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Control Flow Guard
    CFG = 10,
    
    /// @brief Control-flow Enforcement Technology
    CET = 11,
    
    /// @brief Arbitrary Code Guard
    ACG = 12,
    
    /// @brief Dynamic code disable
    DynamicCodeDisable = 13,
    
    /// @brief Block non-Microsoft signed binaries
    SignatureRestriction = 14,
    
    // -------------------------------------------------------------------------
    // Exception Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief SEHOP
    SEHOP = 20,
    
    /// @brief Validate exception chains
    ValidateExceptionChain = 21,
    
    // -------------------------------------------------------------------------
    // Heap Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Heap terminate on corruption
    HeapTerminate = 30,
    
    /// @brief Safe unlinking
    SafeUnlinking = 31,
    
    // -------------------------------------------------------------------------
    // Import/Export Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Export Address Table filtering
    EAF = 40,
    
    /// @brief Export Address Table filtering plus
    EAFPlus = 41,
    
    /// @brief Import Address Table filtering
    IAF = 42,
    
    // -------------------------------------------------------------------------
    // Loader Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Block remote image loads
    BlockRemoteImage = 50,
    
    /// @brief Block low-integrity image loads
    BlockLowIntegrityImage = 51,
    
    /// @brief Prefer system32 images
    PreferSystem32 = 52,
    
    // -------------------------------------------------------------------------
    // Child Process Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Block child process creation
    BlockChildProcess = 60,
    
    /// @brief Restrict child process token
    RestrictChildToken = 61,
    
    // -------------------------------------------------------------------------
    // API Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Win32k system call disable
    Win32kDisable = 70,
    
    /// @brief Filter system calls
    SyscallFilter = 71,
    
    // -------------------------------------------------------------------------
    // Custom Mitigations
    // -------------------------------------------------------------------------
    
    /// @brief Stack pivot detection
    StackPivotDetection = 100,
    
    /// @brief ROP detection
    ROPDetection = 101,
    
    /// @brief Caller validation
    CallerValidation = 102,
    
    /// @brief API call chain validation
    APIChainValidation = 103
};

/**
 * @brief Exploit type detected.
 */
enum class ExploitType : uint16_t {
    /// @brief Unknown
    Unknown = 0,
    
    /// @brief Stack buffer overflow
    StackBufferOverflow = 1,
    
    /// @brief Heap buffer overflow
    HeapBufferOverflow = 2,
    
    /// @brief Integer overflow
    IntegerOverflow = 3,
    
    /// @brief Use after free
    UseAfterFree = 4,
    
    /// @brief Type confusion
    TypeConfusion = 5,
    
    /// @brief Format string
    FormatString = 6,
    
    /// @brief SEH overwrite
    SEHOverwrite = 7,
    
    /// @brief Return address overwrite
    ReturnAddressOverwrite = 8,
    
    /// @brief Vtable corruption
    VtableCorruption = 9,
    
    /// @brief ROP chain execution
    ROPExecution = 10,
    
    /// @brief JOP chain execution
    JOPExecution = 11,
    
    /// @brief Heap spray
    HeapSpray = 12,
    
    /// @brief Stack pivot
    StackPivot = 13,
    
    /// @brief Shellcode execution
    ShellcodeExecution = 14,
    
    /// @brief Null pointer dereference
    NullPointerDeref = 15,
    
    /// @brief Double free
    DoubleFree = 16,
    
    /// @brief Uninitialized memory
    UninitializedMemory = 17
};

/**
 * @brief Mitigation status.
 */
enum class ExploitMitigationStatus : uint8_t {
    /// @brief Unknown
    Unknown = 0,
    
    /// @brief Enabled
    Enabled = 1,
    
    /// @brief Disabled
    Disabled = 2,
    
    /// @brief Not supported
    NotSupported = 3,
    
    /// @brief Partial (some features enabled)
    Partial = 4,
    
    /// @brief Enforced (cannot be disabled)
    Enforced = 5
};

/**
 * @brief Exploit prevention action.
 */
enum class ExploitAction : uint8_t {
    /// @brief Allow (log only)
    Allow = 0,
    
    /// @brief Block operation
    Block = 1,
    
    /// @brief Terminate process
    Terminate = 2,
    
    /// @brief Raise exception
    RaiseException = 3,
    
    /// @brief Alert and continue
    Alert = 4
};

/**
 * @brief Get string for MitigationType.
 */
[[nodiscard]] constexpr const char* MitigationTypeToString(MitigationType type) noexcept;

/**
 * @brief Get string for ExploitType.
 */
[[nodiscard]] constexpr const char* ExploitTypeToString(ExploitType type) noexcept;

/**
 * @brief Get MITRE technique for exploit type.
 */
[[nodiscard]] constexpr const char* ExploitTypeToMitre(ExploitType type) noexcept;

// ============================================================================
// DATA STRUCTURES
// ============================================================================

/**
 * @brief Mitigation status for a process.
 */
struct ProcessMitigationStatus {
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief DEP status
    ExploitMitigationStatus dep = ExploitMitigationStatus::Unknown;
    
    /// @brief Permanent DEP
    bool depPermanent = false;
    
    /// @brief ATL thunk emulation disabled
    bool depATLThunkDisable = false;
    
    /// @brief ASLR status
    ExploitMitigationStatus aslr = ExploitMitigationStatus::Unknown;
    
    /// @brief High-entropy ASLR
    ExploitMitigationStatus highEntropyASLR = ExploitMitigationStatus::Unknown;
    
    /// @brief Bottom-up ASLR
    ExploitMitigationStatus bottomUpASLR = ExploitMitigationStatus::Unknown;
    
    /// @brief Force relocate images
    ExploitMitigationStatus forceRelocate = ExploitMitigationStatus::Unknown;
    
    /// @brief CFG status
    ExploitMitigationStatus cfg = ExploitMitigationStatus::Unknown;
    
    /// @brief CFG strict mode
    bool cfgStrict = false;
    
    /// @brief CFG export suppression
    bool cfgExportSuppression = false;
    
    /// @brief CET status
    ExploitMitigationStatus cet = ExploitMitigationStatus::Unknown;
    
    /// @brief ACG status
    ExploitMitigationStatus acg = ExploitMitigationStatus::Unknown;
    
    /// @brief Allow thread opt-out
    bool acgAllowThreadOptOut = false;
    
    /// @brief SEHOP status
    ExploitMitigationStatus sehop = ExploitMitigationStatus::Unknown;
    
    /// @brief Heap terminate on corruption
    ExploitMitigationStatus heapTerminate = ExploitMitigationStatus::Unknown;
    
    /// @brief Win32k system call disable
    ExploitMitigationStatus win32kDisable = ExploitMitigationStatus::Unknown;
    
    /// @brief Block remote image
    ExploitMitigationStatus blockRemoteImage = ExploitMitigationStatus::Unknown;
    
    /// @brief Block low integrity image
    ExploitMitigationStatus blockLowIntegrity = ExploitMitigationStatus::Unknown;
    
    /// @brief Block child process
    ExploitMitigationStatus blockChildProcess = ExploitMitigationStatus::Unknown;
    
    /// @brief Dynamic code disable
    ExploitMitigationStatus dynamicCode = ExploitMitigationStatus::Unknown;
    
    /// @brief Extension point disable
    ExploitMitigationStatus extensionPoint = ExploitMitigationStatus::Unknown;
    
    /// @brief Signature restriction
    ExploitMitigationStatus signatureRestriction = ExploitMitigationStatus::Unknown;
    
    /// @brief Custom EAF status
    ExploitMitigationStatus eaf = ExploitMitigationStatus::Unknown;
    
    /// @brief Custom IAF status
    ExploitMitigationStatus iaf = ExploitMitigationStatus::Unknown;
    
    /// @brief Custom ROP detection status
    ExploitMitigationStatus ropDetection = ExploitMitigationStatus::Unknown;
    
    /// @brief Custom stack pivot detection
    ExploitMitigationStatus stackPivotDetection = ExploitMitigationStatus::Unknown;
    
    /// @brief Custom caller validation
    ExploitMitigationStatus callerValidation = ExploitMitigationStatus::Unknown;
    
    /// @brief Last check time
    std::chrono::system_clock::time_point lastCheck{};
};

/**
 * @brief Exploit detection event.
 */
struct ExploitEvent {
    /// @brief Event ID
    uint64_t eventId = 0;
    
    /// @brief Event timestamp
    std::chrono::system_clock::time_point timestamp{};
    
    /// @brief Exploit type detected
    ExploitType exploitType = ExploitType::Unknown;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Thread ID
    uint32_t threadId = 0;
    
    /// @brief Instruction pointer
    uintptr_t instructionPointer = 0;
    
    /// @brief Stack pointer
    uintptr_t stackPointer = 0;
    
    /// @brief Faulting address
    uintptr_t faultingAddress = 0;
    
    /// @brief Mitigation that triggered
    MitigationType mitigationType = MitigationType::Unknown;
    
    /// @brief Module name (if known)
    std::wstring moduleName;
    
    /// @brief Function name (if known)
    std::string functionName;
    
    /// @brief Risk score
    double riskScore = 0.0;
    
    /// @brief Confidence level
    double confidence = 0.0;
    
    /// @brief Action taken
    ExploitAction actionTaken = ExploitAction::Allow;
    
    /// @brief MITRE technique
    std::string mitreTechnique;
    
    /// @brief Call stack
    std::vector<uintptr_t> callStack;
    
    /// @brief Call stack symbols
    std::vector<std::string> callStackSymbols;
    
    /// @brief Additional context
    std::map<std::string, std::wstring> context;
    
    /// @brief Evidence data
    std::vector<uint8_t> evidence;
};

/**
 * @brief API call information for validation.
 */
struct APICallInfo {
    /// @brief API name
    std::string apiName;
    
    /// @brief Module containing API
    std::wstring moduleName;
    
    /// @brief API address
    uintptr_t apiAddress = 0;
    
    /// @brief Return address
    uintptr_t returnAddress = 0;
    
    /// @brief Caller module
    std::wstring callerModule;
    
    /// @brief Stack pointer at call
    uintptr_t stackPointer = 0;
    
    /// @brief Is return address in executable region
    bool returnAddressInCode = true;
    
    /// @brief Is caller from legitimate module
    bool callerLegitimate = true;
    
    /// @brief Call stack depth
    size_t callStackDepth = 0;
};

/**
 * @brief ROP chain detection result.
 */
struct ROPDetectionResult {
    /// @brief ROP chain detected
    bool detected = false;
    
    /// @brief Confidence (0-100)
    double confidence = 0.0;
    
    /// @brief Number of gadgets found
    size_t gadgetCount = 0;
    
    /// @brief Gadget addresses
    std::vector<uintptr_t> gadgetAddresses;
    
    /// @brief Gadget modules
    std::vector<std::wstring> gadgetModules;
    
    /// @brief Stack pivot detected
    bool stackPivot = false;
    
    /// @brief Original stack pointer
    uintptr_t originalStackPointer = 0;
    
    /// @brief Current stack pointer
    uintptr_t currentStackPointer = 0;
};

/**
 * @brief EAF/IAF trigger event.
 */
struct TableAccessEvent {
    /// @brief Event timestamp
    std::chrono::system_clock::time_point timestamp{};
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Thread ID
    uint32_t threadId = 0;
    
    /// @brief Is EAT access (vs IAT)
    bool isEAT = true;
    
    /// @brief Target module
    std::wstring targetModule;
    
    /// @brief Target function
    std::string targetFunction;
    
    /// @brief Access address
    uintptr_t accessAddress = 0;
    
    /// @brief Caller address
    uintptr_t callerAddress = 0;
    
    /// @brief Caller module
    std::wstring callerModule;
    
    /// @brief Is caller from legitimate code
    bool callerLegitimate = false;
    
    /// @brief Call stack
    std::vector<uintptr_t> callStack;
};

/**
 * @brief Mitigation policy configuration.
 */
struct MitigationPolicy {
    /// @brief Policy name
    std::wstring name;
    
    /// @brief Policy description
    std::wstring description;
    
    /// @brief Enable DEP
    bool enableDEP = true;
    
    /// @brief DEP permanent
    bool depPermanent = true;
    
    /// @brief Enable ASLR
    bool enableASLR = true;
    
    /// @brief Enable high-entropy ASLR
    bool enableHighEntropyASLR = true;
    
    /// @brief Enable CFG
    bool enableCFG = true;
    
    /// @brief CFG strict mode
    bool cfgStrict = false;
    
    /// @brief Enable CET
    bool enableCET = false;  // Requires hardware support
    
    /// @brief Enable ACG
    bool enableACG = false;  // May break some apps
    
    /// @brief Enable SEHOP
    bool enableSEHOP = true;
    
    /// @brief Enable heap terminate
    bool enableHeapTerminate = true;
    
    /// @brief Block remote images
    bool blockRemoteImages = false;
    
    /// @brief Block low integrity images
    bool blockLowIntegrityImages = false;
    
    /// @brief Disable dynamic code
    bool disableDynamicCode = false;
    
    /// @brief Enable custom EAF
    bool enableEAF = true;
    
    /// @brief Enable custom IAF
    bool enableIAF = false;
    
    /// @brief Enable ROP detection
    bool enableROPDetection = true;
    
    /// @brief Enable stack pivot detection
    bool enableStackPivotDetection = true;
    
    /// @brief Enable caller validation
    bool enableCallerValidation = true;
    
    /// @brief Applies to specific processes (empty = all)
    std::vector<std::wstring> targetProcesses;
    
    /// @brief Excluded processes
    std::vector<std::wstring> excludedProcesses;
};

/**
 * @brief Configuration for exploit prevention.
 */
struct ExploitPreventionConfig {
    // -------------------------------------------------------------------------
    // General Settings
    // -------------------------------------------------------------------------
    
    /// @brief Enable exploit prevention
    bool enabled = true;
    
    /// @brief Apply mitigations to new processes
    bool autoApplyMitigations = true;
    
    /// @brief Monitor for exploit attempts
    bool monitorExploits = true;
    
    // -------------------------------------------------------------------------
    // Action Settings
    // -------------------------------------------------------------------------
    
    /// @brief Default action on exploit detection
    ExploitAction defaultAction = ExploitAction::Block;
    
    /// @brief Action for high-confidence detections
    ExploitAction highConfidenceAction = ExploitAction::Terminate;
    
    /// @brief Confidence threshold for high-confidence action
    double highConfidenceThreshold = 90.0;
    
    // -------------------------------------------------------------------------
    // Mitigation Settings
    // -------------------------------------------------------------------------
    
    /// @brief Default mitigation policy
    MitigationPolicy defaultPolicy;
    
    /// @brief Enforce system-wide mitigations
    bool enforceSystemWide = false;
    
    /// @brief Verify mitigations periodically
    bool periodicVerification = true;
    
    /// @brief Verification interval (seconds)
    uint32_t verificationIntervalSec = 60;
    
    // -------------------------------------------------------------------------
    // Detection Settings
    // -------------------------------------------------------------------------
    
    /// @brief Enable EAF
    bool enableEAF = true;
    
    /// @brief EAF modules to protect
    std::vector<std::wstring> eafProtectedModules;
    
    /// @brief Enable ROP detection
    bool enableROPDetection = true;
    
    /// @brief Enable stack pivot detection
    bool enableStackPivotDetection = true;
    
    /// @brief Enable heap spray detection
    bool enableHeapSprayDetection = true;
    
    // -------------------------------------------------------------------------
    // Factory Methods
    // -------------------------------------------------------------------------
    
    /**
     * @brief Create default configuration.
     */
    [[nodiscard]] static ExploitPreventionConfig CreateDefault() noexcept {
        ExploitPreventionConfig config;
        config.defaultPolicy.name = L"Default";
        config.eafProtectedModules = {
            L"kernel32.dll",
            L"kernelbase.dll",
            L"ntdll.dll"
        };
        return config;
    }
    
    /**
     * @brief Create strict configuration.
     */
    [[nodiscard]] static ExploitPreventionConfig CreateStrict() noexcept {
        ExploitPreventionConfig config = CreateDefault();
        config.defaultAction = ExploitAction::Terminate;
        config.highConfidenceThreshold = 70.0;
        config.defaultPolicy.enableACG = true;
        config.defaultPolicy.blockRemoteImages = true;
        config.defaultPolicy.blockLowIntegrityImages = true;
        config.defaultPolicy.enableIAF = true;
        return config;
    }
    
    /**
     * @brief Create compatible configuration (for legacy apps).
     */
    [[nodiscard]] static ExploitPreventionConfig CreateCompatible() noexcept {
        ExploitPreventionConfig config;
        config.defaultAction = ExploitAction::Alert;
        config.defaultPolicy.enableACG = false;
        config.defaultPolicy.disableDynamicCode = false;
        config.enableEAF = false;  // May cause compatibility issues
        return config;
    }
};

/**
 * @brief Exploit prevention statistics.
 */
struct ExploitPreventionStats {
    /// @brief Total exploit events
    std::atomic<uint64_t> totalEvents{ 0 };
    
    /// @brief Exploits blocked
    std::atomic<uint64_t> exploitsBlocked{ 0 };
    
    /// @brief Processes terminated
    std::atomic<uint64_t> processesTerminated{ 0 };
    
    /// @brief DEP violations
    std::atomic<uint64_t> depViolations{ 0 };
    
    /// @brief CFG violations
    std::atomic<uint64_t> cfgViolations{ 0 };
    
    /// @brief EAF triggers
    std::atomic<uint64_t> eafTriggers{ 0 };
    
    /// @brief IAF triggers
    std::atomic<uint64_t> iafTriggers{ 0 };
    
    /// @brief ROP detections
    std::atomic<uint64_t> ropDetections{ 0 };
    
    /// @brief Stack pivot detections
    std::atomic<uint64_t> stackPivotDetections{ 0 };
    
    /// @brief Heap spray detections
    std::atomic<uint64_t> heapSprayDetections{ 0 };
    
    /// @brief Mitigations applied
    std::atomic<uint64_t> mitigationsApplied{ 0 };
    
    /// @brief Processes with mitigations
    std::atomic<size_t> processesWithMitigations{ 0 };
    
    /**
     * @brief Reset all statistics.
     */
    void Reset() noexcept {
        totalEvents.store(0, std::memory_order_relaxed);
        exploitsBlocked.store(0, std::memory_order_relaxed);
        processesTerminated.store(0, std::memory_order_relaxed);
        depViolations.store(0, std::memory_order_relaxed);
        cfgViolations.store(0, std::memory_order_relaxed);
        eafTriggers.store(0, std::memory_order_relaxed);
        iafTriggers.store(0, std::memory_order_relaxed);
        ropDetections.store(0, std::memory_order_relaxed);
        stackPivotDetections.store(0, std::memory_order_relaxed);
        heapSprayDetections.store(0, std::memory_order_relaxed);
        mitigationsApplied.store(0, std::memory_order_relaxed);
        processesWithMitigations.store(0, std::memory_order_relaxed);
    }
};

/**
 * @brief Callback types.
 */
using ExploitCallback = std::function<ExploitAction(const ExploitEvent&)>;
using EAFCallback = std::function<ExploitAction(const TableAccessEvent&)>;
using ROPCallback = std::function<ExploitAction(uint32_t pid, const ROPDetectionResult&)>;
using MitigationCallback = std::function<void(uint32_t pid, MitigationType, bool success)>;

// ============================================================================
// MAIN EXPLOIT PREVENTION CLASS
// ============================================================================

/**
 * @brief Enterprise-grade exploit mitigation and prevention.
 *
 * Provides comprehensive exploit prevention including memory mitigations,
 * code flow protection, and shellcode prevention.
 *
 * Thread Safety: All public methods are thread-safe.
 *
 * Usage Example:
 * @code
 * auto& exploitPrev = ExploitPrevention::Instance();
 * 
 * // Initialize
 * ExploitPreventionConfig config = ExploitPreventionConfig::CreateDefault();
 * exploitPrev.Initialize(threadPool, config);
 * 
 * // Register callbacks
 * exploitPrev.RegisterExploitCallback([](const ExploitEvent& event) {
 *     LOG_WARN("Exploit detected: {} in process {} ({})",
 *              ExploitTypeToString(event.exploitType),
 *              event.processId, event.processName);
 *     return ExploitAction::Terminate;
 * });
 * 
 * // Start protection
 * exploitPrev.Start();
 * 
 * // Apply mitigations to new process
 * exploitPrev.ApplyMitigations(newPid);
 * 
 * // Check mitigation status
 * auto status = exploitPrev.GetMitigationStatus(targetPid);
 * if (status.dep == ExploitMitigationStatus::Disabled) {
 *     LOG_WARN("DEP disabled for process {}", targetPid);
 * }
 * 
 * // Enable specific mitigation
 * exploitPrev.EnableMitigation(targetPid, MitigationType::CFG);
 * 
 * exploitPrev.Stop();
 * exploitPrev.Shutdown();
 * @endcode
 */
class ExploitPrevention {
public:
    // =========================================================================
    // Singleton Access
    // =========================================================================

    /**
     * @brief Get the singleton instance.
     */
    [[nodiscard]] static ExploitPrevention& Instance();

    // Non-copyable, non-movable
    ExploitPrevention(const ExploitPrevention&) = delete;
    ExploitPrevention& operator=(const ExploitPrevention&) = delete;
    ExploitPrevention(ExploitPrevention&&) = delete;
    ExploitPrevention& operator=(ExploitPrevention&&) = delete;

    // =========================================================================
    // Lifecycle Management
    // =========================================================================

    /**
     * @brief Initialize exploit prevention.
     */
    [[nodiscard]] bool Initialize();

    /**
     * @brief Initialize with thread pool.
     */
    [[nodiscard]] bool Initialize(std::shared_ptr<Utils::ThreadPool> threadPool);

    /**
     * @brief Initialize with configuration.
     */
    [[nodiscard]] bool Initialize(
        std::shared_ptr<Utils::ThreadPool> threadPool,
        const ExploitPreventionConfig& config
    );

    /**
     * @brief Shutdown exploit prevention.
     */
    void Shutdown();

    /**
     * @brief Start protection.
     */
    void Start();

    /**
     * @brief Stop protection.
     */
    void Stop();

    /**
     * @brief Check if protection is running.
     */
    [[nodiscard]] bool IsRunning() const noexcept;

    /**
     * @brief Update configuration.
     */
    void UpdateConfig(const ExploitPreventionConfig& config);

    /**
     * @brief Get current configuration.
     */
    [[nodiscard]] ExploitPreventionConfig GetConfig() const;

    // =========================================================================
    // Mitigation Management
    // =========================================================================

    /**
     * @brief Apply mitigations to a process.
     */
    bool ApplyMitigations(uint32_t pid);

    /**
     * @brief Apply specific mitigation.
     */
    bool EnableMitigation(uint32_t pid, MitigationType mitigation);

    /**
     * @brief Disable specific mitigation.
     */
    bool DisableMitigation(uint32_t pid, MitigationType mitigation);

    /**
     * @brief Apply mitigation policy.
     */
    bool ApplyPolicy(uint32_t pid, const MitigationPolicy& policy);

    /**
     * @brief Get mitigation status for process.
     */
    [[nodiscard]] ProcessMitigationStatus GetMitigationStatus(uint32_t pid);

    /**
     * @brief Verify mitigations are active.
     */
    bool VerifyMitigations(uint32_t pid);

    /**
     * @brief Get all processes with mitigations.
     */
    [[nodiscard]] std::vector<ProcessMitigationStatus> GetAllMitigationStatus() const;

    // =========================================================================
    // EAF/IAF Management
    // =========================================================================

    /**
     * @brief Enable EAF for process.
     */
    bool EnableEAF(uint32_t pid);

    /**
     * @brief Disable EAF for process.
     */
    void DisableEAF(uint32_t pid);

    /**
     * @brief Enable IAF for process.
     */
    bool EnableIAF(uint32_t pid);

    /**
     * @brief Disable IAF for process.
     */
    void DisableIAF(uint32_t pid);

    /**
     * @brief Add module to EAF protection.
     */
    void AddEAFModule(const std::wstring& moduleName);

    /**
     * @brief Remove module from EAF protection.
     */
    void RemoveEAFModule(const std::wstring& moduleName);

    /**
     * @brief Get EAF protected modules.
     */
    [[nodiscard]] std::vector<std::wstring> GetEAFModules() const;

    // =========================================================================
    // Detection
    // =========================================================================

    /**
     * @brief Check for ROP chain.
     */
    [[nodiscard]] ROPDetectionResult DetectROP(uint32_t pid, uint32_t threadId);

    /**
     * @brief Check for stack pivot.
     */
    [[nodiscard]] bool DetectStackPivot(uint32_t pid, uint32_t threadId);

    /**
     * @brief Validate API call.
     */
    [[nodiscard]] bool ValidateAPICall(const APICallInfo& callInfo);

    /**
     * @brief Check if address is in legitimate module.
     */
    [[nodiscard]] bool IsAddressInLegitimateModule(uint32_t pid, uintptr_t address);

    /**
     * @brief Get call stack for thread.
     */
    [[nodiscard]] std::vector<uintptr_t> CaptureCallStack(uint32_t pid, uint32_t threadId);

    // =========================================================================
    // Event Handling
    // =========================================================================

    /**
     * @brief Handle exploit event.
     */
    ExploitAction OnExploitDetected(const ExploitEvent& event);

    /**
     * @brief Handle EAF/IAF trigger.
     */
    ExploitAction OnTableAccess(const TableAccessEvent& event);

    /**
     * @brief Handle exception (for SEHOP, etc.).
     */
    void OnException(uint32_t pid, uint32_t threadId, uint32_t exceptionCode, uintptr_t address);

    // =========================================================================
    // Query
    // =========================================================================

    /**
     * @brief Get recent exploit events.
     */
    [[nodiscard]] std::vector<ExploitEvent> GetRecentEvents(size_t count = 100) const;

    /**
     * @brief Get exploit events for process.
     */
    [[nodiscard]] std::vector<ExploitEvent> GetProcessEvents(uint32_t pid) const;

    /**
     * @brief Check if process is protected.
     */
    [[nodiscard]] bool IsProcessProtected(uint32_t pid) const;

    // =========================================================================
    // Policy Management
    // =========================================================================

    /**
     * @brief Add mitigation policy.
     */
    void AddPolicy(const std::wstring& name, const MitigationPolicy& policy);

    /**
     * @brief Remove mitigation policy.
     */
    void RemovePolicy(const std::wstring& name);

    /**
     * @brief Get policy by name.
     */
    [[nodiscard]] std::optional<MitigationPolicy> GetPolicy(const std::wstring& name) const;

    /**
     * @brief Get all policies.
     */
    [[nodiscard]] std::vector<MitigationPolicy> GetAllPolicies() const;

    /**
     * @brief Load policies from file.
     */
    bool LoadPoliciesFromFile(const std::wstring& filePath);

    /**
     * @brief Save policies to file.
     */
    bool SavePoliciesToFile(const std::wstring& filePath) const;

    // =========================================================================
    // Statistics
    // =========================================================================

    /**
     * @brief Get statistics.
     */
    [[nodiscard]] ExploitPreventionStats GetStats() const;

    /**
     * @brief Reset statistics.
     */
    void ResetStats();

    // =========================================================================
    // Callbacks
    // =========================================================================

    /**
     * @brief Register exploit callback.
     */
    [[nodiscard]] uint64_t RegisterExploitCallback(ExploitCallback callback);

    /**
     * @brief Unregister exploit callback.
     */
    bool UnregisterExploitCallback(uint64_t callbackId);

    /**
     * @brief Register EAF callback.
     */
    [[nodiscard]] uint64_t RegisterEAFCallback(EAFCallback callback);

    /**
     * @brief Unregister EAF callback.
     */
    bool UnregisterEAFCallback(uint64_t callbackId);

    /**
     * @brief Register ROP callback.
     */
    [[nodiscard]] uint64_t RegisterROPCallback(ROPCallback callback);

    /**
     * @brief Unregister ROP callback.
     */
    bool UnregisterROPCallback(uint64_t callbackId);

    /**
     * @brief Register mitigation callback.
     */
    [[nodiscard]] uint64_t RegisterMitigationCallback(MitigationCallback callback);

    /**
     * @brief Unregister mitigation callback.
     */
    bool UnregisterMitigationCallback(uint64_t callbackId);

    // =========================================================================
    // External Integration
    // =========================================================================

    /**
     * @brief Set behavior analyzer.
     */
    void SetBehaviorAnalyzer(Core::Engine::BehaviorAnalyzer* analyzer);

    /**
     * @brief Set threat detector.
     */
    void SetThreatDetector(Core::Engine::ThreatDetector* detector);

private:
    // =========================================================================
    // Private Constructor (Singleton)
    // =========================================================================

    ExploitPrevention();
    ~ExploitPrevention();

    // =========================================================================
    // Internal Methods
    // =========================================================================

    /**
     * @brief Apply Windows process mitigations.
     */
    bool ApplyWindowsMitigations(uint32_t pid, const MitigationPolicy& policy);

    /**
     * @brief Setup hardware breakpoints for EAF.
     */
    bool SetupEAFBreakpoints(uint32_t pid);

    /**
     * @brief Cleanup hardware breakpoints.
     */
    void CleanupEAFBreakpoints(uint32_t pid);

    /**
     * @brief Verify call stack integrity.
     */
    bool VerifyCallStack(uint32_t pid, const std::vector<uintptr_t>& stack);

    /**
     * @brief Background verification thread.
     */
    void VerificationThread();

    /**
     * @brief Invoke exploit callbacks.
     */
    ExploitAction InvokeExploitCallbacks(const ExploitEvent& event);

    /**
     * @brief Invoke EAF callbacks.
     */
    ExploitAction InvokeEAFCallbacks(const TableAccessEvent& event);

    /**
     * @brief Invoke ROP callbacks.
     */
    ExploitAction InvokeROPCallbacks(uint32_t pid, const ROPDetectionResult& result);

    // =========================================================================
    // Internal Data (PIMPL)
    // =========================================================================

    struct Impl;
    std::unique_ptr<Impl> m_impl;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * @brief Check if CPU supports CET.
 */
[[nodiscard]] bool IsCETSupported() noexcept;

/**
 * @brief Check if process has CFG enabled.
 */
[[nodiscard]] bool IsProcessCFGEnabled(uint32_t pid) noexcept;

/**
 * @brief Get process image base.
 */
[[nodiscard]] uintptr_t GetProcessImageBase(uint32_t pid) noexcept;

/**
 * @brief Resolve symbol for address.
 */
[[nodiscard]] std::string ResolveSymbol(uint32_t pid, uintptr_t address) noexcept;

/**
 * @brief Get module for address.
 */
[[nodiscard]] std::wstring GetModuleForAddress(uint32_t pid, uintptr_t address) noexcept;

/**
 * @brief Check if address is in executable memory.
 */
[[nodiscard]] bool IsAddressExecutable(uint32_t pid, uintptr_t address) noexcept;

} // namespace RealTime
} // namespace ShadowStrike
