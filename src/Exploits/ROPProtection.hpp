/*
 * ShadowStrike - Enterprise NGAV/EDR Platform
 * Copyright (C) 2026 ShadowStrike Security
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
/**
 * ============================================================================
 * ShadowStrike NGAV - ROP PROTECTION
 * ============================================================================
 *
 * @file ROPProtection.hpp
 * @brief Enterprise-grade protection against Return-Oriented Programming (ROP)
 *        chains and code-reuse attacks.
 *
 * Provides comprehensive detection and prevention of ROP exploitation through
 * shadow stack implementation, return address validation, and gadget analysis.
 *
 * PROTECTION MECHANISMS:
 * ======================
 *
 * 1. SHADOW STACK
 *    - Software shadow stack implementation
 *    - Hardware CET integration (Intel/AMD)
 *    - Return address tracking
 *    - Stack frame validation
 *
 * 2. RETURN ADDRESS VALIDATION
 *    - CALL/RET balance checking
 *    - Return address bounds validation
 *    - Module range verification
 *    - Stack pointer validation
 *
 * 3. CRITICAL API PROTECTION
 *    - VirtualProtect/VirtualAlloc monitoring
 *    - NtProtectVirtualMemory hooks
 *    - CreateProcess/LoadLibrary validation
 *    - Return address verification at API entry
 *
 * 4. GADGET CHAIN DETECTION
 *    - Stack scanning for gadget sequences
 *    - RET gadget identification
 *    - JOP (Jump-Oriented Programming) detection
 *    - COP (Call-Oriented Programming) detection
 *
 * 5. EXPLOIT PATTERN RECOGNITION
 *    - Known ROP chain signatures
 *    - Shellcode execution patterns
 *    - Stack pivot indicators
 *    - Memory preparation sequences
 *
 * 6. POST-CRASH ANALYSIS
 *    - ROP chain reconstruction
 *    - Gadget disassembly
 *    - Attack attribution
 *    - Forensic evidence collection
 *
 * INTEGRATION:
 * ============
 * - StackPivotDetector for pivot detection
 * - BufferOverflowProtection for memory safety
 * - Utils::MemoryUtils for memory operations
 *
 * @note Full protection requires code injection into target process.
 * @note Hardware CET requires supported CPU and OS.
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#pragma once

// ============================================================================
// STANDARD LIBRARY INCLUDES
// ============================================================================

#include <cstdint>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>
#include <array>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <optional>
#include <memory>
#include <functional>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <span>

// ============================================================================
// WINDOWS SDK INCLUDES
// ============================================================================

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// ============================================================================
// SHADOWSTRIKE INFRASTRUCTURE INCLUDES
// ============================================================================

#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/MemoryUtils.hpp"
#include "../SignatureStore/SignatureStore.hpp"

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

namespace ShadowStrike::Exploits {
    class ROPProtectionImpl;
}

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// COMPILE-TIME CONSTANTS
// ============================================================================

namespace ROPConstants {

    inline constexpr uint32_t VERSION_MAJOR = 3;
    inline constexpr uint32_t VERSION_MINOR = 0;
    inline constexpr uint32_t VERSION_PATCH = 0;

    /// @brief Maximum shadow stack entries per thread
    inline constexpr size_t MAX_SHADOW_STACK_ENTRIES = 4096;
    
    /// @brief Maximum gadget chain length to analyze
    inline constexpr size_t MAX_GADGET_CHAIN_LENGTH = 256;
    
    /// @brief Maximum protected APIs
    inline constexpr size_t MAX_PROTECTED_APIS = 128;
    
    /// @brief Gadget scan depth (bytes)
    inline constexpr size_t GADGET_SCAN_DEPTH = 32;
    
    /// @brief Common RET opcodes
    inline constexpr uint8_t RET_OPCODE = 0xC3;
    inline constexpr uint8_t RETN_OPCODE = 0xC2;
    inline constexpr uint8_t RETF_OPCODE = 0xCB;
    inline constexpr uint8_t RETFN_OPCODE = 0xCA;

}  // namespace ROPConstants

// ============================================================================
// TYPE ALIASES
// ============================================================================

using Clock = std::chrono::steady_clock;
using TimePoint = std::chrono::steady_clock::time_point;
using SystemTimePoint = std::chrono::system_clock::time_point;

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief ROP detection method
 */
enum class RopDetectionMethod : uint8_t {
    Unknown                     = 0,
    ShadowStackMismatch         = 1,    ///< Shadow stack return mismatch
    StackPointerOutOfBounds     = 2,    ///< RSP outside valid range
    ReturnAddressInvalid        = 3,    ///< Return to non-executable
    CallRetMismatch             = 4,    ///< CALL/RET not balanced
    HeuristicGadgetScan         = 5,    ///< Gadget chain on stack
    PatternMatch                = 6,    ///< Known ROP chain signature
    ApiReturnValidation         = 7,    ///< Failed API return check
    HardwareCET                 = 8     ///< Intel CET violation
};

/**
 * @brief Gadget type
 */
enum class GadgetType : uint8_t {
    Unknown     = 0,
    RetGadget   = 1,    ///< Ends with RET
    RetNGadget  = 2,    ///< Ends with RET N
    JmpGadget   = 3,    ///< JOP gadget
    CallGadget  = 4,    ///< COP gadget
    SyscallGadget = 5,  ///< Syscall gadget
    IntGadget   = 6     ///< INT gadget
};

/**
 * @brief Code-reuse attack type
 */
enum class CodeReuseType : uint8_t {
    Unknown     = 0,
    ROP         = 1,    ///< Return-Oriented Programming
    JOP         = 2,    ///< Jump-Oriented Programming
    COP         = 3,    ///< Call-Oriented Programming
    SOP         = 4,    ///< Sigreturn-Oriented Programming
    BROP        = 5,    ///< Blind ROP
    COOP        = 6     ///< Counterfeit Object-Oriented Programming
};

/**
 * @brief Protected API category
 */
enum class ProtectedApiCategory : uint8_t {
    Unknown             = 0,
    MemoryAllocation    = 1,    ///< VirtualAlloc, HeapAlloc
    MemoryProtection    = 2,    ///< VirtualProtect
    ProcessCreation     = 3,    ///< CreateProcess
    ThreadCreation      = 4,    ///< CreateThread, CreateRemoteThread
    DllLoading          = 5,    ///< LoadLibrary
    CodeExecution       = 6,    ///< ShellExecute, WinExec
    FileOperations      = 7,    ///< CreateFile (dangerous operations)
    RegistryAccess      = 8,    ///< Registry operations
    NetworkOperations   = 9     ///< Socket, Connect
};

/**
 * @brief Detection confidence
 */
enum class DetectionConfidence : uint8_t {
    Unknown     = 0,
    Low         = 1,
    Medium      = 2,
    High        = 3,
    VeryHigh    = 4,
    Confirmed   = 5
};

/**
 * @brief Module status
 */
enum class ModuleStatus : uint8_t {
    Uninitialized   = 0,
    Initializing    = 1,
    Running         = 2,
    Paused          = 3,
    Stopping        = 4,
    Stopped         = 5,
    Error           = 6
};

// ============================================================================
// STRUCTURES
// ============================================================================

/**
 * @brief Gadget information
 */
struct GadgetInfo {
    /// @brief Gadget address
    uint64_t address = 0;
    
    /// @brief Gadget type
    GadgetType type = GadgetType::Unknown;
    
    /// @brief Module containing gadget
    std::wstring moduleName;
    
    /// @brief Offset within module
    uint64_t moduleOffset = 0;
    
    /// @brief Gadget bytes
    std::vector<uint8_t> bytes;
    
    /// @brief Disassembly
    std::vector<std::string> disassembly;
    
    /// @brief Stack adjustment (for RET N)
    uint16_t stackAdjustment = 0;
    
    /// @brief Gadget length
    size_t length = 0;
    
    /// @brief Is ASLR-dependent
    bool isAslrDependent = true;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief ROP chain information
 */
struct RopChainInfo {
    /// @brief Chain ID
    std::string chainId;
    
    /// @brief Gadgets in chain
    std::vector<GadgetInfo> gadgets;
    
    /// @brief Chain start address (on stack)
    uint64_t chainStartAddress = 0;
    
    /// @brief Chain length (gadgets)
    size_t chainLength = 0;
    
    /// @brief Total bytes
    size_t totalBytes = 0;
    
    /// @brief Attack type
    CodeReuseType attackType = CodeReuseType::Unknown;
    
    /// @brief Identified payload type
    std::string payloadType;
    
    /// @brief Target function (if identified)
    std::string targetFunction;
    
    /// @brief Arguments (if identifiable)
    std::vector<uint64_t> arguments;
    
    /// @brief Is complete chain
    bool isCompleteChain = false;
    
    /// @brief Uses known gadget sequence
    bool usesKnownSequence = false;
    
    /// @brief Signature match (if any)
    std::string signatureMatch;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Shadow stack entry
 */
struct ShadowStackEntry {
    /// @brief Return address
    uint64_t returnAddress = 0;
    
    /// @brief Call site address
    uint64_t callSite = 0;
    
    /// @brief Stack pointer at call
    uint64_t stackPointer = 0;
    
    /// @brief Frame pointer
    uint64_t framePointer = 0;
    
    /// @brief Target function address
    uint64_t targetFunction = 0;
    
    /// @brief Entry timestamp
    TimePoint timestamp;
};

/**
 * @brief Protected API info
 */
struct ProtectedApiInfo {
    /// @brief API name
    std::string apiName;
    
    /// @brief Module name
    std::wstring moduleName;
    
    /// @brief Function address
    uint64_t address = 0;
    
    /// @brief Category
    ProtectedApiCategory category = ProtectedApiCategory::Unknown;
    
    /// @brief Is hooked by us
    bool isHooked = false;
    
    /// @brief Hook address
    uint64_t hookAddress = 0;
    
    /// @brief Call count
    std::atomic<uint64_t> callCount{0};
    
    /// @brief Block count
    std::atomic<uint64_t> blockCount{0};
};

/**
 * @brief ROP detection event
 */
struct RopEvent {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Thread ID
    uint32_t threadId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief Detection method
    RopDetectionMethod method = RopDetectionMethod::Unknown;
    
    /// @brief Instruction pointer
    uint64_t instructionPointer = 0;
    
    /// @brief Stack pointer
    uint64_t stackPointer = 0;
    
    /// @brief Expected return address (shadow stack)
    uint64_t expectedReturn = 0;
    
    /// @brief Actual return address
    uint64_t actualReturn = 0;
    
    /// @brief API function (if at API boundary)
    std::string apiFunction;
    
    /// @brief ROP chain (if detected)
    std::optional<RopChainInfo> ropChain;
    
    /// @brief Confidence
    DetectionConfidence confidence = DetectionConfidence::Unknown;
    
    /// @brief Confidence score (0-100)
    double confidenceScore = 0.0;
    
    /// @brief Was blocked
    bool wasBlocked = false;
    
    /// @brief Process was terminated
    bool processTerminated = false;
    
    /// @brief Additional details
    std::string details;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Statistics
 */
struct ROPStatistics {
    std::atomic<uint64_t> apiCallsValidated{0};
    std::atomic<uint64_t> shadowStackPushes{0};
    std::atomic<uint64_t> shadowStackPops{0};
    std::atomic<uint64_t> shadowStackMismatches{0};
    std::atomic<uint64_t> ropChainsDetected{0};
    std::atomic<uint64_t> jopChainsDetected{0};
    std::atomic<uint64_t> gadgetsIdentified{0};
    std::atomic<uint64_t> attacksBlocked{0};
    std::atomic<uint64_t> processesTerminated{0};
    std::array<std::atomic<uint64_t>, 8> byMethod{};
    TimePoint startTime = Clock::now();
    
    void Reset() noexcept;
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Configuration
 */
struct ROPProtectionConfiguration {
    /// @brief Enable shadow stack
    bool enableShadowStack = true;
    
    /// @brief Enable API return validation
    bool enableApiReturnValidation = true;
    
    /// @brief Enable gadget scanning
    bool enableGadgetScan = true;
    
    /// @brief Use hardware CET if available
    bool useHardwareCET = true;
    
    /// @brief Block on detection
    bool blockOnDetection = true;
    
    /// @brief Terminate process on confirmed ROP
    bool terminateOnConfirmed = true;
    
    /// @brief Protected APIs (defaults if empty)
    std::vector<std::string> protectedApis;
    
    /// @brief Maximum shadow stack depth
    size_t maxShadowStackDepth = ROPConstants::MAX_SHADOW_STACK_ENTRIES;
    
    /// @brief Excluded processes
    std::vector<std::wstring> excludedProcesses;
    
    /// @brief Verbose logging
    bool verboseLogging = false;
    
    [[nodiscard]] bool IsValid() const noexcept;
};

// ============================================================================
// CALLBACK TYPES
// ============================================================================

using RopDetectedCallback = std::function<void(const RopEvent&)>;
using GadgetChainCallback = std::function<void(const RopChainInfo&)>;
using ApiCallCallback = std::function<void(uint32_t pid, const std::string& api, bool blocked)>;
using ErrorCallback = std::function<void(const std::string& message, int code)>;

// ============================================================================
// ROP PROTECTION CLASS
// ============================================================================

/**
 * @class ROPProtection
 * @brief Enterprise-grade ROP attack protection
 */
class ROPProtection final {
public:
    [[nodiscard]] static ROPProtection& Instance() noexcept;
    [[nodiscard]] static bool HasInstance() noexcept;
    
    ROPProtection(const ROPProtection&) = delete;
    ROPProtection& operator=(const ROPProtection&) = delete;
    ROPProtection(ROPProtection&&) = delete;
    ROPProtection& operator=(ROPProtection&&) = delete;

    // ========================================================================
    // LIFECYCLE
    // ========================================================================
    
    [[nodiscard]] bool Initialize(const ROPProtectionConfiguration& config = {});
    void Shutdown();
    [[nodiscard]] bool IsInitialized() const noexcept;
    [[nodiscard]] ModuleStatus GetStatus() const noexcept;
    
    [[nodiscard]] bool Start();
    [[nodiscard]] bool Stop();
    void Pause();
    void Resume();
    
    [[nodiscard]] bool UpdateConfiguration(const ROPProtectionConfiguration& config);
    [[nodiscard]] ROPProtectionConfiguration GetConfiguration() const;

    // ========================================================================
    // API PROTECTION
    // ========================================================================
    
    /// @brief Validate API call return address
    [[nodiscard]] bool ValidateApiCall(uint64_t returnAddress);
    
    /// @brief Validate API call with context
    [[nodiscard]] bool ValidateApiCall(
        uint64_t returnAddress,
        const std::string& apiName,
        uint32_t processId,
        uint32_t threadId);
    
    /// @brief Add API to protected list
    void ProtectApi(const std::string& apiName, ProtectedApiCategory category);
    
    /// @brief Remove API from protected list
    void UnprotectApi(const std::string& apiName);
    
    /// @brief Get protected APIs
    [[nodiscard]] std::vector<ProtectedApiInfo> GetProtectedApis() const;

    // ========================================================================
    // SHADOW STACK
    // ========================================================================
    
    /// @brief Push return address to shadow stack
    void ShadowStackPush(
        uint32_t threadId, 
        uint64_t returnAddress,
        uint64_t callSite = 0);
    
    /// @brief Pop and validate return address
    [[nodiscard]] bool ShadowStackPop(
        uint32_t threadId, 
        uint64_t expectedReturn);
    
    /// @brief Clear shadow stack for thread
    void ShadowStackClear(uint32_t threadId);
    
    /// @brief Get shadow stack depth for thread
    [[nodiscard]] size_t GetShadowStackDepth(uint32_t threadId) const;

    // ========================================================================
    // GADGET ANALYSIS
    // ========================================================================
    
    /// @brief Scan stack for ROP chain
    [[nodiscard]] bool ScanStackForRop(
        uint32_t processId,
        uint64_t stackPointer,
        size_t scanSize = 4096);
    
    /// @brief Analyze potential ROP chain
    [[nodiscard]] std::optional<RopChainInfo> AnalyzeRopChain(
        uint32_t processId,
        uint64_t chainStart,
        size_t maxGadgets = ROPConstants::MAX_GADGET_CHAIN_LENGTH);
    
    /// @brief Identify gadget at address
    [[nodiscard]] std::optional<GadgetInfo> IdentifyGadget(
        uint32_t processId,
        uint64_t address);
    
    /// @brief Disassemble gadget
    [[nodiscard]] std::vector<std::string> DisassembleGadget(
        std::span<const uint8_t> bytes,
        uint64_t baseAddress = 0);

    // ========================================================================
    // PROCESS PROTECTION
    // ========================================================================
    
    /// @brief Protect process
    [[nodiscard]] bool ProtectProcess(uint32_t processId);
    
    /// @brief Unprotect process
    void UnprotectProcess(uint32_t processId);
    
    /// @brief Check if process is protected
    [[nodiscard]] bool IsProcessProtected(uint32_t processId) const;
    
    /// @brief Get protected processes
    [[nodiscard]] std::vector<uint32_t> GetProtectedProcesses() const;

    // ========================================================================
    // HARDWARE FEATURES
    // ========================================================================
    
    /// @brief Check if hardware CET is available
    [[nodiscard]] bool IsHardwareCETAvailable() const noexcept;
    
    /// @brief Check if hardware CET is enabled for process
    [[nodiscard]] bool IsHardwareCETEnabled(uint32_t processId) const;
    
    /// @brief Enable hardware CET for process
    [[nodiscard]] bool EnableHardwareCET(uint32_t processId);

    // ========================================================================
    // CALLBACKS
    // ========================================================================
    
    void RegisterRopCallback(RopDetectedCallback callback);
    void RegisterGadgetChainCallback(GadgetChainCallback callback);
    void RegisterApiCallCallback(ApiCallCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // ========================================================================
    // STATISTICS
    // ========================================================================
    
    [[nodiscard]] ROPStatistics GetStatistics() const;
    void ResetStatistics();
    [[nodiscard]] std::vector<RopEvent> GetRecentDetections(size_t maxCount = 100) const;
    
    [[nodiscard]] bool SelfTest();
    [[nodiscard]] static std::string GetVersionString() noexcept;

private:
    ROPProtection();
    ~ROPProtection();
    
    std::unique_ptr<ROPProtectionImpl> m_impl;
    static std::atomic<bool> s_instanceCreated;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

[[nodiscard]] std::string_view GetRopDetectionMethodName(RopDetectionMethod method) noexcept;
[[nodiscard]] std::string_view GetGadgetTypeName(GadgetType type) noexcept;
[[nodiscard]] std::string_view GetCodeReuseTypeName(CodeReuseType type) noexcept;
[[nodiscard]] std::string_view GetProtectedApiCategoryName(ProtectedApiCategory cat) noexcept;
[[nodiscard]] bool IsReturnInstruction(uint8_t opcode) noexcept;
[[nodiscard]] bool IsJumpInstruction(std::span<const uint8_t> bytes) noexcept;
[[nodiscard]] bool IsCallInstruction(std::span<const uint8_t> bytes) noexcept;

}  // namespace Exploits
}  // namespace ShadowStrike

// ============================================================================
// MACROS
// ============================================================================

#define SS_VALIDATE_API_CALL(retAddr) \
    ::ShadowStrike::Exploits::ROPProtection::Instance().ValidateApiCall(retAddr)

#define SS_SCAN_STACK_ROP(pid, rsp) \
    ::ShadowStrike::Exploits::ROPProtection::Instance().ScanStackForRop(pid, rsp)

#define SS_PROTECT_PROCESS(pid) \
    ::ShadowStrike::Exploits::ROPProtection::Instance().ProtectProcess(pid)