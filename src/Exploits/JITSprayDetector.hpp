/**
 * ============================================================================
 * ShadowStrike NGAV - JIT SPRAY DETECTOR
 * ============================================================================
 *
 * @file JITSprayDetector.hpp
 * @brief Enterprise-grade detection of JIT (Just-In-Time) spray attacks
 *        that embed shellcode within JIT-compiled code constants.
 *
 * Monitors JIT compilation engines and detects attempts to embed shellcode
 * within JIT-compiled constants that can be executed via control flow hijack.
 *
 * DETECTION CAPABILITIES:
 * =======================
 *
 * 1. JIT ENGINE MONITORING
 *    - V8 (Chrome/Node.js/Electron)
 *    - SpiderMonkey (Firefox)
 *    - Chakra (Legacy Edge)
 *    - JavaScriptCore (Safari/WebKit)
 *    - .NET CLR JIT
 *    - Java HotSpot JIT
 *    - LuaJIT
 *
 * 2. CONSTANT EMBEDDING DETECTION
 *    - XOR constant encoding
 *    - Floating-point constant abuse
 *    - Integer constant embedding
 *    - String constant shellcode
 *
 * 3. W^X POLICY ENFORCEMENT
 *    - Write XOR Execute monitoring
 *    - RWX page detection
 *    - Memory protection transitions
 *    - JIT page permission tracking
 *
 * 4. JIT SPRAY PATTERN DETECTION
 *    - Repeated constant patterns
 *    - Gadget chain detection
 *    - x86/x64 instruction analysis
 *    - Landing zone identification
 *
 * 5. BROWSER-SPECIFIC DETECTION
 *    - JavaScript JIT spray
 *    - WebAssembly exploitation
 *    - ActionScript JIT (Flash - legacy)
 *    - PDF JavaScript JIT
 *
 * 6. MITIGATION TECHNIQUES
 *    - JIT code isolation
 *    - Constant blinding enforcement
 *    - Random padding insertion
 *    - Address randomization
 *
 * INTEGRATION:
 * ============
 * - Utils::MemoryUtils for memory analysis
 * - HeapSprayDetector for correlation
 * - SignatureStore for shellcode patterns
 *
 * @note Requires memory inspection of JIT engine internals.
 * @note Some detection requires browser-specific knowledge.
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#pragma once

// ============================================================================
// STANDARD LIBRARY INCLUDES
// ============================================================================

#include <cstdint>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>
#include <array>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <optional>
#include <memory>
#include <functional>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <span>

// ============================================================================
// WINDOWS SDK INCLUDES
// ============================================================================

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// ============================================================================
// SHADOWSTRIKE INFRASTRUCTURE INCLUDES
// ============================================================================

#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/MemoryUtils.hpp"
#include "../SignatureStore/SignatureStore.hpp"

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

namespace ShadowStrike::Exploits {
    class JITSprayDetectorImpl;
}

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// COMPILE-TIME CONSTANTS
// ============================================================================

namespace JITSprayConstants {

    inline constexpr uint32_t VERSION_MAJOR = 3;
    inline constexpr uint32_t VERSION_MINOR = 0;
    inline constexpr uint32_t VERSION_PATCH = 0;

    /// @brief Minimum JIT page size to scan
    inline constexpr size_t MIN_JIT_PAGE_SIZE = 4096;
    
    /// @brief Maximum bytes to scan per JIT region
    inline constexpr size_t MAX_SCAN_SIZE = 1024 * 1024;
    
    /// @brief Minimum repeated constant length for detection
    inline constexpr size_t MIN_CONSTANT_REPEAT = 8;
    
    /// @brief Maximum JIT pages to track per process
    inline constexpr size_t MAX_JIT_PAGES = 4096;
    
    /// @brief Common XOR spray values
    inline constexpr uint32_t XOR_SPRAY_VALUES[] = {
        0x3C909090,     // XOR AX,0x9090; NOP
        0x3C0D0D0D,     // XOR constant
        0x3C0C0C0C,     // XOR constant
        0x35909090,     // XOR EAX,0x90909090
    };
    
    /// @brief W^X violation threshold (pages)
    inline constexpr size_t WX_VIOLATION_THRESHOLD = 10;

}  // namespace JITSprayConstants

// ============================================================================
// TYPE ALIASES
// ============================================================================

using Clock = std::chrono::steady_clock;
using TimePoint = std::chrono::steady_clock::time_point;
using SystemTimePoint = std::chrono::system_clock::time_point;

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief JIT engine type
 */
enum class JitEngine : uint8_t {
    Unknown             = 0,
    V8                  = 1,    ///< Chrome/Node.js/Electron
    SpiderMonkey        = 2,    ///< Firefox
    Chakra              = 3,    ///< Legacy Edge (ChakraCore)
    JavaScriptCore      = 4,    ///< Safari/WebKit
    DotNetJIT           = 5,    ///< .NET CLR JIT (RyuJIT)
    DotNetNGen          = 6,    ///< .NET Native image
    JavaHotSpot         = 7,    ///< Java HotSpot
    OpenJ9              = 8,    ///< Eclipse OpenJ9
    LuaJIT              = 9,    ///< LuaJIT
    WASM                = 10,   ///< WebAssembly engine
    ActionScript        = 11,   ///< Flash (legacy)
    PyPy                = 12    ///< Python PyPy JIT
};

/**
 * @brief JIT page type
 */
enum class JitPageType : uint8_t {
    Unknown         = 0,
    CodePage        = 1,    ///< JIT compiled code
    StubPage        = 2,    ///< JIT stubs
    ConstantPool    = 3,    ///< Constant pool
    DataPage        = 4,    ///< JIT data
    TrampolinePage  = 5     ///< Trampoline code
};

/**
 * @brief Spray technique
 */
enum class JitSprayTechnique : uint8_t {
    Unknown             = 0,
    XorConstant         = 1,    ///< XOR instruction constants
    FloatConstant       = 2,    ///< Floating-point constant abuse
    IntegerConstant     = 3,    ///< Integer constant embedding
    StringConstant      = 4,    ///< String constant shellcode
    ArrayConstant       = 5,    ///< Array initialization
    ImmediateValue      = 6,    ///< Immediate instruction values
    AddressLeak         = 7     ///< Address leak via constants
};

/**
 * @brief W^X violation type
 */
enum class WXViolationType : uint8_t {
    None                = 0,
    SimultaneousRWX     = 1,    ///< Page is RWX
    WriteToExecutable   = 2,    ///< Write to X page
    ExecuteWritable     = 3,    ///< Execute W page
    TransitionViolation = 4     ///< Illegal protection transition
};

/**
 * @brief Detection confidence
 */
enum class DetectionConfidence : uint8_t {
    Unknown     = 0,
    Low         = 1,
    Medium      = 2,
    High        = 3,
    VeryHigh    = 4,
    Confirmed   = 5
};

/**
 * @brief Module status
 */
enum class ModuleStatus : uint8_t {
    Uninitialized   = 0,
    Initializing    = 1,
    Running         = 2,
    Paused          = 3,
    Stopping        = 4,
    Stopped         = 5,
    Error           = 6
};

// ============================================================================
// STRUCTURES
// ============================================================================

/**
 * @brief JIT page information
 */
struct JitPageInfo {
    /// @brief Page base address
    uint64_t baseAddress = 0;
    
    /// @brief Page size
    size_t size = 0;
    
    /// @brief JIT engine
    JitEngine engine = JitEngine::Unknown;
    
    /// @brief Page type
    JitPageType pageType = JitPageType::Unknown;
    
    /// @brief Memory protection
    uint32_t protection = 0;
    
    /// @brief Is executable
    bool isExecutable = false;
    
    /// @brief Is writable
    bool isWritable = false;
    
    /// @brief W^X violation
    WXViolationType wxViolation = WXViolationType::None;
    
    /// @brief Allocation base
    uint64_t allocationBase = 0;
    
    /// @brief Module name (if known)
    std::wstring moduleName;
    
    /// @brief Entropy
    double entropy = 0.0;
    
    /// @brief Contains suspicious constants
    bool suspiciousConstants = false;
    
    /// @brief Constant repeat count
    uint32_t constantRepeatCount = 0;
    
    /// @brief First seen time
    SystemTimePoint firstSeen;
    
    /// @brief Last scanned time
    SystemTimePoint lastScanned;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Constant embedding information
 */
struct ConstantEmbedding {
    /// @brief Offset within page
    size_t offset = 0;
    
    /// @brief Constant value
    std::vector<uint8_t> constantValue;
    
    /// @brief Repeat count
    uint32_t repeatCount = 0;
    
    /// @brief Total length
    size_t totalLength = 0;
    
    /// @brief Decoded as x86/x64 instructions
    std::vector<std::string> decodedInstructions;
    
    /// @brief Is valid shellcode
    bool isValidShellcode = false;
    
    /// @brief Spray technique
    JitSprayTechnique technique = JitSprayTechnique::Unknown;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief JIT spray event
 */
struct JitSprayEvent {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief JIT engine detected
    JitEngine engine = JitEngine::Unknown;
    
    /// @brief Spray technique
    JitSprayTechnique technique = JitSprayTechnique::Unknown;
    
    /// @brief Suspicious JIT page
    JitPageInfo suspiciousPage;
    
    /// @brief Address where spray detected
    uint64_t address = 0;
    
    /// @brief Constant embedding info
    std::optional<ConstantEmbedding> constantInfo;
    
    /// @brief Suspected bytecode (JavaScript/etc.)
    std::vector<uint8_t> suspiciousBytecode;
    
    /// @brief Source script (if available)
    std::string sourceScript;
    
    /// @brief Shellcode detected
    bool shellcodeDetected = false;
    
    /// @brief W^X violation
    WXViolationType wxViolation = WXViolationType::None;
    
    /// @brief Confidence
    DetectionConfidence confidence = DetectionConfidence::Unknown;
    
    /// @brief Confidence score (0-100)
    double confidenceScore = 0.0;
    
    /// @brief Was blocked
    bool wasBlocked = false;
    
    /// @brief Additional details
    std::string details;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief W^X compliance report
 */
struct WXComplianceReport {
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Total JIT pages
    uint32_t totalJitPages = 0;
    
    /// @brief W^X compliant pages
    uint32_t compliantPages = 0;
    
    /// @brief Violation count
    uint32_t violationCount = 0;
    
    /// @brief Violations by type
    std::map<WXViolationType, uint32_t> violationsByType;
    
    /// @brief Non-compliant pages
    std::vector<JitPageInfo> nonCompliantPages;
    
    /// @brief Is fully compliant
    bool isFullyCompliant = false;
    
    /// @brief Compliance score (0-100)
    double complianceScore = 0.0;
    
    /// @brief Report timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Statistics
 */
struct JITSprayStatistics {
    std::atomic<uint64_t> pagesScanned{0};
    std::atomic<uint64_t> constantsAnalyzed{0};
    std::atomic<uint64_t> spraysDetected{0};
    std::atomic<uint64_t> wxViolationsDetected{0};
    std::atomic<uint64_t> shellcodesDetected{0};
    std::atomic<uint64_t> attacksBlocked{0};
    std::array<std::atomic<uint64_t>, 16> byEngine{};
    std::array<std::atomic<uint64_t>, 8> byTechnique{};
    TimePoint startTime = Clock::now();
    
    void Reset() noexcept;
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Configuration
 */
struct JITSprayDetectorConfiguration {
    /// @brief Enable detection
    bool enabled = true;
    
    /// @brief Enforce W^X policy
    bool enforceWX = true;
    
    /// @brief Scan JIT pages for spray
    bool scanJitPages = true;
    
    /// @brief Maximum bytes to scan per region
    size_t maxScanBytes = JITSprayConstants::MAX_SCAN_SIZE;
    
    /// @brief Enable constant analysis
    bool enableConstantAnalysis = true;
    
    /// @brief Block on W^X violation
    bool blockOnWXViolation = true;
    
    /// @brief Block on spray detection
    bool blockOnSprayDetection = true;
    
    /// @brief Monitor specific engines
    std::vector<JitEngine> monitoredEngines;
    
    /// @brief Scan interval (ms)
    uint32_t scanIntervalMs = 1000;
    
    /// @brief Verbose logging
    bool verboseLogging = false;
    
    [[nodiscard]] bool IsValid() const noexcept;
};

// ============================================================================
// CALLBACK TYPES
// ============================================================================

using JitSprayCallback = std::function<void(const JitSprayEvent&)>;
using WXViolationCallback = std::function<void(uint32_t pid, const JitPageInfo&)>;
using ErrorCallback = std::function<void(const std::string& message, int code)>;

// ============================================================================
// JIT SPRAY DETECTOR CLASS
// ============================================================================

/**
 * @class JITSprayDetector
 * @brief Enterprise-grade JIT spray detection engine
 */
class JITSprayDetector final {
public:
    [[nodiscard]] static JITSprayDetector& Instance() noexcept;
    [[nodiscard]] static bool HasInstance() noexcept;
    
    JITSprayDetector(const JITSprayDetector&) = delete;
    JITSprayDetector& operator=(const JITSprayDetector&) = delete;
    JITSprayDetector(JITSprayDetector&&) = delete;
    JITSprayDetector& operator=(JITSprayDetector&&) = delete;

    // ========================================================================
    // LIFECYCLE
    // ========================================================================
    
    [[nodiscard]] bool Initialize(const JITSprayDetectorConfiguration& config = {});
    void Shutdown();
    [[nodiscard]] bool IsInitialized() const noexcept;
    [[nodiscard]] ModuleStatus GetStatus() const noexcept;
    
    [[nodiscard]] bool Start();
    [[nodiscard]] bool Stop();
    void Pause();
    void Resume();
    
    [[nodiscard]] bool UpdateConfiguration(const JITSprayDetectorConfiguration& config);
    [[nodiscard]] JITSprayDetectorConfiguration GetConfiguration() const;

    // ========================================================================
    // SCANNING
    // ========================================================================
    
    /// @brief Scan JIT pages for spray patterns
    [[nodiscard]] std::optional<JitSprayEvent> ScanJitPages(uint32_t processId);
    
    /// @brief Scan all processes for JIT spray
    [[nodiscard]] std::vector<JitSprayEvent> ScanAllProcesses();
    
    /// @brief Analyze specific JIT page
    [[nodiscard]] JitPageInfo AnalyzeJitPage(
        uint32_t processId,
        uint64_t address,
        size_t size);
    
    /// @brief Detect constant embedding
    [[nodiscard]] std::optional<ConstantEmbedding> DetectConstantEmbedding(
        std::span<const uint8_t> data,
        uint64_t baseAddress = 0);

    // ========================================================================
    // W^X COMPLIANCE
    // ========================================================================
    
    /// @brief Check W^X compliance for process
    [[nodiscard]] WXComplianceReport CheckWXCompliance(uint32_t processId);
    
    /// @brief Check if page violates W^X
    [[nodiscard]] WXViolationType CheckPageWXViolation(
        uint32_t processId,
        uint64_t address);
    
    /// @brief Get W^X non-compliant pages
    [[nodiscard]] std::vector<JitPageInfo> GetWXViolatingPages(uint32_t processId);

    // ========================================================================
    // JIT ENGINE DETECTION
    // ========================================================================
    
    /// @brief Detect JIT engine in process
    [[nodiscard]] JitEngine DetectJitEngine(uint32_t processId);
    
    /// @brief Get all JIT engines in process
    [[nodiscard]] std::vector<JitEngine> GetAllJitEngines(uint32_t processId);
    
    /// @brief Get JIT pages for process
    [[nodiscard]] std::vector<JitPageInfo> GetJitPages(uint32_t processId);

    // ========================================================================
    // MONITORING
    // ========================================================================
    
    /// @brief Start monitoring process
    [[nodiscard]] bool MonitorProcess(uint32_t processId);
    
    /// @brief Stop monitoring process
    [[nodiscard]] bool StopMonitoring(uint32_t processId);
    
    /// @brief Check if process is monitored
    [[nodiscard]] bool IsMonitoring(uint32_t processId) const;

    // ========================================================================
    // CALLBACKS
    // ========================================================================
    
    void RegisterJitSprayCallback(JitSprayCallback callback);
    void RegisterWXViolationCallback(WXViolationCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // ========================================================================
    // STATISTICS
    // ========================================================================
    
    [[nodiscard]] JITSprayStatistics GetStatistics() const;
    void ResetStatistics();
    [[nodiscard]] std::vector<JitSprayEvent> GetRecentDetections(size_t maxCount = 100) const;
    
    [[nodiscard]] bool SelfTest();
    [[nodiscard]] static std::string GetVersionString() noexcept;

private:
    JITSprayDetector();
    ~JITSprayDetector();
    
    std::unique_ptr<JITSprayDetectorImpl> m_impl;
    static std::atomic<bool> s_instanceCreated;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

[[nodiscard]] std::string_view GetJitEngineName(JitEngine engine) noexcept;
[[nodiscard]] std::string_view GetJitPageTypeName(JitPageType type) noexcept;
[[nodiscard]] std::string_view GetJitSprayTechniqueName(JitSprayTechnique tech) noexcept;
[[nodiscard]] std::string_view GetWXViolationTypeName(WXViolationType type) noexcept;
[[nodiscard]] bool IsJitEngineModule(std::wstring_view moduleName) noexcept;
[[nodiscard]] JitEngine DetectJitEngineFromModule(std::wstring_view moduleName);

}  // namespace Exploits
}  // namespace ShadowStrike

// ============================================================================
// MACROS
// ============================================================================

#define SS_SCAN_JIT_SPRAY(pid) \
    ::ShadowStrike::Exploits::JITSprayDetector::Instance().ScanJitPages(pid)

#define SS_CHECK_WX_COMPLIANCE(pid) \
    ::ShadowStrike::Exploits::JITSprayDetector::Instance().CheckWXCompliance(pid)