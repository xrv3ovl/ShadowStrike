/**
 * ============================================================================
 * ShadowStrike NGAV - HEAP SPRAY DETECTOR
 * ============================================================================
 *
 * @file HeapSprayDetector.hpp
 * @brief Enterprise-grade detection of heap spraying attacks used in
 *        browser exploits and memory corruption attacks.
 *
 * Detects heap spray techniques by monitoring memory allocation patterns,
 * analyzing heap entropy, and identifying shellcode landing zones.
 *
 * DETECTION CAPABILITIES:
 * =======================
 *
 * 1. CLASSIC HEAP SPRAY DETECTION
 *    - NOP sled detection (0x90, 0x0C0C, etc.)
 *    - Large uniform allocations
 *    - Repeated allocation patterns
 *    - Predictable address targeting
 *
 * 2. JIT SPRAY CORRELATION
 *    - JavaScript ArrayBuffer spray
 *    - JIT code page patterns
 *    - Constant embedding detection
 *    - Cross-reference with JITSprayDetector
 *
 * 3. BROWSER-SPECIFIC TECHNIQUES
 *    - BSTR/VARIANT spray (COM)
 *    - DOM element spray
 *    - HTML5 ArrayBuffer abuse
 *    - TypedArray spray
 *    - String spray (JavaScript)
 *
 * 4. SHELLCODE DETECTION
 *    - Entropy analysis
 *    - x86/x64 instruction scanning
 *    - API hash detection
 *    - Encoded shellcode patterns
 *
 * 5. ADVANCED SPRAY TECHNIQUES
 *    - Feng shui heap manipulation
 *    - Plunger spray
 *    - Look-aside list targeting
 *    - Segment heap exploitation
 *
 * 6. MEMORY PRESSURE ANALYSIS
 *    - Allocation rate monitoring
 *    - Working set analysis
 *    - Commit charge tracking
 *    - Anomaly detection
 *
 * INTEGRATION:
 * ============
 * - Utils::MemoryUtils for memory operations
 * - PatternStore for spray signatures
 * - JITSprayDetector for correlation
 *
 * @note Requires memory read access to target processes.
 * @note High-frequency scanning may impact performance.
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#pragma once

// ============================================================================
// STANDARD LIBRARY INCLUDES
// ============================================================================

#include <cstdint>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>
#include <array>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <optional>
#include <memory>
#include <functional>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <span>

// ============================================================================
// WINDOWS SDK INCLUDES
// ============================================================================

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// ============================================================================
// SHADOWSTRIKE INFRASTRUCTURE INCLUDES
// ============================================================================

#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/MemoryUtils.hpp"
#include "../PatternStore/PatternStore.hpp"
#include "../SignatureStore/SignatureStore.hpp"

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

namespace ShadowStrike::Exploits {
    class HeapSprayDetectorImpl;
}

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// COMPILE-TIME CONSTANTS
// ============================================================================

namespace HeapSprayConstants {

    inline constexpr uint32_t VERSION_MAJOR = 3;
    inline constexpr uint32_t VERSION_MINOR = 0;
    inline constexpr uint32_t VERSION_PATCH = 0;

    /// @brief Minimum block size considered for spray (1MB default)
    inline constexpr size_t MIN_SPRAY_BLOCK_SIZE = 1024 * 1024;
    
    /// @brief Maximum block size for single spray element
    inline constexpr size_t MAX_SPRAY_BLOCK_SIZE = 64 * 1024 * 1024;
    
    /// @brief Low entropy threshold (NOP sleds)
    inline constexpr double ENTROPY_THRESHOLD_LOW = 1.0;
    
    /// @brief Very low entropy threshold (uniform data)
    inline constexpr double ENTROPY_THRESHOLD_VERY_LOW = 0.5;
    
    /// @brief High entropy threshold (encrypted shellcode)
    inline constexpr double ENTROPY_THRESHOLD_HIGH = 7.5;
    
    /// @brief Common NOP sled values
    inline constexpr uint8_t NOP_SLED_VALUES[] = {
        0x90,       // NOP
        0x41,       // INC ECX
        0x42,       // INC EDX  
        0x43,       // INC EBX
        0x44,       // INC ESP
        0x45,       // INC EBP
        0x46,       // INC ESI
        0x47,       // INC EDI
        0x40,       // INC EAX
    };
    
    /// @brief Common spray target addresses (x86)
    inline constexpr uint32_t SPRAY_TARGET_ADDRS_32[] = {
        0x0C0C0C0C,
        0x0D0D0D0D,
        0x0A0A0A0A,
        0x0B0B0B0B,
        0x06060606,
        0x07070707,
        0x04040404,
        0x05050505,
    };
    
    /// @brief Maximum allocations to track per process
    inline constexpr size_t MAX_TRACKED_ALLOCATIONS = 8192;
    
    /// @brief Scan sample size
    inline constexpr size_t ENTROPY_SAMPLE_SIZE = 4096;

}  // namespace HeapSprayConstants

// ============================================================================
// TYPE ALIASES
// ============================================================================

using Clock = std::chrono::steady_clock;
using TimePoint = std::chrono::steady_clock::time_point;
using SystemTimePoint = std::chrono::system_clock::time_point;

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief Spray technique type
 */
enum class SprayTechnique : uint8_t {
    Unknown         = 0,
    ClassicNopSled  = 1,    ///< Traditional NOP sled spray
    JitSpray        = 2,    ///< JIT compiler abuse
    ArrayBuffer     = 3,    ///< HTML5 ArrayBuffer
    TypedArray      = 4,    ///< JavaScript TypedArray
    BSTR            = 5,    ///< COM BSTR string
    Variant         = 6,    ///< COM VARIANT
    DomElement      = 7,    ///< DOM element spray
    StringSpray     = 8,    ///< JavaScript string spray
    FengShui        = 9,    ///< Heap feng shui
    Plunger         = 10,   ///< Plunger spray technique
    LookAsideList   = 11,   ///< LAL targeting
    SegmentHeap     = 12,   ///< Segment heap abuse
    LFHBucket       = 13    ///< LFH bucket spray
};

/**
 * @brief Memory region type
 */
enum class MemoryRegionType : uint8_t {
    Unknown         = 0,
    Heap            = 1,
    Stack           = 2,
    Image           = 3,
    Mapped          = 4,
    Private         = 5,
    JitCode         = 6,
    SharedMemory    = 7
};

/**
 * @brief Allocation flags
 */
enum class AllocationFlags : uint16_t {
    None            = 0,
    Executable      = 1 << 0,
    Writable        = 1 << 1,
    Readable        = 1 << 2,
    LargePages      = 1 << 3,
    Guard           = 1 << 4,
    NoCache         = 1 << 5,
    Shared          = 1 << 6,
    LowEntropy      = 1 << 7,
    HighEntropy     = 1 << 8,
    Suspicious      = 1 << 9,
    ConfirmedSpray  = 1 << 10
};

/**
 * @brief Detection confidence level
 */
enum class ConfidenceLevel : uint8_t {
    Unknown     = 0,
    Low         = 1,
    Medium      = 2,
    High        = 3,
    VeryHigh    = 4,
    Confirmed   = 5
};

/**
 * @brief Module status
 */
enum class ModuleStatus : uint8_t {
    Uninitialized   = 0,
    Initializing    = 1,
    Running         = 2,
    Paused          = 3,
    Stopping        = 4,
    Stopped         = 5,
    Error           = 6
};

// ============================================================================
// STRUCTURES
// ============================================================================

/**
 * @brief Heap allocation information
 */
struct HeapAllocationInfo {
    /// @brief Allocation address
    uint64_t address = 0;
    
    /// @brief Allocation size
    size_t size = 0;
    
    /// @brief Heap handle
    uint64_t heapHandle = 0;
    
    /// @brief Memory region type
    MemoryRegionType regionType = MemoryRegionType::Unknown;
    
    /// @brief Protection flags
    uint32_t protection = 0;
    
    /// @brief Allocation flags
    AllocationFlags flags = AllocationFlags::None;
    
    /// @brief Is executable
    bool isExecutable = false;
    
    /// @brief Is writable
    bool isWritable = true;
    
    /// @brief Shannon entropy
    double entropy = 0.0;
    
    /// @brief Dominant byte value
    uint8_t dominantByte = 0;
    
    /// @brief Dominant byte percentage
    double dominantBytePercent = 0.0;
    
    /// @brief Contains potential shellcode
    bool containsShellcode = false;
    
    /// @brief Contains NOP sled
    bool containsNopSled = false;
    
    /// @brief Allocation timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Spray pattern information
 */
struct SprayPatternInfo {
    /// @brief Pattern ID
    std::string patternId;
    
    /// @brief Spray technique
    SprayTechnique technique = SprayTechnique::Unknown;
    
    /// @brief Pattern bytes
    std::vector<uint8_t> patternBytes;
    
    /// @brief Pattern offset
    size_t patternOffset = 0;
    
    /// @brief Pattern length
    size_t patternLength = 0;
    
    /// @brief Repeat count
    uint32_t repeatCount = 0;
    
    /// @brief Target address (if targeting specific address)
    uint64_t targetAddress = 0;
    
    /// @brief Shellcode offset within spray
    size_t shellcodeOffset = 0;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Spray event detection result
 */
struct SprayEvent {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief Spray technique detected
    SprayTechnique technique = SprayTechnique::Unknown;
    
    /// @brief Total bytes sprayed
    uint64_t totalSprayedBytes = 0;
    
    /// @brief Number of spray blocks
    uint32_t blockCount = 0;
    
    /// @brief Suspicious allocations
    std::vector<HeapAllocationInfo> suspiciousBlocks;
    
    /// @brief Spray pattern (if identified)
    std::optional<SprayPatternInfo> sprayPattern;
    
    /// @brief Target address (if predictable)
    uint64_t targetAddress = 0;
    
    /// @brief Shellcode detected
    bool shellcodeDetected = false;
    
    /// @brief Shellcode sample
    std::vector<uint8_t> shellcodeSample;
    
    /// @brief Confidence level
    ConfidenceLevel confidence = ConfidenceLevel::Unknown;
    
    /// @brief Confidence score (0-100)
    double confidenceScore = 0.0;
    
    /// @brief Was blocked
    bool wasBlocked = false;
    
    /// @brief Process was terminated
    bool processTerminated = false;
    
    /// @brief Additional details
    std::string details;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Process heap state
 */
struct ProcessHeapState {
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Total heap count
    uint32_t heapCount = 0;
    
    /// @brief Total committed memory
    uint64_t totalCommitted = 0;
    
    /// @brief Total reserved memory
    uint64_t totalReserved = 0;
    
    /// @brief Working set size
    uint64_t workingSetSize = 0;
    
    /// @brief Private bytes
    uint64_t privateBytes = 0;
    
    /// @brief Allocation rate (per second)
    double allocationRate = 0.0;
    
    /// @brief Free rate (per second)
    double freeRate = 0.0;
    
    /// @brief Large allocation count
    uint32_t largeAllocationCount = 0;
    
    /// @brief Low entropy region count
    uint32_t lowEntropyRegionCount = 0;
    
    /// @brief Is under memory pressure
    bool isUnderPressure = false;
    
    /// @brief Is spray suspected
    bool spraySuspected = false;
    
    /// @brief Snapshot timestamp
    SystemTimePoint snapshotTime;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Statistics
 */
struct HeapSprayStatistics {
    std::atomic<uint64_t> scansPerformed{0};
    std::atomic<uint64_t> blocksAnalyzed{0};
    std::atomic<uint64_t> spraysDetected{0};
    std::atomic<uint64_t> nopSledsDetected{0};
    std::atomic<uint64_t> shellcodesDetected{0};
    std::atomic<uint64_t> lowEntropyBlocks{0};
    std::atomic<uint64_t> highEntropyBlocks{0};
    std::atomic<uint64_t> attacksBlocked{0};
    std::array<std::atomic<uint64_t>, 16> byTechnique{};
    TimePoint startTime = Clock::now();
    
    void Reset() noexcept;
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Configuration
 */
struct HeapSprayDetectorConfiguration {
    /// @brief Enable detection
    bool enabled = true;
    
    /// @brief Minimum allocation size to analyze
    size_t minAllocationThreshold = HeapSprayConstants::MIN_SPRAY_BLOCK_SIZE;
    
    /// @brief Enable entropy analysis
    bool enableEntropyAnalysis = true;
    
    /// @brief Low entropy threshold
    double lowEntropyThreshold = HeapSprayConstants::ENTROPY_THRESHOLD_LOW;
    
    /// @brief Enable script engine monitoring
    bool monitorScriptEngines = true;
    
    /// @brief Enable shellcode detection
    bool enableShellcodeDetection = true;
    
    /// @brief Block detected sprays
    bool blockOnDetection = true;
    
    /// @brief Terminate process on high-confidence spray
    bool terminateOnHighConfidence = false;
    
    /// @brief Scan interval (ms)
    uint32_t scanIntervalMs = 500;
    
    /// @brief Memory pressure threshold (bytes)
    uint64_t memoryPressureThreshold = 512 * 1024 * 1024; // 512MB
    
    /// @brief Verbose logging
    bool verboseLogging = false;
    
    [[nodiscard]] bool IsValid() const noexcept;
};

// ============================================================================
// CALLBACK TYPES
// ============================================================================

using SprayDetectedCallback = std::function<void(const SprayEvent&)>;
using HeapStateCallback = std::function<void(const ProcessHeapState&)>;
using ErrorCallback = std::function<void(const std::string& message, int code)>;

// ============================================================================
// HEAP SPRAY DETECTOR CLASS
// ============================================================================

/**
 * @class HeapSprayDetector
 * @brief Enterprise-grade heap spray detection engine
 */
class HeapSprayDetector final {
public:
    [[nodiscard]] static HeapSprayDetector& Instance() noexcept;
    [[nodiscard]] static bool HasInstance() noexcept;
    
    HeapSprayDetector(const HeapSprayDetector&) = delete;
    HeapSprayDetector& operator=(const HeapSprayDetector&) = delete;
    HeapSprayDetector(HeapSprayDetector&&) = delete;
    HeapSprayDetector& operator=(HeapSprayDetector&&) = delete;

    // ========================================================================
    // LIFECYCLE
    // ========================================================================
    
    [[nodiscard]] bool Initialize(const HeapSprayDetectorConfiguration& config = {});
    void Shutdown();
    [[nodiscard]] bool IsInitialized() const noexcept;
    [[nodiscard]] ModuleStatus GetStatus() const noexcept;

    [[nodiscard]] bool Start();
    [[nodiscard]] bool Stop();
    void Pause();
    void Resume();
    
    [[nodiscard]] bool UpdateConfiguration(const HeapSprayDetectorConfiguration& config);
    [[nodiscard]] HeapSprayDetectorConfiguration GetConfiguration() const;

    // ========================================================================
    // SCANNING
    // ========================================================================
    
    /// @brief Scan process heap for spray patterns
    [[nodiscard]] std::optional<SprayEvent> ScanProcessHeap(uint32_t processId);
    
    /// @brief Scan all heaps in process
    [[nodiscard]] std::vector<SprayEvent> ScanAllHeaps(uint32_t processId);
    
    /// @brief Analyze specific memory region
    [[nodiscard]] HeapAllocationInfo AnalyzeMemoryRegion(
        uint32_t processId,
        uint64_t address,
        size_t size);
    
    /// @brief Analyze memory block data
    [[nodiscard]] HeapAllocationInfo AnalyzeMemoryBlock(
        std::span<const uint8_t> data,
        uint64_t baseAddress = 0);

    // ========================================================================
    // ANALYSIS
    // ========================================================================
    
    /// @brief Calculate Shannon entropy
    [[nodiscard]] double CalculateEntropy(std::span<const uint8_t> data);
    
    /// @brief Detect NOP sled in data
    [[nodiscard]] bool DetectNopSled(
        std::span<const uint8_t> data,
        size_t minLength = 64);
    
    /// @brief Detect shellcode in data
    [[nodiscard]] bool DetectShellcode(std::span<const uint8_t> data);
    
    /// @brief Identify spray technique
    [[nodiscard]] SprayTechnique IdentifySprayTechnique(
        std::span<const uint8_t> data,
        double entropy);
    
    /// @brief Get process heap state
    [[nodiscard]] ProcessHeapState GetProcessHeapState(uint32_t processId);
    
    /// @brief Check for spray indicators
    [[nodiscard]] bool HasSprayIndicators(uint32_t processId);

    // ========================================================================
    // MONITORING
    // ========================================================================
    
    /// @brief Start monitoring process
    [[nodiscard]] bool MonitorProcess(uint32_t processId);
    
    /// @brief Stop monitoring process
    [[nodiscard]] bool StopMonitoring(uint32_t processId);
    
    /// @brief Check if process is monitored
    [[nodiscard]] bool IsMonitoring(uint32_t processId) const;
    
    /// @brief Get monitored processes
    [[nodiscard]] std::vector<uint32_t> GetMonitoredProcesses() const;

    // ========================================================================
    // CALLBACKS
    // ========================================================================
    
    void RegisterSprayCallback(SprayDetectedCallback callback);
    void RegisterHeapStateCallback(HeapStateCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // ========================================================================
    // STATISTICS
    // ========================================================================
    
    [[nodiscard]] HeapSprayStatistics GetStatistics() const;
    void ResetStatistics();
    [[nodiscard]] std::vector<SprayEvent> GetRecentDetections(size_t maxCount = 100) const;
    
    [[nodiscard]] bool SelfTest();
    [[nodiscard]] static std::string GetVersionString() noexcept;

private:
    HeapSprayDetector();
    ~HeapSprayDetector();
    
    std::unique_ptr<HeapSprayDetectorImpl> m_impl;
    static std::atomic<bool> s_instanceCreated;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

[[nodiscard]] std::string_view GetSprayTechniqueName(SprayTechnique technique) noexcept;
[[nodiscard]] std::string_view GetMemoryRegionTypeName(MemoryRegionType type) noexcept;
[[nodiscard]] std::string_view GetConfidenceLevelName(ConfidenceLevel level) noexcept;
[[nodiscard]] bool IsCommonNopByte(uint8_t byte) noexcept;
[[nodiscard]] bool IsCommonSprayAddress(uint32_t address) noexcept;

}  // namespace Exploits
}  // namespace ShadowStrike

// ============================================================================
// MACROS
// ============================================================================

#define SS_SCAN_HEAP_SPRAY(pid) \
    ::ShadowStrike::Exploits::HeapSprayDetector::Instance().ScanProcessHeap(pid)

#define SS_CALC_ENTROPY(data) \
    ::ShadowStrike::Exploits::HeapSprayDetector::Instance().CalculateEntropy(data)