/**
 * ============================================================================
 * ShadowStrike NGAV - BUFFER OVERFLOW PROTECTION
 * ============================================================================
 *
 * @file BufferOverflowProtection.hpp
 * @brief Enterprise-grade protection against memory corruption exploits
 *        including stack smashing, heap overflow, and format string attacks.
 *
 * Provides comprehensive memory safety enforcement using hardware-assisted
 * mechanisms (Intel CET, AMD Shadow Stack) and software-based detection.
 *
 * PROTECTION MECHANISMS:
 * ======================
 *
 * 1. STACK PROTECTION
 *    - Stack canary/cookie verification
 *    - Shadow stack implementation
 *    - Return address verification
 *    - Stack limit enforcement
 *    - SafeSEH validation
 *    - SEHOP enforcement
 *
 * 2. HEAP PROTECTION
 *    - Heap metadata validation
 *    - Heap termination on corruption
 *    - Low Fragmentation Heap security
 *    - Segment heap validation
 *    - Double-free detection
 *    - Use-after-free detection
 *
 * 3. DATA EXECUTION PREVENTION
 *    - DEP enforcement
 *    - Permanent DEP for process
 *    - ATL thunk emulation control
 *    - Exception chain validation
 *
 * 4. ADDRESS SPACE LAYOUT RANDOMIZATION
 *    - ASLR enforcement
 *    - High-entropy ASLR
 *    - Bottom-up ASLR
 *    - Force relocate images
 *    - Disallow stripped images
 *
 * 5. CONTROL FLOW INTEGRITY
 *    - CFG enforcement
 *    - CET support (Intel)
 *    - Strict CFG mode
 *    - Export suppression
 *
 * 6. FORMAT STRING PROTECTION
 *    - printf family monitoring
 *    - Format specifier validation
 *    - %n blocking
 *
 * 7. INTEGER OVERFLOW DETECTION
 *    - Safe integer operations
 *    - Size calculation validation
 *    - Array bounds checking
 *
 * INTEGRATION:
 * ============
 * - Utils::ProcessUtils for process operations
 * - Utils::MemoryUtils for memory analysis
 * - ThreatIntel for exploit signature matching
 *
 * @note Requires administrative privileges for some operations.
 * @note Hardware CET requires supported CPU and Windows 10 20H1+.
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#pragma once

// ============================================================================
// STANDARD LIBRARY INCLUDES
// ============================================================================

#include <cstdint>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>
#include <array>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <optional>
#include <variant>
#include <memory>
#include <functional>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <span>
#include <filesystem>
#include <bitset>

// ============================================================================
// WINDOWS SDK INCLUDES
// ============================================================================

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// ============================================================================
// SHADOWSTRIKE INFRASTRUCTURE INCLUDES
// ============================================================================

#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/MemoryUtils.hpp"
#include "../ThreatIntel/ThreatIntelManager.hpp"
#include "../SignatureStore/SignatureStore.hpp"

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

namespace ShadowStrike::Exploits {
    class BufferOverflowProtectionImpl;
}

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// COMPILE-TIME CONSTANTS
// ============================================================================

namespace BufferOverflowConstants {

    inline constexpr uint32_t VERSION_MAJOR = 3;
    inline constexpr uint32_t VERSION_MINOR = 0;
    inline constexpr uint32_t VERSION_PATCH = 0;

    /// @brief Maximum processes to monitor simultaneously
    inline constexpr size_t MAX_MONITORED_PROCESSES = 2048;
    
    /// @brief Maximum stack frames to analyze
    inline constexpr size_t MAX_STACK_FRAMES = 256;
    
    /// @brief Default stack canary (GS cookie) check interval (ms)
    inline constexpr uint32_t CANARY_CHECK_INTERVAL_MS = 100;
    
    /// @brief Maximum exception records to cache
    inline constexpr size_t MAX_EXCEPTION_CACHE = 4096;
    
    /// @brief Stack cookie magic values
    inline constexpr uint64_t STACK_COOKIE_MAGIC_64 = 0x2B992DDFA232;
    inline constexpr uint32_t STACK_COOKIE_MAGIC_32 = 0x0BB40E64;
    
    /// @brief Heap corruption detection magic
    inline constexpr uint64_t HEAP_HEADER_MAGIC = 0xFEEDFACECAFEBEEF;

}  // namespace BufferOverflowConstants

// ============================================================================
// TYPE ALIASES
// ============================================================================

using Clock = std::chrono::steady_clock;
using TimePoint = std::chrono::steady_clock::time_point;
using SystemTimePoint = std::chrono::system_clock::time_point;
using Hash256 = std::array<uint8_t, 32>;

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief Type of memory corruption/overflow attack
 */
enum class OverflowType : uint8_t {
    Unknown                     = 0,
    StackSmashing               = 1,    ///< Return address overwrite
    StackCanaryCorruption       = 2,    ///< Stack cookie overwritten
    SEHOverwrite                = 3,    ///< SEH chain corruption
    HeapOverflow                = 4,    ///< Heap buffer overflow
    HeapMetadataCorruption      = 5,    ///< Heap header corruption
    FormatString                = 6,    ///< %n exploitation
    IntegerOverflow             = 7,    ///< Integer wrap leading to small buffer
    IntegerUnderflow            = 8,    ///< Negative size issues
    UseAfterFree                = 9,    ///< Dangling pointer
    DoubleFree                  = 10,   ///< Double free() call
    HeapUseAfterRealloc         = 11,   ///< Use after realloc()
    NullPointerDeref            = 12,   ///< Null pointer dereference
    TypeConfusion               = 13,   ///< Object type confusion
    OutOfBoundsRead             = 14,   ///< OOB read (information disclosure)
    OutOfBoundsWrite            = 15,   ///< OOB write
    UninitializedMemory         = 16,   ///< Use of uninitialized memory
    Off_By_One                  = 17    ///< Off-by-one errors
};

/**
 * @brief Protection technique type
 */
enum class ProtectionTechnique : uint32_t {
    StackCanary                 = 1 << 0,   ///< GS stack cookies
    SafeSEH                     = 1 << 1,   ///< Safe exception handler
    SEHOP                       = 1 << 2,   ///< SEH Overwrite Protection
    DEP                         = 1 << 3,   ///< Data Execution Prevention
    PermanentDEP                = 1 << 4,   ///< Cannot be disabled
    ASLR                        = 1 << 5,   ///< Address Space Layout Randomization
    HighEntropyASLR             = 1 << 6,   ///< 64-bit high entropy
    BottomUpASLR                = 1 << 7,   ///< Bottom-up randomization
    ForceRelocate               = 1 << 8,   ///< Force image relocation
    HeapTerminate               = 1 << 9,   ///< Terminate on heap corruption
    CFG                         = 1 << 10,  ///< Control Flow Guard
    StrictCFG                   = 1 << 11,  ///< Strict CFG mode
    ShadowStack                 = 1 << 12,  ///< Software shadow stack
    HardwareCET                 = 1 << 13,  ///< Intel CET support
    ReturnAddressVerify         = 1 << 14,  ///< Return address validation
    ImportAddressFilter         = 1 << 15,  ///< IAT access filtering
    ExportAddressFilter         = 1 << 16,  ///< Export address filtering
    StrictHandleCheck           = 1 << 17,  ///< Invalid handle raises exception
    DisableDynamicCode          = 1 << 18,  ///< Block VirtualProtect RWX
    DisallowWin32kSyscalls      = 1 << 19,  ///< Block win32k.sys syscalls
    DisableExtensionPoints      = 1 << 20,  ///< Block legacy extension points
    BlockRemoteImages           = 1 << 21,  ///< Block remote DLL loading
    BlockLowLabelImages         = 1 << 22,  ///< Block low-integrity DLLs
    PreferSystem32Images        = 1 << 23,  ///< Prefer System32 DLLs
    ProhibitDynamicCode         = 1 << 24,  ///< Prohibit dynamic code gen
    AllowThreadOptOut           = 1 << 25,  ///< Allow thread opt-out
    AuditOnlyMode               = 1 << 26   ///< Audit without blocking
};

/**
 * @brief Exploit detection status
 */
enum class ExploitStatus : uint8_t {
    Unknown         = 0,
    Safe            = 1,
    Suspicious      = 2,
    LikelyExploit   = 3,
    ConfirmedExploit= 4,
    Blocked         = 5,
    Terminated      = 6
};

/**
 * @brief Severity level
 */
enum class ExploitSeverity : uint8_t {
    Information     = 0,
    Low             = 1,
    Medium          = 2,
    High            = 3,
    Critical        = 4
};

/**
 * @brief Detection method
 */
enum class DetectionMethod : uint8_t {
    Unknown             = 0,
    ExceptionHandler    = 1,    ///< Exception caught
    CanaryCheck         = 2,    ///< Stack canary corrupted
    ShadowStackMismatch = 3,    ///< Shadow stack mismatch
    HeapValidation      = 4,    ///< Heap integrity check
    HookDetection       = 5,    ///< API hook detection
    PatternMatch        = 6,    ///< Exploit signature match
    Heuristic           = 7,    ///< Behavioral heuristic
    HardwareTrap        = 8,    ///< Hardware exception
    ApiMonitoring       = 9     ///< API call monitoring
};

/**
 * @brief CPU vendor for CET support
 */
enum class CpuVendor : uint8_t {
    Unknown     = 0,
    Intel       = 1,
    AMD         = 2
};

/**
 * @brief Module status
 */
enum class ModuleStatus : uint8_t {
    Uninitialized   = 0,
    Initializing    = 1,
    Running         = 2,
    Paused          = 3,
    Stopping        = 4,
    Stopped         = 5,
    Error           = 6
};

// ============================================================================
// STRUCTURES
// ============================================================================

/**
 * @brief Process mitigation policy configuration
 */
struct ProcessMitigationPolicy {
    /// @brief DEP settings
    bool depEnabled = true;
    bool depPermanent = true;
    bool depAtlThunkEmulation = false;
    
    /// @brief ASLR settings
    bool aslrEnabled = true;
    bool aslrHighEntropy = true;
    bool aslrBottomUp = true;
    bool aslrForceRelocate = true;
    bool aslrDisallowStripped = true;
    
    /// @brief Stack settings
    bool stackTerminateOnCorruption = true;
    
    /// @brief Heap settings
    bool heapTerminateOnCorruption = true;
    
    /// @brief SEH settings
    bool sehopEnabled = true;
    
    /// @brief CFG settings
    bool cfgEnabled = true;
    bool cfgStrictMode = true;
    bool cfgExportSuppression = true;
    
    /// @brief Handle settings
    bool strictHandleCheck = true;
    bool handleExceptionOnInvalid = true;
    
    /// @brief Dynamic code settings
    bool disableDynamicCode = false;
    bool allowThreadOptOut = true;
    bool auditDynamicCode = true;
    
    /// @brief DLL settings
    bool blockRemoteImages = true;
    bool blockLowLabelImages = true;
    bool preferSystem32 = true;
    
    /// @brief Extension point settings
    bool disableExtensionPoints = true;
    
    /// @brief Win32k settings
    bool disallowWin32kCalls = false;
    
    /// @brief CET settings (Intel)
    bool enableCET = true;
    bool cetStrictMode = false;
    
    /**
     * @brief Validate configuration
     */
    [[nodiscard]] bool IsValid() const noexcept;
    
    /**
     * @brief Get as bitmask
     */
    [[nodiscard]] uint64_t ToBitmask() const noexcept;
    
    /**
     * @brief Create from bitmask
     */
    static ProcessMitigationPolicy FromBitmask(uint64_t mask);
    
    /**
     * @brief Get default secure policy
     */
    static ProcessMitigationPolicy GetSecureDefault() noexcept;
    
    /**
     * @brief Get maximum security policy
     */
    static ProcessMitigationPolicy GetMaximumSecurity() noexcept;
};

/**
 * @brief Stack frame information
 */
struct StackFrameInfo {
    /// @brief Frame index
    uint32_t frameIndex = 0;
    
    /// @brief Return address
    uint64_t returnAddress = 0;
    
    /// @brief Stack pointer at frame
    uint64_t stackPointer = 0;
    
    /// @brief Base pointer at frame
    uint64_t basePointer = 0;
    
    /// @brief Module containing return address
    std::wstring moduleName;
    
    /// @brief Module base address
    uint64_t moduleBase = 0;
    
    /// @brief Offset within module
    uint64_t moduleOffset = 0;
    
    /// @brief Function name (if symbols available)
    std::string functionName;
    
    /// @brief Function offset
    uint32_t functionOffset = 0;
    
    /// @brief Source file (if debug info)
    std::string sourceFile;
    
    /// @brief Source line
    uint32_t sourceLine = 0;
    
    /// @brief Is frame valid
    bool isValid = false;
    
    /// @brief Is return address in executable region
    bool returnInExecutable = true;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Exception context information
 */
struct ExceptionContext {
    /// @brief Exception code
    uint32_t exceptionCode = 0;
    
    /// @brief Exception flags
    uint32_t exceptionFlags = 0;
    
    /// @brief Exception address
    uint64_t exceptionAddress = 0;
    
    /// @brief Number of parameters
    uint32_t numParameters = 0;
    
    /// @brief Exception parameters
    std::array<uint64_t, 15> parameters{};
    
    /// @brief Is continuable
    bool isContinuable = false;
    
    /// @brief Is first chance
    bool isFirstChance = true;
    
    /// @brief Register state (x64)
    struct RegisterState {
        uint64_t rax = 0, rbx = 0, rcx = 0, rdx = 0;
        uint64_t rsi = 0, rdi = 0, rbp = 0, rsp = 0;
        uint64_t r8 = 0, r9 = 0, r10 = 0, r11 = 0;
        uint64_t r12 = 0, r13 = 0, r14 = 0, r15 = 0;
        uint64_t rip = 0, rflags = 0;
        uint16_t cs = 0, ss = 0, ds = 0, es = 0, fs = 0, gs = 0;
    } registers;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Memory corruption event
 */
struct ExploitEvent {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Overflow type
    OverflowType type = OverflowType::Unknown;
    
    /// @brief Detection method
    DetectionMethod detectionMethod = DetectionMethod::Unknown;
    
    /// @brief Status
    ExploitStatus status = ExploitStatus::Unknown;
    
    /// @brief Severity
    ExploitSeverity severity = ExploitSeverity::Medium;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Thread ID
    uint32_t threadId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief Instruction pointer (RIP/EIP)
    uint64_t instructionPointer = 0;
    
    /// @brief Stack pointer (RSP/ESP)
    uint64_t stackPointer = 0;
    
    /// @brief Target address being corrupted
    uint64_t targetAddress = 0;
    
    /// @brief Expected value (for canary checks)
    uint64_t expectedValue = 0;
    
    /// @brief Actual value found
    uint64_t actualValue = 0;
    
    /// @brief Module where event occurred
    std::wstring moduleName;
    
    /// @brief Module base address
    uint64_t moduleBase = 0;
    
    /// @brief Function name
    std::string functionName;
    
    /// @brief Exception context
    std::optional<ExceptionContext> exceptionContext;
    
    /// @brief Call stack
    std::vector<StackFrameInfo> callStack;
    
    /// @brief Corrupted bytes (sample)
    std::vector<uint8_t> corruptedData;
    
    /// @brief Matching signature ID
    std::string signatureId;
    
    /// @brief Additional details
    std::string details;
    
    /// @brief Was prevented
    bool prevented = false;
    
    /// @brief Process was terminated
    bool processTerminated = false;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Heap state analysis result
 */
struct HeapAnalysisResult {
    /// @brief Heap handle
    uint64_t heapHandle = 0;
    
    /// @brief Total size
    uint64_t totalSize = 0;
    
    /// @brief Committed size
    uint64_t committedSize = 0;
    
    /// @brief Free size
    uint64_t freeSize = 0;
    
    /// @brief Number of allocations
    uint64_t allocationCount = 0;
    
    /// @brief Is heap corrupted
    bool isCorrupted = false;
    
    /// @brief Corruption type
    std::string corruptionType;
    
    /// @brief Corruption address
    uint64_t corruptionAddress = 0;
    
    /// @brief Is low fragmentation heap
    bool isLFH = false;
    
    /// @brief Is segment heap
    bool isSegmentHeap = false;
    
    /// @brief Heap flags
    uint32_t heapFlags = 0;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Process hardening report
 */
struct HardeningReport {
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Current policy
    ProcessMitigationPolicy currentPolicy;
    
    /// @brief Applied policy
    ProcessMitigationPolicy appliedPolicy;
    
    /// @brief Policies successfully applied
    std::vector<ProtectionTechnique> successfulPolicies;
    
    /// @brief Policies that failed to apply
    std::map<ProtectionTechnique, std::string> failedPolicies;
    
    /// @brief Overall hardening score (0-100)
    double hardeningScore = 0.0;
    
    /// @brief Recommendations
    std::vector<std::string> recommendations;
    
    /// @brief Timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Statistics
 */
struct BufferOverflowStatistics {
    std::atomic<uint64_t> processesMonitored{0};
    std::atomic<uint64_t> processesHardened{0};
    std::atomic<uint64_t> exceptionsHandled{0};
    std::atomic<uint64_t> stackOverflowsDetected{0};
    std::atomic<uint64_t> heapCorruptionsDetected{0};
    std::atomic<uint64_t> formatStringsDetected{0};
    std::atomic<uint64_t> integerOverflowsDetected{0};
    std::atomic<uint64_t> useAfterFreeDetected{0};
    std::atomic<uint64_t> exploitsBlocked{0};
    std::atomic<uint64_t> processesTerminated{0};
    std::atomic<uint64_t> canaryChecks{0};
    std::atomic<uint64_t> canaryFailures{0};
    TimePoint startTime = Clock::now();
    
    void Reset() noexcept;
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Configuration
 */
struct BufferOverflowProtectionConfiguration {
    /// @brief Enable protection
    bool enabled = true;
    
    /// @brief Default policy for new processes
    ProcessMitigationPolicy defaultPolicy;
    
    /// @brief Enable exception monitoring
    bool enableExceptionMonitoring = true;
    
    /// @brief Enable heap validation
    bool enableHeapValidation = true;
    
    /// @brief Enable stack canary checks
    bool enableCanaryChecks = true;
    
    /// @brief Stack canary check interval (ms)
    uint32_t canaryCheckIntervalMs = BufferOverflowConstants::CANARY_CHECK_INTERVAL_MS;
    
    /// @brief Terminate on confirmed exploit
    bool terminateOnExploit = true;
    
    /// @brief Auto-harden new processes
    bool autoHardenProcesses = true;
    
    /// @brief Enable shadow stack
    bool enableShadowStack = false;
    
    /// @brief Excluded processes (by name)
    std::vector<std::wstring> excludedProcesses;
    
    /// @brief Verbose logging
    bool verboseLogging = false;
    
    /// @brief Enable format string protection
    bool enableFormatStringProtection = true;
    
    /// @brief Enable integer overflow detection
    bool enableIntegerOverflowDetection = true;
    
    [[nodiscard]] bool IsValid() const noexcept;
};

// ============================================================================
// CALLBACK TYPES
// ============================================================================

using ExploitDetectedCallback = std::function<void(const ExploitEvent&)>;
using HardeningCallback = std::function<void(const HardeningReport&)>;
using ExceptionCallback = std::function<void(uint32_t processId, const ExceptionContext&)>;
using ErrorCallback = std::function<void(const std::string& message, int code)>;

// ============================================================================
// BUFFER OVERFLOW PROTECTION CLASS
// ============================================================================

/**
 * @class BufferOverflowProtection
 * @brief Enterprise-grade memory corruption protection
 */
class BufferOverflowProtection final {
public:
    [[nodiscard]] static BufferOverflowProtection& Instance() noexcept;
    [[nodiscard]] static bool HasInstance() noexcept;
    
    BufferOverflowProtection(const BufferOverflowProtection&) = delete;
    BufferOverflowProtection& operator=(const BufferOverflowProtection&) = delete;
    BufferOverflowProtection(BufferOverflowProtection&&) = delete;
    BufferOverflowProtection& operator=(BufferOverflowProtection&&) = delete;

    // ========================================================================
    // LIFECYCLE
    // ========================================================================
    
    [[nodiscard]] bool Initialize(const BufferOverflowProtectionConfiguration& config = {});
    void Shutdown();
    [[nodiscard]] bool IsInitialized() const noexcept;
    [[nodiscard]] ModuleStatus GetStatus() const noexcept;
    
    [[nodiscard]] bool Start();
    [[nodiscard]] bool Stop();
    void Pause();
    void Resume();
    
    [[nodiscard]] bool UpdateConfiguration(const BufferOverflowProtectionConfiguration& config);
    [[nodiscard]] BufferOverflowProtectionConfiguration GetConfiguration() const;

    // ========================================================================
    // PROCESS HARDENING
    // ========================================================================
    
    /// @brief Apply mitigation policy to process
    [[nodiscard]] HardeningReport HardenProcess(uint32_t processId);
    
    /// @brief Apply mitigation policy to process
    [[nodiscard]] HardeningReport HardenProcess(
        uint32_t processId, 
        const ProcessMitigationPolicy& policy);
    
    /// @brief Get current process mitigation policy
    [[nodiscard]] ProcessMitigationPolicy GetProcessPolicy(uint32_t processId) const;
    
    /// @brief Check if process has specific protection
    [[nodiscard]] bool HasProtection(
        uint32_t processId, 
        ProtectionTechnique technique) const;
    
    /// @brief Get process hardening score (0-100)
    [[nodiscard]] double GetHardeningScore(uint32_t processId) const;
    
    /// @brief Get hardening recommendations for process
    [[nodiscard]] std::vector<std::string> GetRecommendations(uint32_t processId) const;

    // ========================================================================
    // MONITORING
    // ========================================================================
    
    /// @brief Start monitoring process for exploits
    [[nodiscard]] bool MonitorProcess(uint32_t processId);
    
    /// @brief Stop monitoring process
    [[nodiscard]] bool StopMonitoring(uint32_t processId);
    
    /// @brief Check if process is being monitored
    [[nodiscard]] bool IsMonitoring(uint32_t processId) const;
    
    /// @brief Get list of monitored processes
    [[nodiscard]] std::vector<uint32_t> GetMonitoredProcesses() const;

    // ========================================================================
    // ANALYSIS
    // ========================================================================
    
    /// @brief Analyze exception for exploit indicators
    [[nodiscard]] ExploitEvent AnalyzeException(
        uint32_t processId,
        const ExceptionContext& context);
    
    /// @brief Analyze crash dump for exploit indicators
    [[nodiscard]] ExploitEvent AnalyzeCrashDump(const std::filesystem::path& dumpPath);
    
    /// @brief Analyze memory region for corruption
    [[nodiscard]] std::optional<ExploitEvent> AnalyzeMemoryRegion(
        uint32_t processId,
        uint64_t address,
        size_t size);
    
    /// @brief Validate heap integrity
    [[nodiscard]] HeapAnalysisResult ValidateHeap(uint32_t processId, uint64_t heapHandle);
    
    /// @brief Validate all heaps in process
    [[nodiscard]] std::vector<HeapAnalysisResult> ValidateAllHeaps(uint32_t processId);
    
    /// @brief Check stack canary integrity
    [[nodiscard]] bool ValidateStackCanary(uint32_t processId, uint32_t threadId);
    
    /// @brief Get call stack for thread
    [[nodiscard]] std::vector<StackFrameInfo> GetCallStack(
        uint32_t processId, 
        uint32_t threadId,
        size_t maxFrames = BufferOverflowConstants::MAX_STACK_FRAMES);

    // ========================================================================
    // HARDWARE FEATURES
    // ========================================================================
    
    /// @brief Check if hardware CET is available
    [[nodiscard]] bool IsCETAvailable() const noexcept;
    
    /// @brief Check if hardware shadow stack is available
    [[nodiscard]] bool IsHardwareShadowStackAvailable() const noexcept;
    
    /// @brief Get CPU vendor
    [[nodiscard]] CpuVendor GetCpuVendor() const noexcept;
    
    /// @brief Get supported hardware features
    [[nodiscard]] uint64_t GetHardwareFeatures() const noexcept;

    // ========================================================================
    // CALLBACKS
    // ========================================================================
    
    void RegisterExploitCallback(ExploitDetectedCallback callback);
    void RegisterHardeningCallback(HardeningCallback callback);
    void RegisterExceptionCallback(ExceptionCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // ========================================================================
    // STATISTICS & DIAGNOSTICS
    // ========================================================================
    
    [[nodiscard]] BufferOverflowStatistics GetStatistics() const;
    void ResetStatistics();
    [[nodiscard]] std::vector<ExploitEvent> GetRecentEvents(size_t maxCount = 100) const;
    
    [[nodiscard]] bool SelfTest();
    [[nodiscard]] static std::string GetVersionString() noexcept;

private:
    BufferOverflowProtection();
    ~BufferOverflowProtection();
    
    std::unique_ptr<BufferOverflowProtectionImpl> m_impl;
    static std::atomic<bool> s_instanceCreated;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

[[nodiscard]] std::string_view GetOverflowTypeName(OverflowType type) noexcept;
[[nodiscard]] std::string_view GetProtectionTechniqueName(ProtectionTechnique tech) noexcept;
[[nodiscard]] std::string_view GetExploitStatusName(ExploitStatus status) noexcept;
[[nodiscard]] std::string_view GetExploitSeverityName(ExploitSeverity severity) noexcept;
[[nodiscard]] std::string_view GetDetectionMethodName(DetectionMethod method) noexcept;
[[nodiscard]] std::string GetExceptionCodeName(uint32_t code);
[[nodiscard]] bool IsExploitException(uint32_t exceptionCode) noexcept;

}  // namespace Exploits
}  // namespace ShadowStrike

// ============================================================================
// MACROS
// ============================================================================

#define SS_HARDEN_PROCESS(pid) \
    ::ShadowStrike::Exploits::BufferOverflowProtection::Instance().HardenProcess(pid)

#define SS_MONITOR_PROCESS(pid) \
    ::ShadowStrike::Exploits::BufferOverflowProtection::Instance().MonitorProcess(pid)

#define SS_VALIDATE_HEAP(pid) \
    ::ShadowStrike::Exploits::BufferOverflowProtection::Instance().ValidateAllHeaps(pid)