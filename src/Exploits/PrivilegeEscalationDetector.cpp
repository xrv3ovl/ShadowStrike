/*
 * ShadowStrike - Enterprise NGAV/EDR Platform
 * Copyright (C) 2026 ShadowStrike Security
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
/**
 * ============================================================================
 * ShadowStrike NGAV - PRIVILEGE ESCALATION DETECTOR IMPLEMENTATION
 * ============================================================================
 *
 * @file PrivilegeEscalationDetector.cpp
 * @brief Enterprise-grade implementation of privilege escalation detection
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#include "pch.h"
#include "PrivilegeEscalationDetector.hpp"
#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/RegistryUtils.hpp"
#include "../Utils/StringUtils.hpp"
#include "../Utils/FileUtils.hpp"
#include "../Utils/SystemUtils.hpp"
#include "../ThreatIntel/ThreatIntelManager.hpp"
#include "../PatternStore/PatternStore.hpp"

#include <Windows.h>
#include <AclAPI.h>
#include <sddl.h>
#include <TlHelp32.h>
#include <Psapi.h>
#include <Wtsapi32.h>
#include <algorithm>
#include <random>
#include <sstream>
#include <iomanip>
#include <filesystem>
#include <nlohmann/json.hpp>

#pragma comment(lib, "Advapi32.lib")
#pragma comment(lib, "Wtsapi32.lib")

namespace fs = std::filesystem;
using json = nlohmann::json;

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// STATIC MEMBER INITIALIZATION
// ============================================================================

std::atomic<bool> PrivilegeEscalationDetector::s_instanceCreated{false};

// ============================================================================
// INTERNAL STRUCTURES
// ============================================================================

namespace {

/// @brief Known dangerous privileges
const std::unordered_set<std::wstring> DANGEROUS_PRIVILEGES = {
    L"SeDebugPrivilege",
    L"SeTcbPrivilege",
    L"SeImpersonatePrivilege",
    L"SeAssignPrimaryTokenPrivilege",
    L"SeLoadDriverPrivilege",
    L"SeRestorePrivilege",
    L"SeTakeOwnershipPrivilege",
    L"SeBackupPrivilege",
    L"SeCreateTokenPrivilege"
};

/// @brief UAC bypass executables
const std::unordered_set<std::wstring> UAC_BYPASS_EXECUTABLES = {
    L"eventvwr.exe",
    L"fodhelper.exe",
    L"computerdefaults.exe",
    L"sdclt.exe",
    L"perfmon.exe",
    L"azman.msc",
    L"slui.exe",
    L"taskmgr.exe"
};

/// @brief Auto-elevate executables
const std::unordered_set<std::wstring> AUTO_ELEVATE_BINARIES = {
    L"wusa.exe",
    L"pkgmgr.exe",
    L"spinstall.exe",
    L"cliconfg.exe"
};

/// @brief System integrity SIDs
const std::unordered_map<std::wstring, IntegrityLevel> INTEGRITY_SIDS = {
    {L"S-1-16-0", IntegrityLevel::Untrusted},
    {L"S-1-16-4096", IntegrityLevel::Low},
    {L"S-1-16-8192", IntegrityLevel::Medium},
    {L"S-1-16-8448", IntegrityLevel::MediumPlus},
    {L"S-1-16-12288", IntegrityLevel::High},
    {L"S-1-16-16384", IntegrityLevel::System},
    {L"S-1-16-20480", IntegrityLevel::Protected}
};

/// @brief Generate unique event ID
std::string GenerateEventId() {
    static std::atomic<uint64_t> counter{0};
    auto now = std::chrono::system_clock::now();
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();

    std::ostringstream oss;
    oss << "LPE-" << std::hex << std::setw(12) << std::setfill('0') << ms
        << "-" << std::setw(8) << std::setfill('0') << counter.fetch_add(1);
    return oss.str();
}

/// @brief Convert SID to string
std::wstring SidToString(PSID sid) {
    if (!sid || !IsValidSid(sid)) {
        return L"";
    }

    LPWSTR sidString = nullptr;
    if (ConvertSidToStringSidW(sid, &sidString)) {
        std::wstring result(sidString);
        LocalFree(sidString);
        return result;
    }

    return L"";
}

/// @brief Get process integrity level
IntegrityLevel GetProcessIntegrityLevel(HANDLE hProcess) {
    HANDLE hToken = nullptr;
    if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
        return IntegrityLevel::Unknown;
    }

    DWORD cbSize = 0;
    GetTokenInformation(hToken, TokenIntegrityLevel, nullptr, 0, &cbSize);

    std::vector<uint8_t> buffer(cbSize);
    auto pIntegrity = reinterpret_cast<PTOKEN_MANDATORY_LABEL>(buffer.data());

    IntegrityLevel level = IntegrityLevel::Unknown;

    if (GetTokenInformation(hToken, TokenIntegrityLevel, pIntegrity, cbSize, &cbSize)) {
        DWORD integrityLevel = *GetSidSubAuthority(pIntegrity->Label.Sid,
            *GetSidSubAuthorityCount(pIntegrity->Label.Sid) - 1);

        if (integrityLevel < SECURITY_MANDATORY_LOW_RID) {
            level = IntegrityLevel::Untrusted;
        } else if (integrityLevel < SECURITY_MANDATORY_MEDIUM_RID) {
            level = IntegrityLevel::Low;
        } else if (integrityLevel < SECURITY_MANDATORY_HIGH_RID) {
            level = IntegrityLevel::Medium;
        } else if (integrityLevel < SECURITY_MANDATORY_SYSTEM_RID) {
            level = IntegrityLevel::High;
        } else if (integrityLevel < SECURITY_MANDATORY_PROTECTED_PROCESS_RID) {
            level = IntegrityLevel::System;
        } else {
            level = IntegrityLevel::Protected;
        }
    }

    CloseHandle(hToken);
    return level;
}

} // anonymous namespace

// ============================================================================
// JSON SERIALIZATION IMPLEMENTATIONS
// ============================================================================

std::string PrivilegeInfo::ToJson() const {
    json j;
    j["name"] = Utils::StringUtils::WStringToString(name);
    j["luid"] = luid;
    j["isEnabled"] = isEnabled;
    j["isEnabledByDefault"] = isEnabledByDefault;
    j["isRemoved"] = isRemoved;
    j["usedForImpersonation"] = usedForImpersonation;
    return j.dump();
}

std::string TokenInfo::ToJson() const {
    json j;
    j["processId"] = processId;
    j["threadId"] = threadId;
    j["tokenHandle"] = tokenHandle;
    j["isPrimaryToken"] = isPrimaryToken;
    j["userSid"] = Utils::StringUtils::WStringToString(userSid);
    j["userName"] = Utils::StringUtils::WStringToString(userName);
    j["logonId"] = logonId;
    j["tokenType"] = tokenType;
    j["impersonationLevel"] = impersonationLevel;
    j["integrityLevel"] = static_cast<int>(integrityLevel);
    j["integritySid"] = Utils::StringUtils::WStringToString(integritySid);
    j["isElevated"] = isElevated;
    j["isRestricted"] = isRestricted;
    j["isSandboxed"] = isSandboxed;
    j["isAppContainer"] = isAppContainer;
    j["sessionId"] = sessionId;
    j["tokenSource"] = tokenSource;
    j["enabledPrivilegeCount"] = enabledPrivilegeCount;
    j["hasSeDebugPrivilege"] = hasSeDebugPrivilege;
    j["hasSeImpersonatePrivilege"] = hasSeImpersonatePrivilege;
    j["hasSeTcbPrivilege"] = hasSeTcbPrivilege;

    json groupsArray = json::array();
    for (const auto& sid : groupSids) {
        groupsArray.push_back(Utils::StringUtils::WStringToString(sid));
    }
    j["groupSids"] = groupsArray;

    json privArray = json::array();
    for (const auto& priv : privileges) {
        privArray.push_back(json::parse(priv.ToJson()));
    }
    j["privileges"] = privArray;

    return j.dump();
}

std::string TokenChangeInfo::ToJson() const {
    json j;
    j["eventId"] = eventId;
    j["processId"] = processId;
    j["processName"] = Utils::StringUtils::WStringToString(processName);
    j["processPath"] = Utils::StringUtils::WStringToString(processPath);
    j["threadId"] = threadId;
    j["changeType"] = static_cast<int>(changeType);
    j["originalUser"] = Utils::StringUtils::WStringToString(originalUser);
    j["newUser"] = Utils::StringUtils::WStringToString(newUser);
    j["originalIntegrity"] = static_cast<int>(originalIntegrity);
    j["newIntegrity"] = static_cast<int>(newIntegrity);
    j["isElevation"] = isElevation;
    j["sourceProcessId"] = sourceProcessId;
    j["sourceProcessName"] = Utils::StringUtils::WStringToString(sourceProcessName);
    j["suspicionScore"] = suspicionScore;

    json addedPrivsArray = json::array();
    for (const auto& priv : addedPrivileges) {
        addedPrivsArray.push_back(Utils::StringUtils::WStringToString(priv));
    }
    j["addedPrivileges"] = addedPrivsArray;

    json enabledPrivsArray = json::array();
    for (const auto& priv : enabledPrivileges) {
        enabledPrivsArray.push_back(Utils::StringUtils::WStringToString(priv));
    }
    j["enabledPrivileges"] = enabledPrivsArray;

    if (tokenBefore.has_value()) {
        j["tokenBefore"] = json::parse(tokenBefore->ToJson());
    }

    if (tokenAfter.has_value()) {
        j["tokenAfter"] = json::parse(tokenAfter->ToJson());
    }

    return j.dump();
}

std::string ServiceSecurityInfo::ToJson() const {
    json j;
    j["serviceName"] = Utils::StringUtils::WStringToString(serviceName);
    j["displayName"] = Utils::StringUtils::WStringToString(displayName);
    j["binaryPath"] = Utils::StringUtils::WStringToString(binaryPath);
    j["startType"] = startType;
    j["serviceType"] = serviceType;
    j["currentState"] = currentState;
    j["runAsAccount"] = Utils::StringUtils::WStringToString(runAsAccount);
    j["hasUnquotedPath"] = hasUnquotedPath;
    j["isPathWritable"] = isPathWritable;
    j["isConfigModifiable"] = isConfigModifiable;
    j["isDLLHijackable"] = isDLLHijackable;
    j["vulnerability"] = static_cast<int>(vulnerability);

    json depsArray = json::array();
    for (const auto& dep : dependencies) {
        depsArray.push_back(Utils::StringUtils::WStringToString(dep));
    }
    j["dependencies"] = depsArray;

    json vulnPathsArray = json::array();
    for (const auto& path : vulnerablePaths) {
        vulnPathsArray.push_back(Utils::StringUtils::WStringToString(path));
    }
    j["vulnerablePaths"] = vulnPathsArray;

    return j.dump();
}

std::string LpeEvent::ToJson() const {
    json j;
    j["eventId"] = eventId;
    j["processId"] = processId;
    j["processName"] = Utils::StringUtils::WStringToString(processName);
    j["processPath"] = Utils::StringUtils::WStringToString(processPath);
    j["commandLine"] = Utils::StringUtils::WStringToString(commandLine);
    j["parentProcessId"] = parentProcessId;
    j["parentProcessName"] = Utils::StringUtils::WStringToString(parentProcessName);
    j["technique"] = static_cast<uint32_t>(technique);
    j["techniqueName"] = techniqueName;
    j["mitreAttackId"] = mitreAttackId;
    j["targetRegistryKey"] = Utils::StringUtils::WStringToString(targetRegistryKey);
    j["targetFilePath"] = Utils::StringUtils::WStringToString(targetFilePath);
    j["confidence"] = static_cast<int>(confidence);
    j["confidenceScore"] = confidenceScore;
    j["wasBlocked"] = wasBlocked;
    j["processTerminated"] = processTerminated;
    j["details"] = details;

    if (tokenChange.has_value()) {
        j["tokenChange"] = json::parse(tokenChange->ToJson());
    }

    if (serviceInfo.has_value()) {
        j["serviceInfo"] = json::parse(serviceInfo->ToJson());
    }

    return j.dump();
}

void PrivEscStatistics::Reset() noexcept {
    processesMonitored = 0;
    tokenChangesDetected = 0;
    uacBypassesDetected = 0;
    serviceAbusesDetected = 0;
    dllHijacksDetected = 0;
    registryAbusesDetected = 0;
    potatoAttacksDetected = 0;
    escalationsBlocked = 0;
    processesTerminated = 0;

    for (auto& counter : byTechnique) {
        counter = 0;
    }

    startTime = Clock::now();
}

std::string PrivEscStatistics::ToJson() const {
    auto uptime = std::chrono::duration_cast<std::chrono::seconds>(
        Clock::now() - startTime).count();

    json j;
    j["uptimeSeconds"] = uptime;
    j["processesMonitored"] = processesMonitored.load();
    j["tokenChangesDetected"] = tokenChangesDetected.load();
    j["uacBypassesDetected"] = uacBypassesDetected.load();
    j["serviceAbusesDetected"] = serviceAbusesDetected.load();
    j["dllHijacksDetected"] = dllHijacksDetected.load();
    j["registryAbusesDetected"] = registryAbusesDetected.load();
    j["potatoAttacksDetected"] = potatoAttacksDetected.load();
    j["escalationsBlocked"] = escalationsBlocked.load();
    j["processesTerminated"] = processesTerminated.load();

    json techniqueArray = json::array();
    for (size_t i = 0; i < byTechnique.size(); ++i) {
        techniqueArray.push_back(byTechnique[i].load());
    }
    j["byTechnique"] = techniqueArray;

    return j.dump();
}

bool PrivilegeEscalationDetectorConfiguration::IsValid() const noexcept {
    if (tokenCheckIntervalMs < 100 || tokenCheckIntervalMs > 60000) {
        return false;
    }

    return true;
}

// ============================================================================
// PIMPL IMPLEMENTATION CLASS
// ============================================================================

class PrivilegeEscalationDetectorImpl final {
public:
    PrivilegeEscalationDetectorImpl();
    ~PrivilegeEscalationDetectorImpl();

    // Lifecycle
    bool Initialize(const PrivilegeEscalationDetectorConfiguration& config);
    void Shutdown();
    bool IsInitialized() const noexcept { return m_status == ModuleStatus::Running; }
    ModuleStatus GetStatus() const noexcept { return m_status; }

    bool Start();
    bool Stop();
    void Pause();
    void Resume();

    bool UpdateConfiguration(const PrivilegeEscalationDetectorConfiguration& config);
    PrivilegeEscalationDetectorConfiguration GetConfiguration() const;

    // Token analysis
    TokenInfo GetProcessToken(uint32_t processId);
    bool AnalyzeTokenIntegrity(uint32_t processId);
    std::optional<TokenChangeInfo> DetectTokenManipulation(uint32_t processId);
    std::vector<TokenChangeInfo> GetTokenHistory(uint32_t processId, size_t maxEntries) const;

    // UAC bypass detection
    void MonitorUacBypassPoints();
    std::vector<LpeEvent> DetectUACBypasses();
    bool CheckUACBypassTechnique(LpeTechnique technique);

    // Service analysis
    std::vector<ServiceSecurityInfo> ScanServices();
    std::vector<ServiceSecurityInfo> GetVulnerableServices();
    ServiceSecurityInfo AnalyzeService(const std::wstring& serviceName);
    std::vector<ServiceSecurityInfo> FindUnquotedPaths();
    std::vector<ServiceSecurityInfo> FindWeakPermissions();

    // DLL hijack analysis
    std::vector<std::wstring> ScanDLLHijackPaths(uint32_t processId);
    bool IsDLLHijackVulnerable(const std::wstring& path);

    // Registry analysis
    bool IsAlwaysInstallElevatedEnabled();
    std::vector<std::pair<std::wstring, std::wstring>> GetIFEODebuggers();

    // Monitoring
    bool MonitorProcess(uint32_t processId);
    bool StopMonitoring(uint32_t processId);
    bool IsMonitoring(uint32_t processId) const;
    std::vector<uint32_t> GetMonitoredProcesses() const;

    // Callbacks
    void RegisterLpeCallback(LpeDetectedCallback callback);
    void RegisterTokenChangeCallback(TokenChangeCallback callback);
    void RegisterServiceVulnerabilityCallback(ServiceVulnerabilityCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // Statistics
    PrivEscStatistics GetStatistics() const;
    void ResetStatistics();
    std::vector<LpeEvent> GetRecentDetections(size_t maxCount) const;

    bool SelfTest();

private:
    // Internal methods
    void MonitoringThreadFunc();
    void ProcessMonitoringLoop();
    TokenInfo ExtractTokenInfo(HANDLE hToken, uint32_t processId);
    std::vector<PrivilegeInfo> GetTokenPrivileges(HANDLE hToken);
    bool HasUnquotedPath(const std::wstring& path) const;
    bool CheckServicePermissions(const std::wstring& serviceName);
    double CalculateSuspicionScore(const TokenChangeInfo& change) const;
    void NotifyLpeDetected(const LpeEvent& event);
    void NotifyTokenChange(const TokenChangeInfo& change);
    void NotifyServiceVulnerability(const ServiceSecurityInfo& info);
    void NotifyError(const std::string& message, int code);
    void RecordDetection(const LpeEvent& event);

    // Member variables
    mutable std::shared_mutex m_mutex;
    std::atomic<ModuleStatus> m_status{ModuleStatus::Uninitialized};
    PrivilegeEscalationDetectorConfiguration m_config;

    // Monitoring state
    std::unordered_map<uint32_t, TokenInfo> m_processTokens;
    std::unordered_set<uint32_t> m_monitoredProcesses;
    std::unordered_map<uint32_t, std::vector<TokenChangeInfo>> m_tokenHistory;

    // Caching
    std::vector<ServiceSecurityInfo> m_cachedVulnerableServices;
    TimePoint m_lastServiceScanTime;
    std::unordered_map<std::wstring, bool> m_dllHijackCache;

    // Detections
    std::deque<LpeEvent> m_recentDetections;
    static constexpr size_t MAX_RECENT_DETECTIONS = 1000;

    // Callbacks
    std::vector<LpeDetectedCallback> m_lpeCallbacks;
    std::vector<TokenChangeCallback> m_tokenChangeCallbacks;
    std::vector<ServiceVulnerabilityCallback> m_serviceVulnCallbacks;
    std::vector<ErrorCallback> m_errorCallbacks;

    // Statistics
    PrivEscStatistics m_stats;

    // Threading
    std::unique_ptr<std::thread> m_monitoringThread;
    std::atomic<bool> m_stopMonitoring{false};
    std::atomic<bool> m_paused{false};
};

// ============================================================================
// PIMPL CONSTRUCTOR/DESTRUCTOR
// ============================================================================

PrivilegeEscalationDetectorImpl::PrivilegeEscalationDetectorImpl()
    : m_lastServiceScanTime(Clock::now()) {
    Utils::Logger::Info("PrivilegeEscalationDetectorImpl constructed");
}

PrivilegeEscalationDetectorImpl::~PrivilegeEscalationDetectorImpl() {
    Shutdown();
    Utils::Logger::Info("PrivilegeEscalationDetectorImpl destroyed");
}

// ============================================================================
// LIFECYCLE IMPLEMENTATION
// ============================================================================

bool PrivilegeEscalationDetectorImpl::Initialize(
    const PrivilegeEscalationDetectorConfiguration& config) {

    std::unique_lock lock(m_mutex);

    try {
        if (m_status != ModuleStatus::Uninitialized) {
            Utils::Logger::Warn("PrivilegeEscalationDetector already initialized");
            return false;
        }

        m_status = ModuleStatus::Initializing;

        // Validate configuration
        if (!config.IsValid()) {
            Utils::Logger::Error("Invalid configuration provided");
            m_status = ModuleStatus::Error;
            return false;
        }

        m_config = config;

        // Initialize statistics
        m_stats.Reset();

        // Clear caches
        m_processTokens.clear();
        m_monitoredProcesses.clear();
        m_tokenHistory.clear();
        m_recentDetections.clear();
        m_dllHijackCache.clear();

        m_status = ModuleStatus::Running;

        Utils::Logger::Info("PrivilegeEscalationDetector initialized successfully");
        return true;

    } catch (const std::exception& e) {
        Utils::Logger::Critical("Initialization failed: {}", e.what());
        m_status = ModuleStatus::Error;
        return false;
    } catch (...) {
        Utils::Logger::Critical("Initialization failed with unknown exception");
        m_status = ModuleStatus::Error;
        return false;
    }
}

void PrivilegeEscalationDetectorImpl::Shutdown() {
    std::unique_lock lock(m_mutex);

    try {
        if (m_status == ModuleStatus::Stopped || m_status == ModuleStatus::Uninitialized) {
            return;
        }

        m_status = ModuleStatus::Stopping;

        // Stop monitoring thread
        m_stopMonitoring = true;
        lock.unlock();

        if (m_monitoringThread && m_monitoringThread->joinable()) {
            m_monitoringThread->join();
        }

        lock.lock();

        // Clear all state
        m_processTokens.clear();
        m_monitoredProcesses.clear();
        m_tokenHistory.clear();
        m_recentDetections.clear();
        m_cachedVulnerableServices.clear();
        m_dllHijackCache.clear();

        UnregisterCallbacks();

        m_status = ModuleStatus::Stopped;

        Utils::Logger::Info("PrivilegeEscalationDetector shutdown complete");

    } catch (const std::exception& e) {
        Utils::Logger::Error("Shutdown error: {}", e.what());
    } catch (...) {
        Utils::Logger::Error("Shutdown error: unknown exception");
    }
}

bool PrivilegeEscalationDetectorImpl::Start() {
    std::unique_lock lock(m_mutex);

    try {
        if (m_status != ModuleStatus::Running) {
            Utils::Logger::Error("Cannot start: module not initialized");
            return false;
        }

        if (m_monitoringThread && m_monitoringThread->joinable()) {
            Utils::Logger::Warn("Monitoring already started");
            return true;
        }

        m_stopMonitoring = false;
        m_paused = false;

        m_monitoringThread = std::make_unique<std::thread>(
            &PrivilegeEscalationDetectorImpl::MonitoringThreadFunc, this);

        Utils::Logger::Info("PrivilegeEscalationDetector monitoring started");
        return true;

    } catch (const std::exception& e) {
        Utils::Logger::Error("Start failed: {}", e.what());
        return false;
    }
}

bool PrivilegeEscalationDetectorImpl::Stop() {
    try {
        m_stopMonitoring = true;

        if (m_monitoringThread && m_monitoringThread->joinable()) {
            m_monitoringThread->join();
            m_monitoringThread.reset();
        }

        Utils::Logger::Info("PrivilegeEscalationDetector monitoring stopped");
        return true;

    } catch (const std::exception& e) {
        Utils::Logger::Error("Stop failed: {}", e.what());
        return false;
    }
}

void PrivilegeEscalationDetectorImpl::Pause() {
    m_paused = true;
    Utils::Logger::Info("PrivilegeEscalationDetector paused");
}

void PrivilegeEscalationDetectorImpl::Resume() {
    m_paused = false;
    Utils::Logger::Info("PrivilegeEscalationDetector resumed");
}

bool PrivilegeEscalationDetectorImpl::UpdateConfiguration(
    const PrivilegeEscalationDetectorConfiguration& config) {

    std::unique_lock lock(m_mutex);

    if (!config.IsValid()) {
        Utils::Logger::Error("Invalid configuration update");
        return false;
    }

    m_config = config;
    Utils::Logger::Info("Configuration updated");
    return true;
}

PrivilegeEscalationDetectorConfiguration PrivilegeEscalationDetectorImpl::GetConfiguration() const {
    std::shared_lock lock(m_mutex);
    return m_config;
}

// ============================================================================
// TOKEN ANALYSIS IMPLEMENTATION
// ============================================================================

TokenInfo PrivilegeEscalationDetectorImpl::GetProcessToken(uint32_t processId) {
    TokenInfo info;
    info.processId = processId;
    info.snapshotTime = std::chrono::system_clock::now();

    try {
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, processId);
        if (!hProcess) {
            Utils::Logger::Warn("Failed to open process {}: {}", processId, GetLastError());
            return info;
        }

        HANDLE hToken = nullptr;
        if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
            Utils::Logger::Warn("Failed to open token for process {}: {}", processId, GetLastError());
            CloseHandle(hProcess);
            return info;
        }

        info = ExtractTokenInfo(hToken, processId);

        CloseHandle(hToken);
        CloseHandle(hProcess);

    } catch (const std::exception& e) {
        Utils::Logger::Error("GetProcessToken failed for PID {}: {}", processId, e.what());
    } catch (...) {
        Utils::Logger::Error("GetProcessToken failed for PID {}: unknown exception", processId);
    }

    return info;
}

TokenInfo PrivilegeEscalationDetectorImpl::ExtractTokenInfo(HANDLE hToken, uint32_t processId) {
    TokenInfo info;
    info.processId = processId;
    info.tokenHandle = reinterpret_cast<uint64_t>(hToken);
    info.snapshotTime = std::chrono::system_clock::now();

    // Get token type
    DWORD cbSize = 0;
    TOKEN_TYPE tokenType;
    if (GetTokenInformation(hToken, TokenType, &tokenType, sizeof(tokenType), &cbSize)) {
        info.tokenType = static_cast<uint32_t>(tokenType);
        info.isPrimaryToken = (tokenType == TokenPrimary);
    }

    // Get user SID
    GetTokenInformation(hToken, TokenUser, nullptr, 0, &cbSize);
    std::vector<uint8_t> userBuffer(cbSize);
    auto pTokenUser = reinterpret_cast<PTOKEN_USER>(userBuffer.data());

    if (GetTokenInformation(hToken, TokenUser, pTokenUser, cbSize, &cbSize)) {
        info.userSid = SidToString(pTokenUser->User.Sid);
    }

    // Get session ID
    DWORD sessionId = 0;
    cbSize = sizeof(sessionId);
    if (GetTokenInformation(hToken, TokenSessionId, &sessionId, cbSize, &cbSize)) {
        info.sessionId = sessionId;
    }

    // Get elevation status
    TOKEN_ELEVATION elevation = {0};
    cbSize = sizeof(elevation);
    if (GetTokenInformation(hToken, TokenElevation, &elevation, cbSize, &cbSize)) {
        info.isElevated = (elevation.TokenIsElevated != 0);
    }

    // Get integrity level
    GetTokenInformation(hToken, TokenIntegrityLevel, nullptr, 0, &cbSize);
    std::vector<uint8_t> integrityBuffer(cbSize);
    auto pIntegrity = reinterpret_cast<PTOKEN_MANDATORY_LABEL>(integrityBuffer.data());

    if (GetTokenInformation(hToken, TokenIntegrityLevel, pIntegrity, cbSize, &cbSize)) {
        info.integritySid = SidToString(pIntegrity->Label.Sid);
        info.integrityLevel = ParseIntegrityLevel(info.integritySid);
    }

    // Get privileges
    info.privileges = GetTokenPrivileges(hToken);

    for (const auto& priv : info.privileges) {
        if (priv.isEnabled) {
            info.enabledPrivilegeCount++;
        }

        if (priv.name == L"SeDebugPrivilege") {
            info.hasSeDebugPrivilege = priv.isEnabled;
        } else if (priv.name == L"SeImpersonatePrivilege") {
            info.hasSeImpersonatePrivilege = priv.isEnabled;
        } else if (priv.name == L"SeTcbPrivilege") {
            info.hasSeTcbPrivilege = priv.isEnabled;
        }
    }

    return info;
}

std::vector<PrivilegeInfo> PrivilegeEscalationDetectorImpl::GetTokenPrivileges(HANDLE hToken) {
    std::vector<PrivilegeInfo> privileges;

    DWORD cbSize = 0;
    GetTokenInformation(hToken, TokenPrivileges, nullptr, 0, &cbSize);

    std::vector<uint8_t> buffer(cbSize);
    auto pPrivileges = reinterpret_cast<PTOKEN_PRIVILEGES>(buffer.data());

    if (!GetTokenInformation(hToken, TokenPrivileges, pPrivileges, cbSize, &cbSize)) {
        return privileges;
    }

    for (DWORD i = 0; i < pPrivileges->PrivilegeCount; ++i) {
        PrivilegeInfo info;

        // Get LUID
        info.luid = *reinterpret_cast<uint64_t*>(&pPrivileges->Privileges[i].Luid);

        // Get privilege name
        wchar_t name[256] = {0};
        DWORD nameLen = _countof(name);
        if (LookupPrivilegeNameW(nullptr, &pPrivileges->Privileges[i].Luid, name, &nameLen)) {
            info.name = name;
        }

        // Check attributes
        DWORD attrs = pPrivileges->Privileges[i].Attributes;
        info.isEnabled = (attrs & SE_PRIVILEGE_ENABLED) != 0;
        info.isEnabledByDefault = (attrs & SE_PRIVILEGE_ENABLED_BY_DEFAULT) != 0;
        info.isRemoved = (attrs & SE_PRIVILEGE_REMOVED) != 0;
        info.usedForImpersonation = (attrs & SE_PRIVILEGE_USED_FOR_ACCESS) != 0;

        privileges.push_back(info);
    }

    return privileges;
}

bool PrivilegeEscalationDetectorImpl::AnalyzeTokenIntegrity(uint32_t processId) {
    try {
        auto currentToken = GetProcessToken(processId);

        std::shared_lock lock(m_mutex);

        // Check if we have a previous snapshot
        auto it = m_processTokens.find(processId);
        if (it == m_processTokens.end()) {
            // First time seeing this process
            lock.unlock();
            std::unique_lock wlock(m_mutex);
            m_processTokens[processId] = currentToken;
            return true;
        }

        const auto& previousToken = it->second;

        // Compare tokens
        bool suspicious = false;

        // Check for integrity level elevation
        if (currentToken.integrityLevel > previousToken.integrityLevel) {
            Utils::Logger::Warn("Process {} elevated from {} to {}",
                processId,
                GetIntegrityLevelName(previousToken.integrityLevel),
                GetIntegrityLevelName(currentToken.integrityLevel));
            suspicious = true;
        }

        // Check for new dangerous privileges
        for (const auto& priv : currentToken.privileges) {
            if (!priv.isEnabled) continue;
            if (DANGEROUS_PRIVILEGES.find(priv.name) == DANGEROUS_PRIVILEGES.end()) {
                continue;
            }

            // Check if this privilege was not enabled before
            bool wasEnabled = false;
            for (const auto& prevPriv : previousToken.privileges) {
                if (prevPriv.name == priv.name && prevPriv.isEnabled) {
                    wasEnabled = true;
                    break;
                }
            }

            if (!wasEnabled) {
                Utils::Logger::Warn("Process {} gained dangerous privilege: {}",
                    processId,
                    Utils::StringUtils::WStringToString(priv.name));
                suspicious = true;
            }
        }

        // Check for user SID change (token stealing)
        if (currentToken.userSid != previousToken.userSid) {
            Utils::Logger::Error("Process {} changed user SID (token stealing): {} -> {}",
                processId,
                Utils::StringUtils::WStringToString(previousToken.userSid),
                Utils::StringUtils::WStringToString(currentToken.userSid));
            suspicious = true;
        }

        return !suspicious;

    } catch (const std::exception& e) {
        Utils::Logger::Error("AnalyzeTokenIntegrity failed for PID {}: {}", processId, e.what());
        return false;
    }
}

std::optional<TokenChangeInfo> PrivilegeEscalationDetectorImpl::DetectTokenManipulation(
    uint32_t processId) {

    try {
        auto currentToken = GetProcessToken(processId);

        std::shared_lock lock(m_mutex);
        auto it = m_processTokens.find(processId);
        if (it == m_processTokens.end()) {
            return std::nullopt;
        }

        const auto& previousToken = it->second;

        TokenChangeInfo change;
        change.eventId = GenerateEventId();
        change.processId = processId;
        change.timestamp = std::chrono::system_clock::now();
        change.originalUser = previousToken.userName;
        change.newUser = currentToken.userName;
        change.originalIntegrity = previousToken.integrityLevel;
        change.newIntegrity = currentToken.integrityLevel;
        change.tokenBefore = previousToken;
        change.tokenAfter = currentToken;

        // Detect type of change
        if (currentToken.integrityLevel > previousToken.integrityLevel) {
            change.changeType = TokenChangeType::IntegrityElevated;
            change.isElevation = true;
            m_stats.tokenChangesDetected++;
        } else if (currentToken.userSid != previousToken.userSid) {
            change.changeType = TokenChangeType::UserChanged;
            m_stats.tokenChangesDetected++;
        } else {
            // Check for privilege changes
            for (const auto& priv : currentToken.privileges) {
                if (!priv.isEnabled) continue;

                bool found = false;
                for (const auto& prevPriv : previousToken.privileges) {
                    if (prevPriv.name == priv.name) {
                        found = true;
                        if (!prevPriv.isEnabled && priv.isEnabled) {
                            change.enabledPrivileges.push_back(priv.name);
                        }
                        break;
                    }
                }

                if (!found) {
                    change.addedPrivileges.push_back(priv.name);
                }
            }

            if (!change.addedPrivileges.empty()) {
                change.changeType = TokenChangeType::PrivilegeAdded;
                m_stats.tokenChangesDetected++;
            } else if (!change.enabledPrivileges.empty()) {
                change.changeType = TokenChangeType::PrivilegeEnabled;
                m_stats.tokenChangesDetected++;
            } else {
                return std::nullopt;
            }
        }

        // Calculate suspicion score
        change.suspicionScore = CalculateSuspicionScore(change);

        // Record in history
        lock.unlock();
        std::unique_lock wlock(m_mutex);

        m_processTokens[processId] = currentToken;

        auto& history = m_tokenHistory[processId];
        history.push_back(change);
        if (history.size() > 1000) {
            history.erase(history.begin(), history.begin() + 100);
        }

        // Notify callbacks
        wlock.unlock();
        NotifyTokenChange(change);

        return change;

    } catch (const std::exception& e) {
        Utils::Logger::Error("DetectTokenManipulation failed for PID {}: {}", processId, e.what());
        return std::nullopt;
    }
}

double PrivilegeEscalationDetectorImpl::CalculateSuspicionScore(
    const TokenChangeInfo& change) const {

    double score = 0.0;

    // Integrity elevation is highly suspicious
    if (change.isElevation) {
        int levelDiff = static_cast<int>(change.newIntegrity) -
                       static_cast<int>(change.originalIntegrity);
        score += levelDiff * 15.0;
    }

    // User change is extremely suspicious
    if (change.changeType == TokenChangeType::UserChanged) {
        score += 50.0;
    }

    // Dangerous privileges
    for (const auto& priv : change.addedPrivileges) {
        if (DANGEROUS_PRIVILEGES.find(priv) != DANGEROUS_PRIVILEGES.end()) {
            score += 20.0;
        } else {
            score += 5.0;
        }
    }

    for (const auto& priv : change.enabledPrivileges) {
        if (DANGEROUS_PRIVILEGES.find(priv) != DANGEROUS_PRIVILEGES.end()) {
            score += 15.0;
        } else {
            score += 3.0;
        }
    }

    return std::min(score, 100.0);
}

std::vector<TokenChangeInfo> PrivilegeEscalationDetectorImpl::GetTokenHistory(
    uint32_t processId, size_t maxEntries) const {

    std::shared_lock lock(m_mutex);

    auto it = m_tokenHistory.find(processId);
    if (it == m_tokenHistory.end()) {
        return {};
    }

    const auto& history = it->second;

    if (history.size() <= maxEntries) {
        return history;
    }

    return std::vector<TokenChangeInfo>(
        history.end() - maxEntries,
        history.end()
    );
}

// ============================================================================
// UAC BYPASS DETECTION IMPLEMENTATION
// ============================================================================

void PrivilegeEscalationDetectorImpl::MonitorUacBypassPoints() {
    if (!m_config.monitorUACBypass) {
        return;
    }

    try {
        // Monitor known UAC bypass registry keys
        for (const auto& regPath : PrivEscConstants::UAC_BYPASS_PATHS) {
            // Check if key exists and has suspicious values
            auto value = Utils::RegistryUtils::ReadStringValue(
                HKEY_CURRENT_USER, regPath, L"");

            if (!value.empty()) {
                Utils::Logger::Warn("Suspicious UAC bypass registry key found: {}",
                    Utils::StringUtils::WStringToString(regPath));

                m_stats.uacBypassesDetected++;
            }
        }

        // Check custom paths from configuration
        for (const auto& regPath : m_config.additionalUacPaths) {
            auto value = Utils::RegistryUtils::ReadStringValue(
                HKEY_CURRENT_USER, regPath.c_str(), L"");

            if (!value.empty()) {
                Utils::Logger::Warn("Custom UAC bypass path triggered: {}",
                    Utils::StringUtils::WStringToString(regPath));

                m_stats.uacBypassesDetected++;
            }
        }

    } catch (const std::exception& e) {
        Utils::Logger::Error("MonitorUacBypassPoints failed: {}", e.what());
    }
}

std::vector<LpeEvent> PrivilegeEscalationDetectorImpl::DetectUACBypasses() {
    std::vector<LpeEvent> events;

    if (!m_config.monitorUACBypass) {
        return events;
    }

    try {
        // Check for fodhelper bypass
        auto fodhelperKey = L"Software\\Classes\\ms-settings\\Shell\\Open\\command";
        auto fodhelperValue = Utils::RegistryUtils::ReadStringValue(
            HKEY_CURRENT_USER, fodhelperKey, L"");

        if (!fodhelperValue.empty()) {
            LpeEvent event;
            event.eventId = GenerateEventId();
            event.technique = LpeTechnique::FodhelperBypass;
            event.techniqueName = "Fodhelper UAC Bypass";
            event.mitreAttackId = "T1548.002";
            event.targetRegistryKey = fodhelperKey;
            event.confidence = DetectionConfidence::VeryHigh;
            event.confidenceScore = 95.0;
            event.timestamp = std::chrono::system_clock::now();
            event.details = "Fodhelper.exe UAC bypass detected via registry manipulation";

            events.push_back(event);
            m_stats.uacBypassesDetected++;

            NotifyLpeDetected(event);
        }

        // Check for eventvwr bypass
        auto eventvwrKey = L"Software\\Classes\\mscfile\\shell\\open\\command";
        auto eventvwrValue = Utils::RegistryUtils::ReadStringValue(
            HKEY_CURRENT_USER, eventvwrKey, L"");

        if (!eventvwrValue.empty()) {
            LpeEvent event;
            event.eventId = GenerateEventId();
            event.technique = LpeTechnique::EventViewerBypass;
            event.techniqueName = "Event Viewer UAC Bypass";
            event.mitreAttackId = "T1548.002";
            event.targetRegistryKey = eventvwrKey;
            event.confidence = DetectionConfidence::VeryHigh;
            event.confidenceScore = 95.0;
            event.timestamp = std::chrono::system_clock::now();
            event.details = "Event Viewer UAC bypass detected via registry manipulation";

            events.push_back(event);
            m_stats.uacBypassesDetected++;

            NotifyLpeDetected(event);
        }

        // Check for computerdefaults bypass
        auto compdefKey = L"Software\\Classes\\Folder\\shell\\open\\command";
        auto compdefValue = Utils::RegistryUtils::ReadStringValue(
            HKEY_CURRENT_USER, compdefKey, L"");

        if (!compdefValue.empty()) {
            LpeEvent event;
            event.eventId = GenerateEventId();
            event.technique = LpeTechnique::ComputerDefaultsBypass;
            event.techniqueName = "ComputerDefaults UAC Bypass";
            event.mitreAttackId = "T1548.002";
            event.targetRegistryKey = compdefKey;
            event.confidence = DetectionConfidence::VeryHigh;
            event.confidenceScore = 95.0;
            event.timestamp = std::chrono::system_clock::now();
            event.details = "ComputerDefaults UAC bypass detected";

            events.push_back(event);
            m_stats.uacBypassesDetected++;

            NotifyLpeDetected(event);
        }

    } catch (const std::exception& e) {
        Utils::Logger::Error("DetectUACBypasses failed: {}", e.what());
    }

    return events;
}

bool PrivilegeEscalationDetectorImpl::CheckUACBypassTechnique(LpeTechnique technique) {
    try {
        switch (technique) {
            case LpeTechnique::FodhelperBypass: {
                auto value = Utils::RegistryUtils::ReadStringValue(
                    HKEY_CURRENT_USER,
                    L"Software\\Classes\\ms-settings\\Shell\\Open\\command",
                    L"");
                return !value.empty();
            }

            case LpeTechnique::EventViewerBypass: {
                auto value = Utils::RegistryUtils::ReadStringValue(
                    HKEY_CURRENT_USER,
                    L"Software\\Classes\\mscfile\\shell\\open\\command",
                    L"");
                return !value.empty();
            }

            case LpeTechnique::ComputerDefaultsBypass: {
                auto value = Utils::RegistryUtils::ReadStringValue(
                    HKEY_CURRENT_USER,
                    L"Software\\Classes\\Folder\\shell\\open\\command",
                    L"");
                return !value.empty();
            }

            default:
                return false;
        }

    } catch (const std::exception& e) {
        Utils::Logger::Error("CheckUACBypassTechnique failed: {}", e.what());
        return false;
    }
}

// ============================================================================
// SERVICE ANALYSIS IMPLEMENTATION
// ============================================================================

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetectorImpl::ScanServices() {
    std::vector<ServiceSecurityInfo> services;

    if (!m_config.monitorServiceConfig) {
        return services;
    }

    try {
        SC_HANDLE hSCManager = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_ENUMERATE_SERVICE);
        if (!hSCManager) {
            Utils::Logger::Error("Failed to open service control manager: {}", GetLastError());
            return services;
        }

        DWORD bytesNeeded = 0;
        DWORD servicesReturned = 0;
        DWORD resumeHandle = 0;

        // First call to get size
        EnumServicesStatusExW(
            hSCManager,
            SC_ENUM_PROCESS_INFO,
            SERVICE_WIN32,
            SERVICE_STATE_ALL,
            nullptr,
            0,
            &bytesNeeded,
            &servicesReturned,
            &resumeHandle,
            nullptr
        );

        std::vector<uint8_t> buffer(bytesNeeded);
        auto pServices = reinterpret_cast<LPENUM_SERVICE_STATUS_PROCESSW>(buffer.data());

        if (EnumServicesStatusExW(
                hSCManager,
                SC_ENUM_PROCESS_INFO,
                SERVICE_WIN32,
                SERVICE_STATE_ALL,
                reinterpret_cast<LPBYTE>(pServices),
                bytesNeeded,
                &bytesNeeded,
                &servicesReturned,
                &resumeHandle,
                nullptr)) {

            for (DWORD i = 0; i < servicesReturned; ++i) {
                auto info = AnalyzeService(pServices[i].lpServiceName);

                if (info.vulnerability != ServiceVulnerability::None) {
                    services.push_back(info);
                    m_stats.serviceAbusesDetected++;
                }
            }
        }

        CloseServiceHandle(hSCManager);

        // Cache results
        {
            std::unique_lock lock(m_mutex);
            m_cachedVulnerableServices = services;
            m_lastServiceScanTime = Clock::now();
        }

    } catch (const std::exception& e) {
        Utils::Logger::Error("ScanServices failed: {}", e.what());
    }

    return services;
}

ServiceSecurityInfo PrivilegeEscalationDetectorImpl::AnalyzeService(const std::wstring& serviceName) {
    ServiceSecurityInfo info;
    info.serviceName = serviceName;

    try {
        SC_HANDLE hSCManager = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
        if (!hSCManager) {
            return info;
        }

        SC_HANDLE hService = OpenServiceW(hSCManager, serviceName.c_str(),
            SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);

        if (!hService) {
            CloseServiceHandle(hSCManager);
            return info;
        }

        // Get service configuration
        DWORD bytesNeeded = 0;
        QueryServiceConfigW(hService, nullptr, 0, &bytesNeeded);

        std::vector<uint8_t> configBuffer(bytesNeeded);
        auto pConfig = reinterpret_cast<LPQUERY_SERVICE_CONFIGW>(configBuffer.data());

        if (QueryServiceConfigW(hService, pConfig, bytesNeeded, &bytesNeeded)) {
            info.binaryPath = pConfig->lpBinaryPathName ? pConfig->lpBinaryPathName : L"";
            info.displayName = pConfig->lpDisplayName ? pConfig->lpDisplayName : L"";
            info.startType = pConfig->dwStartType;
            info.serviceType = pConfig->dwServiceType;
            info.runAsAccount = pConfig->lpServiceStartName ? pConfig->lpServiceStartName : L"";

            // Check for unquoted path
            if (HasUnquotedPath(info.binaryPath)) {
                info.hasUnquotedPath = true;
                info.vulnerability = ServiceVulnerability::UnquotedPath;

                Utils::Logger::Warn("Service '{}' has unquoted path: {}",
                    Utils::StringUtils::WStringToString(serviceName),
                    Utils::StringUtils::WStringToString(info.binaryPath));
            }

            // Check if binary path is writable
            if (!info.binaryPath.empty()) {
                // Extract actual path (remove arguments)
                std::wstring binaryOnly = info.binaryPath;
                auto spacePos = binaryOnly.find(L' ');
                if (spacePos != std::wstring::npos) {
                    binaryOnly = binaryOnly.substr(0, spacePos);
                }

                // Remove quotes
                if (!binaryOnly.empty() && binaryOnly[0] == L'"') {
                    binaryOnly = binaryOnly.substr(1);
                }
                if (!binaryOnly.empty() && binaryOnly.back() == L'"') {
                    binaryOnly.pop_back();
                }

                // Check if file exists and is writable
                if (fs::exists(binaryOnly)) {
                    DWORD attrs = GetFileAttributesW(binaryOnly.c_str());
                    if (attrs != INVALID_FILE_ATTRIBUTES) {
                        // Try to open for writing (basic check)
                        HANDLE hFile = CreateFileW(
                            binaryOnly.c_str(),
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            nullptr,
                            OPEN_EXISTING,
                            0,
                            nullptr
                        );

                        if (hFile != INVALID_HANDLE_VALUE) {
                            info.isPathWritable = true;
                            info.vulnerability = ServiceVulnerability::WeakFilePermissions;
                            CloseHandle(hFile);

                            Utils::Logger::Warn("Service '{}' binary is writable: {}",
                                Utils::StringUtils::WStringToString(serviceName),
                                Utils::StringUtils::WStringToString(binaryOnly));
                        }
                    }
                }
            }
        }

        // Get service status
        SERVICE_STATUS_PROCESS status = {0};
        bytesNeeded = 0;
        if (QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO,
                reinterpret_cast<LPBYTE>(&status), sizeof(status), &bytesNeeded)) {
            info.currentState = status.dwCurrentState;
        }

        CloseServiceHandle(hService);
        CloseServiceHandle(hSCManager);

    } catch (const std::exception& e) {
        Utils::Logger::Error("AnalyzeService failed for '{}': {}",
            Utils::StringUtils::WStringToString(serviceName), e.what());
    }

    return info;
}

bool PrivilegeEscalationDetectorImpl::HasUnquotedPath(const std::wstring& path) const {
    if (path.empty() || path.length() < 3) {
        return false;
    }

    // If path starts with quote, it's properly quoted
    if (path[0] == L'"') {
        return false;
    }

    // Check if path contains spaces and is not quoted
    if (path.find(L' ') != std::wstring::npos) {
        // Exception: paths starting with system directories are usually safe
        if (path.find(L"C:\\Windows\\") == 0 || path.find(L"C:\\Program Files\\") == 0) {
            // Even system paths should be quoted if they have spaces in arguments
            auto firstSpace = path.find(L' ');
            if (firstSpace != std::wstring::npos) {
                // Check if space is before .exe
                auto exePos = path.find(L".exe");
                if (exePos != std::wstring::npos && firstSpace < exePos) {
                    return true;
                }
            }
        } else {
            return true;
        }
    }

    return false;
}

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetectorImpl::GetVulnerableServices() {
    std::shared_lock lock(m_mutex);

    // Return cached results if recent
    auto timeSinceLastScan = Clock::now() - m_lastServiceScanTime;
    if (timeSinceLastScan < std::chrono::minutes(5) && !m_cachedVulnerableServices.empty()) {
        return m_cachedVulnerableServices;
    }

    lock.unlock();

    // Rescan
    return ScanServices();
}

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetectorImpl::FindUnquotedPaths() {
    auto allServices = ScanServices();

    std::vector<ServiceSecurityInfo> unquoted;
    std::copy_if(allServices.begin(), allServices.end(), std::back_inserter(unquoted),
        [](const ServiceSecurityInfo& info) {
            return info.hasUnquotedPath;
        });

    return unquoted;
}

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetectorImpl::FindWeakPermissions() {
    auto allServices = ScanServices();

    std::vector<ServiceSecurityInfo> weak;
    std::copy_if(allServices.begin(), allServices.end(), std::back_inserter(weak),
        [](const ServiceSecurityInfo& info) {
            return info.isPathWritable || info.isConfigModifiable;
        });

    return weak;
}

// ============================================================================
// DLL HIJACK ANALYSIS
// ============================================================================

std::vector<std::wstring> PrivilegeEscalationDetectorImpl::ScanDLLHijackPaths(uint32_t processId) {
    std::vector<std::wstring> vulnerablePaths;

    try {
        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId);
        if (!hProcess) {
            return vulnerablePaths;
        }

        wchar_t processPath[MAX_PATH] = {0};
        DWORD pathLen = MAX_PATH;
        if (QueryFullProcessImageNameW(hProcess, 0, processPath, &pathLen)) {
            fs::path exePath(processPath);
            fs::path exeDir = exePath.parent_path();

            // Check if exe directory is writable (DLL search order hijacking)
            if (IsDLLHijackVulnerable(exeDir.wstring())) {
                vulnerablePaths.push_back(exeDir.wstring());
                m_stats.dllHijacksDetected++;
            }
        }

        CloseHandle(hProcess);

    } catch (const std::exception& e) {
        Utils::Logger::Error("ScanDLLHijackPaths failed for PID {}: {}", processId, e.what());
    }

    return vulnerablePaths;
}

bool PrivilegeEscalationDetectorImpl::IsDLLHijackVulnerable(const std::wstring& path) {
    // Check cache first
    {
        std::shared_lock lock(m_mutex);
        auto it = m_dllHijackCache.find(path);
        if (it != m_dllHijackCache.end()) {
            return it->second;
        }
    }

    bool vulnerable = false;

    try {
        if (!fs::exists(path)) {
            return false;
        }

        // Try to create a test file to check write permissions
        fs::path testFile = fs::path(path) / L"_ss_test_write.tmp";

        HANDLE hFile = CreateFileW(
            testFile.c_str(),
            GENERIC_WRITE,
            0,
            nullptr,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
            nullptr
        );

        if (hFile != INVALID_HANDLE_VALUE) {
            vulnerable = true;
            CloseHandle(hFile);
        }

    } catch (...) {
        vulnerable = false;
    }

    // Cache result
    {
        std::unique_lock lock(m_mutex);
        m_dllHijackCache[path] = vulnerable;
    }

    return vulnerable;
}

// ============================================================================
// REGISTRY ANALYSIS
// ============================================================================

bool PrivilegeEscalationDetectorImpl::IsAlwaysInstallElevatedEnabled() {
    try {
        // Check HKLM
        auto hklmValue = Utils::RegistryUtils::ReadDwordValue(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
            L"AlwaysInstallElevated"
        );

        // Check HKCU
        auto hkcuValue = Utils::RegistryUtils::ReadDwordValue(
            HKEY_CURRENT_USER,
            L"SOFTWARE\\Policies\\Microsoft\\Windows\\Installer",
            L"AlwaysInstallElevated"
        );

        bool enabled = (hklmValue == 1 && hkcuValue == 1);

        if (enabled) {
            Utils::Logger::Warn("AlwaysInstallElevated is enabled - privilege escalation vector!");
            m_stats.registryAbusesDetected++;
        }

        return enabled;

    } catch (const std::exception& e) {
        Utils::Logger::Error("IsAlwaysInstallElevatedEnabled failed: {}", e.what());
        return false;
    }
}

std::vector<std::pair<std::wstring, std::wstring>> PrivilegeEscalationDetectorImpl::GetIFEODebuggers() {
    std::vector<std::pair<std::wstring, std::wstring>> debuggers;

    try {
        const wchar_t* ifeoPath = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options";

        // This would require enumerating subkeys - simplified version
        // In production, use RegEnumKeyEx to enumerate all IFEO entries

        Utils::Logger::Info("IFEO debuggers check completed");

    } catch (const std::exception& e) {
        Utils::Logger::Error("GetIFEODebuggers failed: {}", e.what());
    }

    return debuggers;
}

// ============================================================================
// MONITORING
// ============================================================================

bool PrivilegeEscalationDetectorImpl::MonitorProcess(uint32_t processId) {
    std::unique_lock lock(m_mutex);

    if (m_monitoredProcesses.size() >= PrivEscConstants::MAX_MONITORED_PROCESSES) {
        Utils::Logger::Warn("Maximum monitored processes reached");
        return false;
    }

    m_monitoredProcesses.insert(processId);

    // Take initial token snapshot
    lock.unlock();
    auto token = GetProcessToken(processId);
    lock.lock();

    m_processTokens[processId] = token;
    m_stats.processesMonitored++;

    Utils::Logger::Info("Now monitoring process {}", processId);
    return true;
}

bool PrivilegeEscalationDetectorImpl::StopMonitoring(uint32_t processId) {
    std::unique_lock lock(m_mutex);

    auto it = m_monitoredProcesses.find(processId);
    if (it == m_monitoredProcesses.end()) {
        return false;
    }

    m_monitoredProcesses.erase(it);
    m_processTokens.erase(processId);

    Utils::Logger::Info("Stopped monitoring process {}", processId);
    return true;
}

bool PrivilegeEscalationDetectorImpl::IsMonitoring(uint32_t processId) const {
    std::shared_lock lock(m_mutex);
    return m_monitoredProcesses.find(processId) != m_monitoredProcesses.end();
}

std::vector<uint32_t> PrivilegeEscalationDetectorImpl::GetMonitoredProcesses() const {
    std::shared_lock lock(m_mutex);
    return std::vector<uint32_t>(m_monitoredProcesses.begin(), m_monitoredProcesses.end());
}

void PrivilegeEscalationDetectorImpl::MonitoringThreadFunc() {
    Utils::Logger::Info("Privilege escalation monitoring thread started");

    while (!m_stopMonitoring) {
        if (!m_paused) {
            ProcessMonitoringLoop();
        }

        // Sleep for configured interval
        std::this_thread::sleep_for(std::chrono::milliseconds(m_config.tokenCheckIntervalMs));
    }

    Utils::Logger::Info("Privilege escalation monitoring thread stopped");
}

void PrivilegeEscalationDetectorImpl::ProcessMonitoringLoop() {
    try {
        std::vector<uint32_t> processesToMonitor;

        {
            std::shared_lock lock(m_mutex);
            processesToMonitor.assign(m_monitoredProcesses.begin(), m_monitoredProcesses.end());
        }

        for (uint32_t pid : processesToMonitor) {
            // Check token integrity
            if (m_config.monitorTokenChanges) {
                auto change = DetectTokenManipulation(pid);
                if (change.has_value() && change->suspicionScore > 50.0) {
                    Utils::Logger::Warn("High suspicion token change detected in PID {}: score={}",
                        pid, change->suspicionScore);
                }
            }
        }

        // Periodically check UAC bypass points
        if (m_config.monitorUACBypass) {
            static int uacCheckCounter = 0;
            if (++uacCheckCounter >= 10) { // Every 10 iterations
                MonitorUacBypassPoints();
                DetectUACBypasses();
                uacCheckCounter = 0;
            }
        }

    } catch (const std::exception& e) {
        Utils::Logger::Error("ProcessMonitoringLoop error: {}", e.what());
    }
}

// ============================================================================
// CALLBACKS
// ============================================================================

void PrivilegeEscalationDetectorImpl::RegisterLpeCallback(LpeDetectedCallback callback) {
    std::unique_lock lock(m_mutex);
    m_lpeCallbacks.push_back(std::move(callback));
}

void PrivilegeEscalationDetectorImpl::RegisterTokenChangeCallback(TokenChangeCallback callback) {
    std::unique_lock lock(m_mutex);
    m_tokenChangeCallbacks.push_back(std::move(callback));
}

void PrivilegeEscalationDetectorImpl::RegisterServiceVulnerabilityCallback(
    ServiceVulnerabilityCallback callback) {
    std::unique_lock lock(m_mutex);
    m_serviceVulnCallbacks.push_back(std::move(callback));
}

void PrivilegeEscalationDetectorImpl::RegisterErrorCallback(ErrorCallback callback) {
    std::unique_lock lock(m_mutex);
    m_errorCallbacks.push_back(std::move(callback));
}

void PrivilegeEscalationDetectorImpl::UnregisterCallbacks() {
    std::unique_lock lock(m_mutex);
    m_lpeCallbacks.clear();
    m_tokenChangeCallbacks.clear();
    m_serviceVulnCallbacks.clear();
    m_errorCallbacks.clear();
}

void PrivilegeEscalationDetectorImpl::NotifyLpeDetected(const LpeEvent& event) {
    std::shared_lock lock(m_mutex);
    auto callbacks = m_lpeCallbacks;
    lock.unlock();

    for (const auto& callback : callbacks) {
        try {
            callback(event);
        } catch (const std::exception& e) {
            Utils::Logger::Error("LPE callback exception: {}", e.what());
        }
    }

    RecordDetection(event);
}

void PrivilegeEscalationDetectorImpl::NotifyTokenChange(const TokenChangeInfo& change) {
    std::shared_lock lock(m_mutex);
    auto callbacks = m_tokenChangeCallbacks;
    lock.unlock();

    for (const auto& callback : callbacks) {
        try {
            callback(change);
        } catch (const std::exception& e) {
            Utils::Logger::Error("Token change callback exception: {}", e.what());
        }
    }
}

void PrivilegeEscalationDetectorImpl::NotifyServiceVulnerability(const ServiceSecurityInfo& info) {
    std::shared_lock lock(m_mutex);
    auto callbacks = m_serviceVulnCallbacks;
    lock.unlock();

    for (const auto& callback : callbacks) {
        try {
            callback(info);
        } catch (const std::exception& e) {
            Utils::Logger::Error("Service vulnerability callback exception: {}", e.what());
        }
    }
}

void PrivilegeEscalationDetectorImpl::NotifyError(const std::string& message, int code) {
    std::shared_lock lock(m_mutex);
    auto callbacks = m_errorCallbacks;
    lock.unlock();

    for (const auto& callback : callbacks) {
        try {
            callback(message, code);
        } catch (const std::exception& e) {
            Utils::Logger::Error("Error callback exception: {}", e.what());
        }
    }
}

void PrivilegeEscalationDetectorImpl::RecordDetection(const LpeEvent& event) {
    std::unique_lock lock(m_mutex);

    m_recentDetections.push_back(event);

    if (m_recentDetections.size() > MAX_RECENT_DETECTIONS) {
        m_recentDetections.pop_front();
    }
}

// ============================================================================
// STATISTICS
// ============================================================================

PrivEscStatistics PrivilegeEscalationDetectorImpl::GetStatistics() const {
    std::shared_lock lock(m_mutex);
    return m_stats;
}

void PrivilegeEscalationDetectorImpl::ResetStatistics() {
    std::unique_lock lock(m_mutex);
    m_stats.Reset();
    Utils::Logger::Info("Statistics reset");
}

std::vector<LpeEvent> PrivilegeEscalationDetectorImpl::GetRecentDetections(size_t maxCount) const {
    std::shared_lock lock(m_mutex);

    if (m_recentDetections.size() <= maxCount) {
        return std::vector<LpeEvent>(m_recentDetections.begin(), m_recentDetections.end());
    }

    return std::vector<LpeEvent>(
        m_recentDetections.end() - maxCount,
        m_recentDetections.end()
    );
}

// ============================================================================
// SELF TEST
// ============================================================================

bool PrivilegeEscalationDetectorImpl::SelfTest() {
    Utils::Logger::Info("Running PrivilegeEscalationDetector self-test...");

    try {
        // Test 1: Get own process token
        uint32_t currentPid = GetCurrentProcessId();
        auto token = GetProcessToken(currentPid);

        if (token.processId != currentPid) {
            Utils::Logger::Error("Self-test failed: token process ID mismatch");
            return false;
        }

        Utils::Logger::Info(" Token extraction test passed");

        // Test 2: Check integrity level parsing
        auto level = GetProcessIntegrityLevel(GetCurrentProcess());
        if (level == IntegrityLevel::Unknown) {
            Utils::Logger::Warn("Self-test: Could not determine integrity level");
        } else {
            Utils::Logger::Info(" Integrity level: {}", GetIntegrityLevelName(level));
        }

        // Test 3: Service scan
        auto services = ScanServices();
        Utils::Logger::Info(" Service scan completed: {} services analyzed", services.size());

        // Test 4: UAC bypass detection
        auto bypasses = DetectUACBypasses();
        Utils::Logger::Info(" UAC bypass detection: {} potential bypasses", bypasses.size());

        // Test 5: AlwaysInstallElevated check
        bool aie = IsAlwaysInstallElevatedEnabled();
        Utils::Logger::Info(" AlwaysInstallElevated check: {}", aie ? "ENABLED" : "disabled");

        Utils::Logger::Info("All self-tests passed!");
        return true;

    } catch (const std::exception& e) {
        Utils::Logger::Critical("Self-test failed with exception: {}", e.what());
        return false;
    }
}

// ============================================================================
// PUBLIC API IMPLEMENTATION (SINGLETON)
// ============================================================================

PrivilegeEscalationDetector& PrivilegeEscalationDetector::Instance() noexcept {
    static PrivilegeEscalationDetector instance;
    return instance;
}

bool PrivilegeEscalationDetector::HasInstance() noexcept {
    return s_instanceCreated.load();
}

PrivilegeEscalationDetector::PrivilegeEscalationDetector()
    : m_impl(std::make_unique<PrivilegeEscalationDetectorImpl>()) {
    s_instanceCreated = true;
}

PrivilegeEscalationDetector::~PrivilegeEscalationDetector() {
    s_instanceCreated = false;
}

// Forward all public methods to implementation

bool PrivilegeEscalationDetector::Initialize(
    const PrivilegeEscalationDetectorConfiguration& config) {
    return m_impl->Initialize(config);
}

void PrivilegeEscalationDetector::Shutdown() {
    m_impl->Shutdown();
}

bool PrivilegeEscalationDetector::IsInitialized() const noexcept {
    return m_impl->IsInitialized();
}

ModuleStatus PrivilegeEscalationDetector::GetStatus() const noexcept {
    return m_impl->GetStatus();
}

bool PrivilegeEscalationDetector::Start() {
    return m_impl->Start();
}

bool PrivilegeEscalationDetector::Stop() {
    return m_impl->Stop();
}

void PrivilegeEscalationDetector::Pause() {
    m_impl->Pause();
}

void PrivilegeEscalationDetector::Resume() {
    m_impl->Resume();
}

bool PrivilegeEscalationDetector::UpdateConfiguration(
    const PrivilegeEscalationDetectorConfiguration& config) {
    return m_impl->UpdateConfiguration(config);
}

PrivilegeEscalationDetectorConfiguration PrivilegeEscalationDetector::GetConfiguration() const {
    return m_impl->GetConfiguration();
}

TokenInfo PrivilegeEscalationDetector::GetProcessToken(uint32_t processId) {
    return m_impl->GetProcessToken(processId);
}

bool PrivilegeEscalationDetector::AnalyzeTokenIntegrity(uint32_t processId) {
    return m_impl->AnalyzeTokenIntegrity(processId);
}

std::optional<TokenChangeInfo> PrivilegeEscalationDetector::DetectTokenManipulation(
    uint32_t processId) {
    return m_impl->DetectTokenManipulation(processId);
}

std::vector<TokenChangeInfo> PrivilegeEscalationDetector::GetTokenHistory(
    uint32_t processId, size_t maxEntries) const {
    return m_impl->GetTokenHistory(processId, maxEntries);
}

void PrivilegeEscalationDetector::MonitorUacBypassPoints() {
    m_impl->MonitorUacBypassPoints();
}

std::vector<LpeEvent> PrivilegeEscalationDetector::DetectUACBypasses() {
    return m_impl->DetectUACBypasses();
}

bool PrivilegeEscalationDetector::CheckUACBypassTechnique(LpeTechnique technique) {
    return m_impl->CheckUACBypassTechnique(technique);
}

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetector::ScanServices() {
    return m_impl->ScanServices();
}

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetector::GetVulnerableServices() {
    return m_impl->GetVulnerableServices();
}

ServiceSecurityInfo PrivilegeEscalationDetector::AnalyzeService(const std::wstring& serviceName) {
    return m_impl->AnalyzeService(serviceName);
}

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetector::FindUnquotedPaths() {
    return m_impl->FindUnquotedPaths();
}

std::vector<ServiceSecurityInfo> PrivilegeEscalationDetector::FindWeakPermissions() {
    return m_impl->FindWeakPermissions();
}

std::vector<std::wstring> PrivilegeEscalationDetector::ScanDLLHijackPaths(uint32_t processId) {
    return m_impl->ScanDLLHijackPaths(processId);
}

bool PrivilegeEscalationDetector::IsDLLHijackVulnerable(const std::wstring& path) {
    return m_impl->IsDLLHijackVulnerable(path);
}

bool PrivilegeEscalationDetector::IsAlwaysInstallElevatedEnabled() {
    return m_impl->IsAlwaysInstallElevatedEnabled();
}

std::vector<std::pair<std::wstring, std::wstring>> PrivilegeEscalationDetector::GetIFEODebuggers() {
    return m_impl->GetIFEODebuggers();
}

bool PrivilegeEscalationDetector::MonitorProcess(uint32_t processId) {
    return m_impl->MonitorProcess(processId);
}

bool PrivilegeEscalationDetector::StopMonitoring(uint32_t processId) {
    return m_impl->StopMonitoring(processId);
}

bool PrivilegeEscalationDetector::IsMonitoring(uint32_t processId) const {
    return m_impl->IsMonitoring(processId);
}

std::vector<uint32_t> PrivilegeEscalationDetector::GetMonitoredProcesses() const {
    return m_impl->GetMonitoredProcesses();
}

void PrivilegeEscalationDetector::RegisterLpeCallback(LpeDetectedCallback callback) {
    m_impl->RegisterLpeCallback(std::move(callback));
}

void PrivilegeEscalationDetector::RegisterTokenChangeCallback(TokenChangeCallback callback) {
    m_impl->RegisterTokenChangeCallback(std::move(callback));
}

void PrivilegeEscalationDetector::RegisterServiceVulnerabilityCallback(
    ServiceVulnerabilityCallback callback) {
    m_impl->RegisterServiceVulnerabilityCallback(std::move(callback));
}

void PrivilegeEscalationDetector::RegisterErrorCallback(ErrorCallback callback) {
    m_impl->RegisterErrorCallback(std::move(callback));
}

void PrivilegeEscalationDetector::UnregisterCallbacks() {
    m_impl->UnregisterCallbacks();
}

PrivEscStatistics PrivilegeEscalationDetector::GetStatistics() const {
    return m_impl->GetStatistics();
}

void PrivilegeEscalationDetector::ResetStatistics() {
    m_impl->ResetStatistics();
}

std::vector<LpeEvent> PrivilegeEscalationDetector::GetRecentDetections(size_t maxCount) const {
    return m_impl->GetRecentDetections(maxCount);
}

bool PrivilegeEscalationDetector::SelfTest() {
    return m_impl->SelfTest();
}

std::string PrivilegeEscalationDetector::GetVersionString() noexcept {
    std::ostringstream oss;
    oss << PrivEscConstants::VERSION_MAJOR << "."
        << PrivEscConstants::VERSION_MINOR << "."
        << PrivEscConstants::VERSION_PATCH;
    return oss.str();
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

std::string_view GetLpeTechniqueName(LpeTechnique technique) noexcept {
    switch (technique) {
        case LpeTechnique::TokenStealing: return "Token Stealing";
        case LpeTechnique::TokenImpersonation: return "Token Impersonation";
        case LpeTechnique::UacBypassCOM: return "UAC Bypass (COM)";
        case LpeTechnique::UacBypassRegistry: return "UAC Bypass (Registry)";
        case LpeTechnique::UacBypassEnvironment: return "UAC Bypass (Environment)";
        case LpeTechnique::UacBypassDLL: return "UAC Bypass (DLL)";
        case LpeTechnique::UacBypassAutoElevate: return "UAC Bypass (Auto-Elevate)";
        case LpeTechnique::ServiceBinPathAbuse: return "Service Binary Path Abuse";
        case LpeTechnique::ServiceDLLPlanting: return "Service DLL Planting";
        case LpeTechnique::UnquotedServicePath: return "Unquoted Service Path";
        case LpeTechnique::WeakServicePermissions: return "Weak Service Permissions";
        case LpeTechnique::NamedPipeImpersonation: return "Named Pipe Impersonation";
        case LpeTechnique::ScheduledTaskAbuse: return "Scheduled Task Abuse";
        case LpeTechnique::RegistryAlwaysInstall: return "AlwaysInstallElevated";
        case LpeTechnique::RegistryIFEO: return "IFEO Abuse";
        case LpeTechnique::RegistryCLSID: return "CLSID Hijacking";
        case LpeTechnique::DLLSearchOrderHijack: return "DLL Search Order Hijacking";
        case LpeTechnique::DLLPhantom: return "Phantom DLL";
        case LpeTechnique::DLLWinSxS: return "WinSxS DLL Hijacking";
        case LpeTechnique::PotatoAttack: return "Potato Attack";
        case LpeTechnique::PrintSpoofer: return "PrintSpoofer";
        case LpeTechnique::PipeRelayAttack: return "Pipe Relay";
        case LpeTechnique::KernelExploitLPE: return "Kernel Exploit";
        case LpeTechnique::JuicyPotato: return "JuicyPotato";
        case LpeTechnique::RoguePotato: return "RoguePotato";
        case LpeTechnique::SweetPotato: return "SweetPotato";
        case LpeTechnique::MockFolderBypass: return "Mock Folder Bypass";
        case LpeTechnique::FodhelperBypass: return "Fodhelper Bypass";
        case LpeTechnique::SilentCleanupBypass: return "SilentCleanup Bypass";
        case LpeTechnique::EventViewerBypass: return "Event Viewer Bypass";
        case LpeTechnique::ComputerDefaultsBypass: return "ComputerDefaults Bypass";
        default: return "Unknown";
    }
}

std::string GetLpeTechniqueMitreId(LpeTechnique technique) {
    switch (technique) {
        case LpeTechnique::TokenStealing:
        case LpeTechnique::TokenImpersonation:
            return "T1134";
        case LpeTechnique::UacBypassCOM:
        case LpeTechnique::UacBypassRegistry:
        case LpeTechnique::UacBypassEnvironment:
        case LpeTechnique::UacBypassDLL:
        case LpeTechnique::UacBypassAutoElevate:
        case LpeTechnique::FodhelperBypass:
        case LpeTechnique::EventViewerBypass:
        case LpeTechnique::ComputerDefaultsBypass:
            return "T1548.002";
        case LpeTechnique::ServiceBinPathAbuse:
        case LpeTechnique::WeakServicePermissions:
            return "T1543.003";
        case LpeTechnique::ScheduledTaskAbuse:
            return "T1053.005";
        case LpeTechnique::DLLSearchOrderHijack:
        case LpeTechnique::DLLPhantom:
        case LpeTechnique::DLLWinSxS:
            return "T1574.001";
        default:
            return "T1068";
    }
}

std::string_view GetIntegrityLevelName(IntegrityLevel level) noexcept {
    switch (level) {
        case IntegrityLevel::Untrusted: return "Untrusted";
        case IntegrityLevel::Low: return "Low";
        case IntegrityLevel::Medium: return "Medium";
        case IntegrityLevel::MediumPlus: return "Medium+";
        case IntegrityLevel::High: return "High";
        case IntegrityLevel::System: return "System";
        case IntegrityLevel::Protected: return "Protected";
        default: return "Unknown";
    }
}

std::string_view GetTokenChangeTypeName(TokenChangeType type) noexcept {
    switch (type) {
        case TokenChangeType::PrivilegeAdded: return "Privilege Added";
        case TokenChangeType::PrivilegeEnabled: return "Privilege Enabled";
        case TokenChangeType::IntegrityElevated: return "Integrity Elevated";
        case TokenChangeType::UserChanged: return "User Changed";
        case TokenChangeType::GroupAdded: return "Group Added";
        case TokenChangeType::PrimaryToken: return "Primary Token Replaced";
        case TokenChangeType::ImpersonationStart: return "Impersonation Started";
        case TokenChangeType::ImpersonationStop: return "Impersonation Stopped";
        default: return "None";
    }
}

std::string_view GetServiceVulnerabilityName(ServiceVulnerability vuln) noexcept {
    switch (vuln) {
        case ServiceVulnerability::UnquotedPath: return "Unquoted Path";
        case ServiceVulnerability::WeakDACL: return "Weak DACL";
        case ServiceVulnerability::WeakFilePermissions: return "Weak File Permissions";
        case ServiceVulnerability::WritableDirectory: return "Writable Directory";
        case ServiceVulnerability::DLLHijackable: return "DLL Hijackable";
        case ServiceVulnerability::ModifiableConfig: return "Modifiable Config";
        case ServiceVulnerability::InsecureDependency: return "Insecure Dependency";
        default: return "None";
    }
}

bool IsPrivilegedAccount(const std::wstring& userSid) {
    // Well-known privileged SIDs
    return userSid.find(L"S-1-5-18") == 0 ||  // SYSTEM
           userSid.find(L"S-1-5-19") == 0 ||  // LOCAL SERVICE
           userSid.find(L"S-1-5-20") == 0 ||  // NETWORK SERVICE
           userSid.find(L"-544") != std::wstring::npos;  // Administrators group
}

IntegrityLevel ParseIntegrityLevel(const std::wstring& integritySid) {
    auto it = INTEGRITY_SIDS.find(integritySid);
    if (it != INTEGRITY_SIDS.end()) {
        return it->second;
    }

    return IntegrityLevel::Unknown;
}

}  // namespace Exploits
}  // namespace ShadowStrike
