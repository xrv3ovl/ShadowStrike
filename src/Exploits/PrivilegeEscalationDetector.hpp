/**
 * ============================================================================
 * ShadowStrike NGAV - PRIVILEGE ESCALATION DETECTOR
 * ============================================================================
 *
 * @file PrivilegeEscalationDetector.hpp
 * @brief Enterprise-grade detection of local privilege escalation (LPE)
 *        attempts including token manipulation, UAC bypass, and service abuse.
 *
 * Monitors and detects various privilege escalation techniques used by
 * attackers to elevate from standard user to SYSTEM or Administrator.
 *
 * DETECTION CAPABILITIES:
 * =======================
 *
 * 1. TOKEN MANIPULATION
 *    - Token stealing (SeDebugPrivilege abuse)
 *    - Token duplication
 *    - Token impersonation
 *    - Primary token replacement
 *    - Privilege token insertion
 *
 * 2. UAC BYPASS TECHNIQUES
 *    - COM object elevation (eventvwr.msc, fodhelper.exe)
 *    - Auto-elevating executables abuse
 *    - Environment variable injection
 *    - DLL hijacking in elevated processes
 *    - Registry-based bypass (ms-settings, sdclt)
 *    - Mock folder bypass
 *    - SilentCleanup abuse
 *
 * 3. SERVICE EXPLOITATION
 *    - Unquoted service paths
 *    - Weak service permissions
 *    - DLL planting in service directories
 *    - Service binary replacement
 *    - Service configuration modification
 *    - Named pipe impersonation
 *
 * 4. SCHEDULED TASK ABUSE
 *    - Task creation with elevated privileges
 *    - Task modification
 *    - Task trigger manipulation
 *
 * 5. REGISTRY ABUSE
 *    - AlwaysInstallElevated
 *    - Image File Execution Options
 *    - App Paths hijacking
 *    - CLSID hijacking
 *
 * 6. DLL HIJACKING
 *    - Search order hijacking
 *    - Phantom DLL loading
 *    - Side-by-side (WinSxS) abuse
 *    - Known DLL redirection
 *
 * 7. POTATO ATTACKS
 *    - SeImpersonatePrivilege abuse
 *    - BITS, PrintSpoofer, etc.
 *    - Named pipe relay attacks
 *    - DCOM/RPC exploitation
 *
 * INTEGRATION:
 * ============
 * - Utils::ProcessUtils for process/token operations
 * - Utils::RegistryUtils for registry monitoring
 * - ThreatIntel for known bypass patterns
 *
 * @note Requires SeDebugPrivilege for some operations.
 * @note Works alongside Windows Defender Credential Guard.
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#pragma once

// ============================================================================
// STANDARD LIBRARY INCLUDES
// ============================================================================

#include <cstdint>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>
#include <array>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <optional>
#include <memory>
#include <functional>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <span>
#include <bitset>

// ============================================================================
// WINDOWS SDK INCLUDES
// ============================================================================

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// ============================================================================
// SHADOWSTRIKE INFRASTRUCTURE INCLUDES
// ============================================================================

#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/RegistryUtils.hpp"
#include "../ThreatIntel/ThreatIntelManager.hpp"
#include "../PatternStore/PatternStore.hpp"

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

namespace ShadowStrike::Exploits {
    class PrivilegeEscalationDetectorImpl;
}

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// COMPILE-TIME CONSTANTS
// ============================================================================

namespace PrivEscConstants {

    inline constexpr uint32_t VERSION_MAJOR = 3;
    inline constexpr uint32_t VERSION_MINOR = 0;
    inline constexpr uint32_t VERSION_PATCH = 0;

    /// @brief Maximum processes to monitor
    inline constexpr size_t MAX_MONITORED_PROCESSES = 4096;
    
    /// @brief Maximum events to cache
    inline constexpr size_t MAX_CACHED_EVENTS = 8192;
    
    /// @brief Token check interval (ms)
    inline constexpr uint32_t TOKEN_CHECK_INTERVAL_MS = 1000;
    
    /// @brief Common UAC bypass registry paths
    inline constexpr const wchar_t* UAC_BYPASS_PATHS[] = {
        L"Software\\Classes\\ms-settings\\Shell\\Open\\command",
        L"Software\\Classes\\mscfile\\shell\\open\\command",
        L"Software\\Classes\\exefile\\shell\\runas\\command",
        L"Software\\Classes\\Folder\\shell\\open\\command",
        L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths",
    };

}  // namespace PrivEscConstants

// ============================================================================
// TYPE ALIASES
// ============================================================================

using Clock = std::chrono::steady_clock;
using TimePoint = std::chrono::steady_clock::time_point;
using SystemTimePoint = std::chrono::system_clock::time_point;

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief Privilege escalation technique
 */
enum class LpeTechnique : uint32_t {
    Unknown                     = 0,
    TokenStealing               = 1 << 0,   ///< Token duplication/stealing
    TokenImpersonation          = 1 << 1,   ///< Named pipe impersonation
    UacBypassCOM                = 1 << 2,   ///< COM object UAC bypass
    UacBypassRegistry           = 1 << 3,   ///< Registry-based UAC bypass
    UacBypassEnvironment        = 1 << 4,   ///< Environment variable injection
    UacBypassDLL                = 1 << 5,   ///< DLL hijack UAC bypass
    UacBypassAutoElevate        = 1 << 6,   ///< Auto-elevate binary abuse
    ServiceBinPathAbuse         = 1 << 7,   ///< Modify service binary path
    ServiceDLLPlanting          = 1 << 8,   ///< DLL planting in services
    UnquotedServicePath         = 1 << 9,   ///< Unquoted path exploitation
    WeakServicePermissions      = 1 << 10,  ///< Weak DACL on service
    NamedPipeImpersonation      = 1 << 11,  ///< Named pipe relay
    ScheduledTaskAbuse          = 1 << 12,  ///< Task scheduler abuse
    RegistryAlwaysInstall       = 1 << 13,  ///< AlwaysInstallElevated
    RegistryIFEO                = 1 << 14,  ///< Image File Execution Options
    RegistryCLSID               = 1 << 15,  ///< CLSID hijacking
    DLLSearchOrderHijack        = 1 << 16,  ///< DLL search order hijacking
    DLLPhantom                  = 1 << 17,  ///< Phantom DLL loading
    DLLWinSxS                   = 1 << 18,  ///< WinSxS DLL hijacking
    PotatoAttack                = 1 << 19,  ///< Potato-family attacks
    PrintSpoofer                = 1 << 20,  ///< PrintSpoofer technique
    PipeRelayAttack             = 1 << 21,  ///< Pipe relay/NTLM relay
    KernelExploitLPE            = 1 << 22,  ///< Kernel-level LPE
    JuicyPotato                 = 1 << 23,  ///< JuicyPotato attack
    RoguePotato                 = 1 << 24,  ///< RoguePotato attack
    SweetPotato                 = 1 << 25,  ///< SweetPotato attack
    MockFolderBypass            = 1 << 26,  ///< Mock folder UAC bypass
    FodhelperBypass             = 1 << 27,  ///< fodhelper.exe bypass
    SilentCleanupBypass         = 1 << 28,  ///< SilentCleanup bypass
    EventViewerBypass           = 1 << 29,  ///< eventvwr.msc bypass
    ComputerDefaultsBypass      = 1 << 30   ///< computerdefaults.exe bypass
};

/**
 * @brief Token integrity level
 */
enum class IntegrityLevel : uint8_t {
    Unknown             = 0,
    Untrusted           = 1,
    Low                 = 2,
    Medium              = 3,
    MediumPlus          = 4,
    High                = 5,
    System              = 6,
    Protected           = 7
};

/**
 * @brief Token change type
 */
enum class TokenChangeType : uint8_t {
    None                = 0,
    PrivilegeAdded      = 1,    ///< New privilege enabled
    PrivilegeEnabled    = 2,    ///< Disabled privilege enabled
    IntegrityElevated   = 3,    ///< Integrity level increased
    UserChanged         = 4,    ///< User SID changed
    GroupAdded          = 5,    ///< New group added
    PrimaryToken        = 6,    ///< Primary token replaced
    ImpersonationStart  = 7,    ///< Started impersonating
    ImpersonationStop   = 8     ///< Stopped impersonating
};

/**
 * @brief Service vulnerability type
 */
enum class ServiceVulnerability : uint8_t {
    None                    = 0,
    UnquotedPath            = 1,
    WeakDACL                = 2,
    WeakFilePermissions     = 3,
    WritableDirectory       = 4,
    DLLHijackable           = 5,
    ModifiableConfig        = 6,
    InsecureDependency      = 7
};

/**
 * @brief Detection confidence
 */
enum class DetectionConfidence : uint8_t {
    Unknown     = 0,
    Low         = 1,
    Medium      = 2,
    High        = 3,
    VeryHigh    = 4,
    Confirmed   = 5
};

/**
 * @brief Module status
 */
enum class ModuleStatus : uint8_t {
    Uninitialized   = 0,
    Initializing    = 1,
    Running         = 2,
    Paused          = 3,
    Stopping        = 4,
    Stopped         = 5,
    Error           = 6
};

// ============================================================================
// STRUCTURES
// ============================================================================

/**
 * @brief Windows privilege information
 */
struct PrivilegeInfo {
    /// @brief Privilege name (e.g., "SeDebugPrivilege")
    std::wstring name;
    
    /// @brief LUID value
    uint64_t luid = 0;
    
    /// @brief Is currently enabled
    bool isEnabled = false;
    
    /// @brief Is enabled by default
    bool isEnabledByDefault = false;
    
    /// @brief Is removed
    bool isRemoved = false;
    
    /// @brief Is used for impersonation
    bool usedForImpersonation = false;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Token information
 */
struct TokenInfo {
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Thread ID (for impersonation tokens)
    uint32_t threadId = 0;
    
    /// @brief Token handle
    uint64_t tokenHandle = 0;
    
    /// @brief Is primary token (vs impersonation)
    bool isPrimaryToken = true;
    
    /// @brief User SID string
    std::wstring userSid;
    
    /// @brief User name (DOMAIN\User)
    std::wstring userName;
    
    /// @brief Logon session ID
    uint64_t logonId = 0;
    
    /// @brief Token type
    uint32_t tokenType = 0;
    
    /// @brief Impersonation level
    uint32_t impersonationLevel = 0;
    
    /// @brief Integrity level
    IntegrityLevel integrityLevel = IntegrityLevel::Unknown;
    
    /// @brief Integrity level SID
    std::wstring integritySid;
    
    /// @brief Is elevated
    bool isElevated = false;
    
    /// @brief Is restricted
    bool isRestricted = false;
    
    /// @brief Is sandboxed
    bool isSandboxed = false;
    
    /// @brief Is AppContainer
    bool isAppContainer = false;
    
    /// @brief Session ID
    uint32_t sessionId = 0;
    
    /// @brief Token source
    std::string tokenSource;
    
    /// @brief Group SIDs
    std::vector<std::wstring> groupSids;
    
    /// @brief Privileges
    std::vector<PrivilegeInfo> privileges;
    
    /// @brief Enabled privilege count
    uint32_t enabledPrivilegeCount = 0;
    
    /// @brief Has SeDebugPrivilege
    bool hasSeDebugPrivilege = false;
    
    /// @brief Has SeImpersonatePrivilege
    bool hasSeImpersonatePrivilege = false;
    
    /// @brief Has SeTcbPrivilege
    bool hasSeTcbPrivilege = false;
    
    /// @brief Snapshot time
    SystemTimePoint snapshotTime;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Token change event
 */
struct TokenChangeInfo {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief Thread ID
    uint32_t threadId = 0;
    
    /// @brief Change type
    TokenChangeType changeType = TokenChangeType::None;
    
    /// @brief Original user
    std::wstring originalUser;
    
    /// @brief New user (if changed)
    std::wstring newUser;
    
    /// @brief Original integrity
    IntegrityLevel originalIntegrity = IntegrityLevel::Unknown;
    
    /// @brief New integrity
    IntegrityLevel newIntegrity = IntegrityLevel::Unknown;
    
    /// @brief Is elevation
    bool isElevation = false;
    
    /// @brief Added privileges
    std::vector<std::wstring> addedPrivileges;
    
    /// @brief Enabled privileges
    std::vector<std::wstring> enabledPrivileges;
    
    /// @brief Source process (for token stealing)
    uint32_t sourceProcessId = 0;
    
    /// @brief Source process name
    std::wstring sourceProcessName;
    
    /// @brief Token before change
    std::optional<TokenInfo> tokenBefore;
    
    /// @brief Token after change
    std::optional<TokenInfo> tokenAfter;
    
    /// @brief Suspicion score (0-100)
    double suspicionScore = 0.0;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Service security info
 */
struct ServiceSecurityInfo {
    /// @brief Service name
    std::wstring serviceName;
    
    /// @brief Display name
    std::wstring displayName;
    
    /// @brief Binary path
    std::wstring binaryPath;
    
    /// @brief Start type
    uint32_t startType = 0;
    
    /// @brief Service type
    uint32_t serviceType = 0;
    
    /// @brief Current state
    uint32_t currentState = 0;
    
    /// @brief Runs as account
    std::wstring runAsAccount;
    
    /// @brief Has unquoted path
    bool hasUnquotedPath = false;
    
    /// @brief Is path writable by non-admin
    bool isPathWritable = false;
    
    /// @brief Is service config modifiable
    bool isConfigModifiable = false;
    
    /// @brief Is vulnerable to DLL hijacking
    bool isDLLHijackable = false;
    
    /// @brief Vulnerability type
    ServiceVulnerability vulnerability = ServiceVulnerability::None;
    
    /// @brief Dependencies
    std::vector<std::wstring> dependencies;
    
    /// @brief Vulnerable dependency paths
    std::vector<std::wstring> vulnerablePaths;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Privilege escalation event
 */
struct LpeEvent {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief Process command line
    std::wstring commandLine;
    
    /// @brief Parent process ID
    uint32_t parentProcessId = 0;
    
    /// @brief Parent process name
    std::wstring parentProcessName;
    
    /// @brief Technique detected
    LpeTechnique technique = LpeTechnique::Unknown;
    
    /// @brief Technique name
    std::string techniqueName;
    
    /// @brief MITRE ATT&CK ID
    std::string mitreAttackId;
    
    /// @brief Token change (if applicable)
    std::optional<TokenChangeInfo> tokenChange;
    
    /// @brief Service info (if service-related)
    std::optional<ServiceSecurityInfo> serviceInfo;
    
    /// @brief Target registry key (if registry-related)
    std::wstring targetRegistryKey;
    
    /// @brief Target file path (if file-related)
    std::wstring targetFilePath;
    
    /// @brief Payload/data involved
    std::vector<uint8_t> payload;
    
    /// @brief Confidence
    DetectionConfidence confidence = DetectionConfidence::Unknown;
    
    /// @brief Confidence score (0-100)
    double confidenceScore = 0.0;
    
    /// @brief Was blocked
    bool wasBlocked = false;
    
    /// @brief Process was terminated
    bool processTerminated = false;
    
    /// @brief Additional details
    std::string details;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Statistics
 */
struct PrivEscStatistics {
    std::atomic<uint64_t> processesMonitored{0};
    std::atomic<uint64_t> tokenChangesDetected{0};
    std::atomic<uint64_t> uacBypassesDetected{0};
    std::atomic<uint64_t> serviceAbusesDetected{0};
    std::atomic<uint64_t> dllHijacksDetected{0};
    std::atomic<uint64_t> registryAbusesDetected{0};
    std::atomic<uint64_t> potatoAttacksDetected{0};
    std::atomic<uint64_t> escalationsBlocked{0};
    std::atomic<uint64_t> processesTerminated{0};
    std::array<std::atomic<uint64_t>, 32> byTechnique{};
    TimePoint startTime = Clock::now();
    
    void Reset() noexcept;
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Configuration
 */
struct PrivilegeEscalationDetectorConfiguration {
    /// @brief Enable token monitoring
    bool monitorTokenChanges = true;
    
    /// @brief Enable UAC bypass monitoring
    bool monitorUACBypass = true;
    
    /// @brief Enable service monitoring
    bool monitorServiceConfig = true;
    
    /// @brief Enable registry monitoring
    bool monitorRegistry = true;
    
    /// @brief Enable DLL hijack detection
    bool detectDLLHijacking = true;
    
    /// @brief Block detected escalations
    bool blockOnDetection = true;
    
    /// @brief Terminate process on high-confidence detection
    bool terminateOnHighConfidence = false;
    
    /// @brief Token check interval (ms)
    uint32_t tokenCheckIntervalMs = PrivEscConstants::TOKEN_CHECK_INTERVAL_MS;
    
    /// @brief Additional UAC bypass paths to monitor
    std::vector<std::wstring> additionalUacPaths;
    
    /// @brief Whitelisted processes
    std::vector<std::wstring> whitelistedProcesses;
    
    /// @brief Verbose logging
    bool verboseLogging = false;
    
    [[nodiscard]] bool IsValid() const noexcept;
};

// ============================================================================
// CALLBACK TYPES
// ============================================================================

using LpeDetectedCallback = std::function<void(const LpeEvent&)>;
using TokenChangeCallback = std::function<void(const TokenChangeInfo&)>;
using ServiceVulnerabilityCallback = std::function<void(const ServiceSecurityInfo&)>;
using ErrorCallback = std::function<void(const std::string& message, int code)>;

// ============================================================================
// PRIVILEGE ESCALATION DETECTOR CLASS
// ============================================================================

/**
 * @class PrivilegeEscalationDetector
 * @brief Enterprise-grade local privilege escalation detection
 */
class PrivilegeEscalationDetector final {
public:
    [[nodiscard]] static PrivilegeEscalationDetector& Instance() noexcept;
    [[nodiscard]] static bool HasInstance() noexcept;
    
    PrivilegeEscalationDetector(const PrivilegeEscalationDetector&) = delete;
    PrivilegeEscalationDetector& operator=(const PrivilegeEscalationDetector&) = delete;
    PrivilegeEscalationDetector(PrivilegeEscalationDetector&&) = delete;
    PrivilegeEscalationDetector& operator=(PrivilegeEscalationDetector&&) = delete;

    // ========================================================================
    // LIFECYCLE
    // ========================================================================
    
    [[nodiscard]] bool Initialize(const PrivilegeEscalationDetectorConfiguration& config = {});
    void Shutdown();
    [[nodiscard]] bool IsInitialized() const noexcept;
    [[nodiscard]] ModuleStatus GetStatus() const noexcept;
    
    [[nodiscard]] bool Start();
    [[nodiscard]] bool Stop();
    void Pause();
    void Resume();
    
    [[nodiscard]] bool UpdateConfiguration(const PrivilegeEscalationDetectorConfiguration& config);
    [[nodiscard]] PrivilegeEscalationDetectorConfiguration GetConfiguration() const;

    // ========================================================================
    // TOKEN ANALYSIS
    // ========================================================================
    
    /// @brief Get token info for process
    [[nodiscard]] TokenInfo GetProcessToken(uint32_t processId);
    
    /// @brief Analyze token for anomalies
    [[nodiscard]] bool AnalyzeTokenIntegrity(uint32_t processId);
    
    /// @brief Check for token manipulation
    [[nodiscard]] std::optional<TokenChangeInfo> DetectTokenManipulation(uint32_t processId);
    
    /// @brief Get token history for process
    [[nodiscard]] std::vector<TokenChangeInfo> GetTokenHistory(
        uint32_t processId, 
        size_t maxEntries = 100) const;

    // ========================================================================
    // UAC BYPASS DETECTION
    // ========================================================================
    
    /// @brief Monitor UAC bypass registry points
    void MonitorUacBypassPoints();
    
    /// @brief Check for active UAC bypasses
    [[nodiscard]] std::vector<LpeEvent> DetectUACBypasses();
    
    /// @brief Check specific UAC bypass technique
    [[nodiscard]] bool CheckUACBypassTechnique(LpeTechnique technique);

    // ========================================================================
    // SERVICE ANALYSIS
    // ========================================================================
    
    /// @brief Scan all services for vulnerabilities
    [[nodiscard]] std::vector<ServiceSecurityInfo> ScanServices();
    
    /// @brief Get vulnerable services
    [[nodiscard]] std::vector<ServiceSecurityInfo> GetVulnerableServices();
    
    /// @brief Check specific service
    [[nodiscard]] ServiceSecurityInfo AnalyzeService(const std::wstring& serviceName);
    
    /// @brief Find unquoted service paths
    [[nodiscard]] std::vector<ServiceSecurityInfo> FindUnquotedPaths();
    
    /// @brief Find weak service permissions
    [[nodiscard]] std::vector<ServiceSecurityInfo> FindWeakPermissions();

    // ========================================================================
    // DLL HIJACK ANALYSIS
    // ========================================================================
    
    /// @brief Scan process for DLL hijacking potential
    [[nodiscard]] std::vector<std::wstring> ScanDLLHijackPaths(uint32_t processId);
    
    /// @brief Check if path is vulnerable to DLL hijacking
    [[nodiscard]] bool IsDLLHijackVulnerable(const std::wstring& path);

    // ========================================================================
    // REGISTRY ANALYSIS
    // ========================================================================
    
    /// @brief Check AlwaysInstallElevated setting
    [[nodiscard]] bool IsAlwaysInstallElevatedEnabled();
    
    /// @brief Get IFEO debuggers
    [[nodiscard]] std::vector<std::pair<std::wstring, std::wstring>> GetIFEODebuggers();

    // ========================================================================
    // MONITORING
    // ========================================================================
    
    /// @brief Start monitoring process
    [[nodiscard]] bool MonitorProcess(uint32_t processId);
    
    /// @brief Stop monitoring process
    [[nodiscard]] bool StopMonitoring(uint32_t processId);
    
    /// @brief Check if process is monitored
    [[nodiscard]] bool IsMonitoring(uint32_t processId) const;
    
    /// @brief Get monitored processes
    [[nodiscard]] std::vector<uint32_t> GetMonitoredProcesses() const;

    // ========================================================================
    // CALLBACKS
    // ========================================================================
    
    void RegisterLpeCallback(LpeDetectedCallback callback);
    void RegisterTokenChangeCallback(TokenChangeCallback callback);
    void RegisterServiceVulnerabilityCallback(ServiceVulnerabilityCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // ========================================================================
    // STATISTICS
    // ========================================================================
    
    [[nodiscard]] PrivEscStatistics GetStatistics() const;
    void ResetStatistics();
    [[nodiscard]] std::vector<LpeEvent> GetRecentDetections(size_t maxCount = 100) const;
    
    [[nodiscard]] bool SelfTest();
    [[nodiscard]] static std::string GetVersionString() noexcept;

private:
    PrivilegeEscalationDetector();
    ~PrivilegeEscalationDetector();
    
    std::unique_ptr<PrivilegeEscalationDetectorImpl> m_impl;
    static std::atomic<bool> s_instanceCreated;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

[[nodiscard]] std::string_view GetLpeTechniqueName(LpeTechnique technique) noexcept;
[[nodiscard]] std::string GetLpeTechniqueMitreId(LpeTechnique technique);
[[nodiscard]] std::string_view GetIntegrityLevelName(IntegrityLevel level) noexcept;
[[nodiscard]] std::string_view GetTokenChangeTypeName(TokenChangeType type) noexcept;
[[nodiscard]] std::string_view GetServiceVulnerabilityName(ServiceVulnerability vuln) noexcept;
[[nodiscard]] bool IsPrivilegedAccount(const std::wstring& userSid);
[[nodiscard]] IntegrityLevel ParseIntegrityLevel(const std::wstring& integritySid);

}  // namespace Exploits
}  // namespace ShadowStrike

// ============================================================================
// MACROS
// ============================================================================

#define SS_GET_PROCESS_TOKEN(pid) \
    ::ShadowStrike::Exploits::PrivilegeEscalationDetector::Instance().GetProcessToken(pid)

#define SS_SCAN_VULNERABLE_SERVICES() \
    ::ShadowStrike::Exploits::PrivilegeEscalationDetector::Instance().GetVulnerableServices()

#define SS_DETECT_UAC_BYPASS() \
    ::ShadowStrike::Exploits::PrivilegeEscalationDetector::Instance().DetectUACBypasses()