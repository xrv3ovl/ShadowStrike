/*
 * ShadowStrike - Enterprise NGAV/EDR Platform
 * Copyright (C) 2026 ShadowStrike Security
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
/**
 * ============================================================================
 * ShadowStrike NGAV - STACK PIVOT DETECTOR
 * ============================================================================
 *
 * @file StackPivotDetector.hpp
 * @brief Enterprise-grade detection of stack pivoting attacks where the
 *        stack pointer is redirected to attacker-controlled memory.
 *
 * Monitors and validates stack pointer integrity to detect when RSP/ESP
 * is moved to heap, data sections, or other non-stack memory regions.
 *
 * DETECTION CAPABILITIES:
 * =======================
 *
 * 1. STACK POINTER VALIDATION
 *    - TEB stack limits checking
 *    - RSP/ESP bounds validation
 *    - Stack growth direction analysis
 *    - Guard page monitoring
 *
 * 2. PIVOT DESTINATION ANALYSIS
 *    - Heap pivot detection
 *    - Data section pivot
 *    - Image section pivot
 *    - Mapped memory pivot
 *    - Allocated memory pivot
 *
 * 3. PIVOT TECHNIQUE DETECTION
 *    - XCHG ESP,EAX gadgets
 *    - MOV ESP,reg gadgets
 *    - POP ESP gadgets
 *    - LEAVE instruction abuse
 *    - Stack pointer arithmetic
 *
 * 4. THREAD MONITORING
 *    - Per-thread stack tracking
 *    - Stack limit caching
 *    - Stack usage analysis
 *    - Thread creation monitoring
 *
 * 5. CONTEXT SWITCH MONITORING
 *    - Exception context validation
 *    - System call boundary checks
 *    - Callback validation
 *
 * 6. FORENSIC CAPABILITIES
 *    - Pivot reconstruction
 *    - Memory region analysis
 *    - Attack attribution
 *
 * INTEGRATION:
 * ============
 * - ROPProtection for comprehensive exploit mitigation
 * - Utils::MemoryUtils for memory region analysis
 * - Utils::ProcessUtils for thread enumeration
 *
 * @note Works with ROPProtection for complete protection.
 * @note Requires thread monitoring capability.
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#pragma once

// ============================================================================
// STANDARD LIBRARY INCLUDES
// ============================================================================

#include <cstdint>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>
#include <array>
#include <map>
#include <unordered_map>
#include <optional>
#include <memory>
#include <functional>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <span>

// ============================================================================
// WINDOWS SDK INCLUDES
// ============================================================================

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// ============================================================================
// SHADOWSTRIKE INFRASTRUCTURE INCLUDES
// ============================================================================

#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/MemoryUtils.hpp"

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

namespace ShadowStrike::Exploits {
    class StackPivotDetectorImpl;
}

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// COMPILE-TIME CONSTANTS
// ============================================================================

namespace StackPivotConstants {

    inline constexpr uint32_t VERSION_MAJOR = 3;
    inline constexpr uint32_t VERSION_MINOR = 0;
    inline constexpr uint32_t VERSION_PATCH = 0;

    /// @brief Maximum threads to track per process
    inline constexpr size_t MAX_TRACKED_THREADS = 4096;
    
    /// @brief Maximum processes to monitor
    inline constexpr size_t MAX_MONITORED_PROCESSES = 2048;
    
    /// @brief Stack validation interval (ms)
    inline constexpr uint32_t VALIDATION_INTERVAL_MS = 100;
    
    /// @brief Default stack size (1 MB)
    inline constexpr size_t DEFAULT_STACK_SIZE = 1024 * 1024;
    
    /// @brief Stack guard page size
    inline constexpr size_t GUARD_PAGE_SIZE = 4096;
    
    /// @brief Minimum valid stack size
    inline constexpr size_t MIN_STACK_SIZE = 4096;

}  // namespace StackPivotConstants

// ============================================================================
// TYPE ALIASES
// ============================================================================

using Clock = std::chrono::steady_clock;
using TimePoint = std::chrono::steady_clock::time_point;
using SystemTimePoint = std::chrono::system_clock::time_point;

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief Memory region type for pivot destination
 */
enum class PivotDestinationType : uint8_t {
    Unknown             = 0,
    ValidStack          = 1,    ///< Valid thread stack (no pivot)
    Heap                = 2,    ///< Process heap
    ImageSection        = 3,    ///< PE image section
    DataSection         = 4,    ///< Data/BSS section
    MappedFile          = 5,    ///< Memory-mapped file
    PrivateMemory       = 6,    ///< VirtualAlloc'd memory
    SharedMemory        = 7,    ///< Shared section
    GuardPage           = 8,    ///< Guard page (about to grow stack)
    ReservedMemory      = 9,    ///< Reserved but not committed
    FreeMemory          = 10,   ///< Free address space
    OtherThreadStack    = 11,   ///< Another thread's stack
    KernelStack         = 12    ///< Kernel address (invalid in user mode)
};

/**
 * @brief Pivot technique type
 */
enum class PivotTechnique : uint8_t {
    Unknown             = 0,
    XchgEspEax          = 1,    ///< XCHG ESP,EAX
    XchgRspRax          = 2,    ///< XCHG RSP,RAX
    MovEspReg           = 3,    ///< MOV ESP,reg
    MovRspReg           = 4,    ///< MOV RSP,reg
    PopEsp              = 5,    ///< POP ESP
    PopRsp              = 6,    ///< POP RSP
    LeaveRet            = 7,    ///< LEAVE; RET sequence
    AddEspImm           = 8,    ///< Large ADD ESP,imm
    SubEspImm           = 9,    ///< Suspicious SUB ESP,imm (negative)
    PushSpRet           = 10,   ///< PUSH ESP; RET (to new stack)
    CallStackPivot      = 11,   ///< CALL to stack pivot gadget
    LongjmpAbuse        = 12,   ///< setjmp/longjmp abuse
    ExceptionDispatch   = 13,   ///< Exception handler manipulation
    FiberSwitch         = 14    ///< Fiber context manipulation
};

/**
 * @brief Stack validation result
 */
enum class StackValidationResult : uint8_t {
    Unknown         = 0,
    Valid           = 1,    ///< Stack pointer is valid
    PivotDetected   = 2,    ///< Stack pivot detected
    NearGuardPage   = 3,    ///< Near guard page (stack growth)
    Overflow        = 4,    ///< Stack overflow detected
    Underflow       = 5,    ///< Below stack base (suspicious)
    InvalidBounds   = 6     ///< Cannot determine bounds
};

/**
 * @brief Detection confidence
 */
enum class DetectionConfidence : uint8_t {
    Unknown     = 0,
    Low         = 1,
    Medium      = 2,
    High        = 3,
    VeryHigh    = 4,
    Confirmed   = 5
};

/**
 * @brief Module status
 */
enum class ModuleStatus : uint8_t {
    Uninitialized   = 0,
    Initializing    = 1,
    Running         = 2,
    Paused          = 3,
    Stopping        = 4,
    Stopped         = 5,
    Error           = 6
};

// ============================================================================
// STRUCTURES
// ============================================================================

/**
 * @brief Thread stack range information
 */
struct StackRange {
    /// @brief Thread ID
    uint32_t threadId = 0;
    
    /// @brief Stack base (high address, bottom of stack)
    uint64_t stackBase = 0;
    
    /// @brief Stack limit (low address, top of stack growth)
    uint64_t stackLimit = 0;
    
    /// @brief Stack allocation base
    uint64_t allocationBase = 0;
    
    /// @brief Total stack size
    size_t stackSize = 0;
    
    /// @brief Committed stack size
    size_t committedSize = 0;
    
    /// @brief Reserved stack size
    size_t reservedSize = 0;
    
    /// @brief Guard page address
    uint64_t guardPage = 0;
    
    /// @brief Has guard page
    bool hasGuardPage = true;
    
    /// @brief Is main thread stack
    bool isMainThread = false;
    
    /// @brief Last updated
    SystemTimePoint lastUpdated;
    
    /**
     * @brief Check if address is within stack bounds
     */
    [[nodiscard]] bool ContainsAddress(uint64_t address) const noexcept {
        return address >= stackLimit && address <= stackBase;
    }
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Memory region information
 */
struct MemoryRegionInfo {
    /// @brief Base address
    uint64_t baseAddress = 0;
    
    /// @brief Region size
    size_t regionSize = 0;
    
    /// @brief Allocation base
    uint64_t allocationBase = 0;
    
    /// @brief Region type
    PivotDestinationType regionType = PivotDestinationType::Unknown;
    
    /// @brief Memory state (MEM_COMMIT, etc.)
    uint32_t state = 0;
    
    /// @brief Memory protection
    uint32_t protection = 0;
    
    /// @brief Memory type (MEM_PRIVATE, etc.)
    uint32_t type = 0;
    
    /// @brief Is executable
    bool isExecutable = false;
    
    /// @brief Is writable
    bool isWritable = false;
    
    /// @brief Module name (if image)
    std::wstring moduleName;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Stack pivot event
 */
struct PivotEvent {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Thread ID
    uint32_t threadId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief Original stack base
    uint64_t originalStackBase = 0;
    
    /// @brief Original stack limit
    uint64_t originalStackLimit = 0;
    
    /// @brief New stack pointer value
    uint64_t newStackPointer = 0;
    
    /// @brief Pivot destination type
    PivotDestinationType destinationType = PivotDestinationType::Unknown;
    
    /// @brief Pivot destination region info
    MemoryRegionInfo destinationRegion;
    
    /// @brief Pivot technique (if identified)
    PivotTechnique technique = PivotTechnique::Unknown;
    
    /// @brief Pivot gadget address (if identified)
    uint64_t pivotGadgetAddress = 0;
    
    /// @brief Pivot gadget bytes
    std::vector<uint8_t> pivotGadgetBytes;
    
    /// @brief Pivot gadget disassembly
    std::string pivotGadgetDisasm;
    
    /// @brief Instruction pointer at detection
    uint64_t instructionPointer = 0;
    
    /// @brief Stack contents at new location
    std::vector<uint8_t> newStackContents;
    
    /// @brief Confidence
    DetectionConfidence confidence = DetectionConfidence::Unknown;
    
    /// @brief Confidence score (0-100)
    double confidenceScore = 0.0;
    
    /// @brief Was blocked
    bool wasBlocked = false;
    
    /// @brief Process was terminated
    bool processTerminated = false;
    
    /// @brief Additional details
    std::string details;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Statistics
 */
struct StackPivotStatistics {
    std::atomic<uint64_t> checksPerformed{0};
    std::atomic<uint64_t> threadsMonitored{0};
    std::atomic<uint64_t> pivotsDetected{0};
    std::atomic<uint64_t> heapPivots{0};
    std::atomic<uint64_t> dataPivots{0};
    std::atomic<uint64_t> imagePivots{0};
    std::atomic<uint64_t> attacksBlocked{0};
    std::atomic<uint64_t> processesTerminated{0};
    std::array<std::atomic<uint64_t>, 16> byTechnique{};
    TimePoint startTime = Clock::now();
    
    void Reset() noexcept;
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Configuration
 */
struct StackPivotDetectorConfiguration {
    /// @brief Enable strict mode (block immediately)
    bool strictMode = true;
    
    /// @brief Enable periodic validation
    bool enablePeriodicValidation = true;
    
    /// @brief Validation interval (ms)
    uint32_t validationIntervalMs = StackPivotConstants::VALIDATION_INTERVAL_MS;
    
    /// @brief Enable API boundary checks
    bool enableApiBoundaryChecks = true;
    
    /// @brief Enable exception context validation
    bool enableExceptionValidation = true;
    
    /// @brief Block on detected pivot
    bool blockOnPivot = true;
    
    /// @brief Terminate process on confirmed pivot
    bool terminateOnPivot = true;
    
    /// @brief Monitor thread creation
    bool monitorThreadCreation = true;
    
    /// @brief Excluded processes
    std::vector<std::wstring> excludedProcesses;
    
    /// @brief Verbose logging
    bool verboseLogging = false;
    
    [[nodiscard]] bool IsValid() const noexcept;
};

// ============================================================================
// CALLBACK TYPES
// ============================================================================

using PivotDetectedCallback = std::function<void(const PivotEvent&)>;
using StackValidationCallback = std::function<void(uint32_t threadId, StackValidationResult)>;
using ErrorCallback = std::function<void(const std::string& message, int code)>;

// ============================================================================
// STACK PIVOT DETECTOR CLASS
// ============================================================================

/**
 * @class StackPivotDetector
 * @brief Enterprise-grade stack pivot attack detection
 */
class StackPivotDetector final {
public:
    [[nodiscard]] static StackPivotDetector& Instance() noexcept;
    [[nodiscard]] static bool HasInstance() noexcept;
    
    StackPivotDetector(const StackPivotDetector&) = delete;
    StackPivotDetector& operator=(const StackPivotDetector&) = delete;
    StackPivotDetector(StackPivotDetector&&) = delete;
    StackPivotDetector& operator=(StackPivotDetector&&) = delete;

    // ========================================================================
    // LIFECYCLE
    // ========================================================================
    
    [[nodiscard]] bool Initialize(const StackPivotDetectorConfiguration& config = {});
    void Shutdown();
    [[nodiscard]] bool IsInitialized() const noexcept;
    [[nodiscard]] ModuleStatus GetStatus() const noexcept;
    
    [[nodiscard]] bool Start();
    [[nodiscard]] bool Stop();
    void Pause();
    void Resume();
    
    [[nodiscard]] bool UpdateConfiguration(const StackPivotDetectorConfiguration& config);
    [[nodiscard]] StackPivotDetectorConfiguration GetConfiguration() const;

    // ========================================================================
    // STACK VALIDATION
    // ========================================================================
    
    /// @brief Validate stack pointer for thread
    [[nodiscard]] StackValidationResult ValidateStackPointer(
        uint32_t processId,
        uint32_t threadId,
        uint64_t stackPointer);
    
    /// @brief Validate stack pointer against known limits
    [[nodiscard]] StackValidationResult ValidateStackPointer(
        uint64_t stackPointer,
        const StackRange& limits);
    
    /// @brief Quick check if address is on any known stack
    [[nodiscard]] bool IsOnValidStack(
        uint32_t processId,
        uint64_t address) const;
    
    /// @brief Detect pivot in current thread context
    [[nodiscard]] std::optional<PivotEvent> DetectPivot(
        uint32_t processId,
        uint32_t threadId,
        uint64_t currentRsp,
        uint64_t currentRip = 0);

    // ========================================================================
    // STACK TRACKING
    // ========================================================================
    
    /// @brief Get stack limits for thread
    [[nodiscard]] std::optional<StackRange> GetStackLimits(
        uint32_t processId,
        uint32_t threadId) const;
    
    /// @brief Refresh stack limits for process
    void RefreshStackLimits(uint32_t processId);
    
    /// @brief Refresh stack limits for specific thread
    void RefreshStackLimits(uint32_t processId, uint32_t threadId);
    
    /// @brief Get all stack ranges for process
    [[nodiscard]] std::vector<StackRange> GetProcessStackRanges(
        uint32_t processId) const;
    
    /// @brief Cache stack limits for new thread
    void RegisterThread(uint32_t processId, uint32_t threadId);
    
    /// @brief Remove cached limits for terminated thread
    void UnregisterThread(uint32_t processId, uint32_t threadId);

    // ========================================================================
    // MEMORY ANALYSIS
    // ========================================================================
    
    /// @brief Get memory region type
    [[nodiscard]] PivotDestinationType GetRegionType(
        uint32_t processId,
        uint64_t address);
    
    /// @brief Get detailed memory region info
    [[nodiscard]] MemoryRegionInfo GetMemoryRegionInfo(
        uint32_t processId,
        uint64_t address);
    
    /// @brief Check if address is in heap
    [[nodiscard]] bool IsHeapAddress(uint32_t processId, uint64_t address);
    
    /// @brief Check if address is in image section
    [[nodiscard]] bool IsImageAddress(uint32_t processId, uint64_t address);

    // ========================================================================
    // PROCESS MONITORING
    // ========================================================================
    
    /// @brief Start monitoring process
    [[nodiscard]] bool MonitorProcess(uint32_t processId);
    
    /// @brief Stop monitoring process
    void StopMonitoring(uint32_t processId);
    
    /// @brief Check if process is monitored
    [[nodiscard]] bool IsMonitoring(uint32_t processId) const;
    
    /// @brief Get monitored processes
    [[nodiscard]] std::vector<uint32_t> GetMonitoredProcesses() const;

    // ========================================================================
    // CALLBACKS
    // ========================================================================
    
    void RegisterPivotCallback(PivotDetectedCallback callback);
    void RegisterValidationCallback(StackValidationCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // ========================================================================
    // STATISTICS
    // ========================================================================
    
    [[nodiscard]] StackPivotStatistics GetStatistics() const;
    void ResetStatistics();
    [[nodiscard]] std::vector<PivotEvent> GetRecentDetections(size_t maxCount = 100) const;
    
    [[nodiscard]] bool SelfTest();
    [[nodiscard]] static std::string GetVersionString() noexcept;

private:
    StackPivotDetector();
    ~StackPivotDetector();
    
    std::unique_ptr<StackPivotDetectorImpl> m_impl;
    static std::atomic<bool> s_instanceCreated;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

[[nodiscard]] std::string_view GetPivotDestinationTypeName(PivotDestinationType type) noexcept;
[[nodiscard]] std::string_view GetPivotTechniqueName(PivotTechnique technique) noexcept;
[[nodiscard]] std::string_view GetStackValidationResultName(StackValidationResult result) noexcept;
[[nodiscard]] bool IsStackPivotGadget(std::span<const uint8_t> bytes) noexcept;
[[nodiscard]] PivotTechnique IdentifyPivotTechnique(std::span<const uint8_t> gadgetBytes);

}  // namespace Exploits
}  // namespace ShadowStrike

// ============================================================================
// MACROS
// ============================================================================

#define SS_VALIDATE_STACK(pid, tid, rsp) \
    ::ShadowStrike::Exploits::StackPivotDetector::Instance().ValidateStackPointer(pid, tid, rsp)

#define SS_IS_VALID_STACK(pid, addr) \
    ::ShadowStrike::Exploits::StackPivotDetector::Instance().IsOnValidStack(pid, addr)

#define SS_DETECT_PIVOT(pid, tid, rsp) \
    ::ShadowStrike::Exploits::StackPivotDetector::Instance().DetectPivot(pid, tid, rsp)