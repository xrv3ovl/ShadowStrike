/**
 * ============================================================================
 * ShadowStrike NGAV - KERNEL EXPLOIT DETECTOR
 * ============================================================================
 *
 * @file KernelExploitDetector.hpp
 * @brief Enterprise-grade detection of kernel-level exploitation attempts
 *        and vulnerable driver abuse (BYOVD - Bring Your Own Vulnerable Driver).
 *
 * Provides user-mode visibility into kernel-level threats through driver
 * load monitoring, DeviceIoControl abuse detection, and KASLR bypass attempts.
 *
 * DETECTION CAPABILITIES:
 * =======================
 *
 * 1. VULNERABLE DRIVER DETECTION (BYOVD)
 *    - LOLDrivers database integration
 *    - Microsoft block list
 *    - Hash-based driver identification
 *    - Known vulnerable driver signatures
 *    - Custom driver blacklist
 *
 * 2. DRIVER LOAD MONITORING
 *    - All driver load events
 *    - Unsigned driver detection
 *    - Certificate validation
 *    - Code signing verification
 *    - Timestamp validation
 *
 * 3. IOCTL ABUSE DETECTION
 *    - Suspicious DeviceIoControl patterns
 *    - Known exploit IOCTLs
 *    - Memory read/write IOCTLs
 *    - Kernel address disclosure
 *
 * 4. KASLR BYPASS DETECTION
 *    - Kernel address leaks
 *    - NtQuerySystemInformation abuse
 *    - EnumDeviceDrivers abuse
 *    - Pool tag scanning
 *
 * 5. KERNEL MEMORY ATTACKS
 *    - Token stealing payloads
 *    - NULL pointer dereference
 *    - Pool corruption attempts
 *    - Type confusion exploits
 *
 * 6. ROOTKIT INDICATORS
 *    - Hidden driver detection
 *    - DKOM (Direct Kernel Object Manipulation)
 *    - SSDT hooking attempts
 *    - Callback tampering
 *
 * 7. BSOD ANALYSIS
 *    - Crash dump correlation
 *    - Exploit crash patterns
 *    - Bug check analysis
 *
 * INTEGRATION:
 * ============
 * - ThreatIntel for driver blacklists
 * - HashStore for driver hash verification
 * - Utils::ProcessUtils for process context
 *
 * @note User-mode has limited kernel visibility.
 * @note Full protection requires companion kernel driver.
 *
 * @author ShadowStrike Security Team
 * @version 3.0.0
 * @date 2026
 * @copyright (c) 2026 ShadowStrike Security. All rights reserved.
 *
 * LICENSE: Proprietary - ShadowStrike Enterprise License
 * ============================================================================
 */

#pragma once

// ============================================================================
// STANDARD LIBRARY INCLUDES
// ============================================================================

#include <cstdint>
#include <cstddef>
#include <string>
#include <string_view>
#include <vector>
#include <array>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <set>
#include <optional>
#include <memory>
#include <functional>
#include <chrono>
#include <atomic>
#include <mutex>
#include <shared_mutex>
#include <span>
#include <filesystem>

// ============================================================================
// WINDOWS SDK INCLUDES
// ============================================================================

#ifdef _WIN32
#  ifndef NOMINMAX
#    define NOMINMAX
#  endif
#  ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#  endif
#  include <Windows.h>
#endif

// ============================================================================
// SHADOWSTRIKE INFRASTRUCTURE INCLUDES
// ============================================================================

#include "../Utils/Logger.hpp"
#include "../Utils/ProcessUtils.hpp"
#include "../Utils/HashUtils.hpp"
#include "../HashStore/HashStore.hpp"
#include "../ThreatIntel/ThreatIntelManager.hpp"

// ============================================================================
// FORWARD DECLARATIONS
// ============================================================================

namespace ShadowStrike::Exploits {
    class KernelExploitDetectorImpl;
}

namespace ShadowStrike {
namespace Exploits {

// ============================================================================
// COMPILE-TIME CONSTANTS
// ============================================================================

namespace KernelExploitConstants {

    inline constexpr uint32_t VERSION_MAJOR = 3;
    inline constexpr uint32_t VERSION_MINOR = 0;
    inline constexpr uint32_t VERSION_PATCH = 0;

    /// @brief Maximum drivers to track
    inline constexpr size_t MAX_TRACKED_DRIVERS = 2048;
    
    /// @brief Maximum IOCTL events to track
    inline constexpr size_t MAX_IOCTL_EVENTS = 4096;
    
    /// @brief Common vulnerable driver IOCTLs
    inline constexpr uint32_t VULNERABLE_IOCTLS[] = {
        0x9C406104,     // gdrv.sys read physical
        0x9C406108,     // gdrv.sys write physical
        0x9C40A0D8,     // MSI driver
        0x80002000,     // RWEverything
        0x222808,       // CPU-Z (vulnerable)
        0x226003,       // ASUS driver
    };
    
    /// @brief Kernel address range (typical x64)
    inline constexpr uint64_t KERNEL_ADDRESS_MIN = 0xFFFF800000000000ULL;
    inline constexpr uint64_t KERNEL_ADDRESS_MAX = 0xFFFFFFFFFFFFFFFFULL;

}  // namespace KernelExploitConstants

// ============================================================================
// TYPE ALIASES
// ============================================================================

using Clock = std::chrono::steady_clock;
using TimePoint = std::chrono::steady_clock::time_point;
using SystemTimePoint = std::chrono::system_clock::time_point;
using Hash256 = std::array<uint8_t, 32>;

// ============================================================================
// ENUMERATIONS
// ============================================================================

/**
 * @brief Kernel threat type
 */
enum class KernelThreatType : uint32_t {
    Unknown                 = 0,
    VulnerableDriverLoad    = 1 << 0,   ///< BYOVD attack
    MaliciousDriverLoad     = 1 << 1,   ///< Known malicious driver
    UnsignedDriverLoad      = 1 << 2,   ///< Unsigned driver attempt
    TokenStealing           = 1 << 3,   ///< Token stealing payload
    NullPointerDeref        = 1 << 4,   ///< NULL pointer dereference
    PoolCorruption          = 1 << 5,   ///< Kernel pool corruption
    TypeConfusion           = 1 << 6,   ///< Kernel type confusion
    IntegerOverflow         = 1 << 7,   ///< Kernel integer overflow
    UseAfterFree            = 1 << 8,   ///< Kernel UAF
    HiddenDriver            = 1 << 9,   ///< Rootkit hidden driver
    SSDTHooking             = 1 << 10,  ///< SSDT hook attempt
    KASLRLeak               = 1 << 11,  ///< KASLR bypass attempt
    CallbackTampering       = 1 << 12,  ///< Callback modification
    DKOMAttack              = 1 << 13,  ///< Direct Kernel Object Manipulation
    PrivilegeEscalation     = 1 << 14,  ///< Kernel-level privesc
    ArbitraryRead           = 1 << 15,  ///< Arbitrary kernel read
    ArbitraryWrite          = 1 << 16,  ///< Arbitrary kernel write
    IOCTLAbuse              = 1 << 17,  ///< Suspicious IOCTL usage
    DriverBlocklistViolation = 1 << 18  ///< MS blocklist driver
};

/**
 * @brief Driver signature status
 */
enum class DriverSignatureStatus : uint8_t {
    Unknown             = 0,
    ValidSigned         = 1,    ///< Properly signed
    InvalidSignature    = 2,    ///< Invalid signature
    Unsigned            = 3,    ///< No signature
    RevokedCertificate  = 4,    ///< Revoked signing cert
    ExpiredCertificate  = 5,    ///< Expired signing cert
    TestSigned          = 6,    ///< Test signed
    WhqlSigned          = 7,    ///< WHQL signed
    AttestationSigned   = 8,    ///< Attestation signed
    SelfSigned          = 9     ///< Self-signed certificate
};

/**
 * @brief Driver vulnerability class
 */
enum class VulnerabilityClass : uint8_t {
    Unknown                     = 0,
    ArbitraryMemoryRead         = 1,    ///< Read arbitrary kernel memory
    ArbitraryMemoryWrite        = 2,    ///< Write arbitrary kernel memory
    ArbitraryMSRAccess          = 3,    ///< MSR read/write
    ArbitraryPortAccess         = 4,    ///< IO port access
    ArbitraryPhysicalAccess     = 5,    ///< Physical memory access
    PrivilegeEscalation         = 6,    ///< Generic privesc
    CodeExecution               = 7,    ///< Kernel code execution
    InformationDisclosure       = 8,    ///< Info leak
    DenialOfService             = 9,    ///< System crash
    Multiple                    = 255   ///< Multiple vulnerabilities
};

/**
 * @brief Detection action
 */
enum class DetectionAction : uint8_t {
    None            = 0,
    Alert           = 1,
    Block           = 2,
    Terminate       = 3,
    Quarantine      = 4
};

/**
 * @brief Bug check (BSOD) category
 */
enum class BugCheckCategory : uint8_t {
    Unknown             = 0,
    MemoryCorruption    = 1,
    NullDereference     = 2,
    PoolCorruption      = 3,
    StackOverflow       = 4,
    InvalidAccess       = 5,
    DriverFault         = 6,
    ExploitIndicator    = 7
};

/**
 * @brief Module status
 */
enum class ModuleStatus : uint8_t {
    Uninitialized   = 0,
    Initializing    = 1,
    Running         = 2,
    Paused          = 3,
    Stopping        = 4,
    Stopped         = 5,
    Error           = 6
};

// ============================================================================
// STRUCTURES
// ============================================================================

/**
 * @brief Driver information
 */
struct DriverInfo {
    /// @brief Driver file name
    std::wstring fileName;
    
    /// @brief Full file path
    std::wstring filePath;
    
    /// @brief Service name
    std::wstring serviceName;
    
    /// @brief Driver base address (kernel)
    uint64_t baseAddress = 0;
    
    /// @brief Driver size
    size_t size = 0;
    
    /// @brief Entry point offset
    uint64_t entryPointOffset = 0;
    
    /// @brief SHA256 hash
    std::string sha256;
    
    /// @brief SHA1 hash
    std::string sha1;
    
    /// @brief MD5 hash
    std::string md5;
    
    /// @brief Authenticode hash
    std::string authenticodeHash;
    
    /// @brief Signature status
    DriverSignatureStatus signatureStatus = DriverSignatureStatus::Unknown;
    
    /// @brief Signer name
    std::wstring signerName;
    
    /// @brief Signer thumbprint
    std::string signerThumbprint;
    
    /// @brief Certificate issuer
    std::wstring issuerName;
    
    /// @brief Certificate expiry
    SystemTimePoint certificateExpiry;
    
    /// @brief File version
    std::wstring fileVersion;
    
    /// @brief Product version
    std::wstring productVersion;
    
    /// @brief Product name
    std::wstring productName;
    
    /// @brief Company name
    std::wstring companyName;
    
    /// @brief File description
    std::wstring description;
    
    /// @brief Original filename
    std::wstring originalFileName;
    
    /// @brief File creation time
    SystemTimePoint fileCreated;
    
    /// @brief File modification time
    SystemTimePoint fileModified;
    
    /// @brief Load time
    SystemTimePoint loadTime;
    
    /// @brief Is on Microsoft blocklist
    bool isMicrosoftBlocked = false;
    
    /// @brief Is on LOLDrivers list
    bool isLOLDriver = false;
    
    /// @brief Is known vulnerable
    bool isVulnerable = false;
    
    /// @brief Vulnerability class
    VulnerabilityClass vulnerabilityClass = VulnerabilityClass::Unknown;
    
    /// @brief CVE identifiers
    std::vector<std::string> cveIds;
    
    /// @brief ThreatIntel source
    std::string threatIntelSource;
    
    /// @brief Process that loaded driver
    uint32_t loaderProcessId = 0;
    
    /// @brief Loader process name
    std::wstring loaderProcessName;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief IOCTL event information
 */
struct IOCTLEventInfo {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Process ID
    uint32_t processId = 0;
    
    /// @brief Process name
    std::wstring processName;
    
    /// @brief Process path
    std::wstring processPath;
    
    /// @brief Target device path
    std::wstring devicePath;
    
    /// @brief Target driver
    std::wstring driverName;
    
    /// @brief IOCTL code
    uint32_t ioctlCode = 0;
    
    /// @brief Input buffer size
    size_t inputBufferSize = 0;
    
    /// @brief Output buffer size
    size_t outputBufferSize = 0;
    
    /// @brief Input buffer sample (first N bytes)
    std::vector<uint8_t> inputSample;
    
    /// @brief Is suspicious
    bool isSuspicious = false;
    
    /// @brief Suspicion reason
    std::string suspicionReason;
    
    /// @brief Threat type
    KernelThreatType threatType = KernelThreatType::Unknown;
    
    /// @brief Was blocked
    bool wasBlocked = false;
    
    /// @brief Timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Kernel exploit event
 */
struct KernelExploitEvent {
    /// @brief Event ID
    std::string eventId;
    
    /// @brief Threat type
    KernelThreatType threatType = KernelThreatType::Unknown;
    
    /// @brief Source process ID
    uint32_t sourceProcessId = 0;
    
    /// @brief Source process name
    std::wstring sourceProcessName;
    
    /// @brief Source process path
    std::wstring sourceProcessPath;
    
    /// @brief Driver involved (if any)
    std::optional<DriverInfo> driverInfo;
    
    /// @brief IOCTL event (if any)
    std::optional<IOCTLEventInfo> ioctlEvent;
    
    /// @brief Target kernel address
    uint64_t targetAddress = 0;
    
    /// @brief Exploit payload sample
    std::vector<uint8_t> payloadSample;
    
    /// @brief Action taken
    DetectionAction action = DetectionAction::None;
    
    /// @brief Was blocked
    bool wasBlocked = false;
    
    /// @brief Confidence (0-100)
    double confidence = 0.0;
    
    /// @brief Additional details
    std::string details;
    
    /// @brief Detection timestamp
    SystemTimePoint timestamp;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Bug check (BSOD) analysis result
 */
struct BugCheckAnalysis {
    /// @brief Bug check code
    uint32_t bugCheckCode = 0;
    
    /// @brief Bug check code name
    std::string bugCheckName;
    
    /// @brief Bug check category
    BugCheckCategory category = BugCheckCategory::Unknown;
    
    /// @brief Parameters
    std::array<uint64_t, 4> parameters{};
    
    /// @brief Faulting module
    std::wstring faultingModule;
    
    /// @brief Faulting address
    uint64_t faultingAddress = 0;
    
    /// @brief Is exploit indicator
    bool isExploitIndicator = false;
    
    /// @brief Related driver (if identified)
    std::optional<DriverInfo> relatedDriver;
    
    /// @brief Analysis summary
    std::string summary;
    
    /// @brief Dump file path
    std::wstring dumpFilePath;
    
    /// @brief Bug check time
    SystemTimePoint bugCheckTime;
    
    /**
     * @brief Serialize to JSON
     */
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Statistics
 */
struct KernelExploitStatistics {
    std::atomic<uint64_t> driversScanned{0};
    std::atomic<uint64_t> driversBlocked{0};
    std::atomic<uint64_t> vulnerableDriversDetected{0};
    std::atomic<uint64_t> loldriversDetected{0};
    std::atomic<uint64_t> unsignedDriversDetected{0};
    std::atomic<uint64_t> ioctlEventsAnalyzed{0};
    std::atomic<uint64_t> suspiciousIoctlsDetected{0};
    std::atomic<uint64_t> kaslrLeaksDetected{0};
    std::atomic<uint64_t> exploitAttemptsBlocked{0};
    std::atomic<uint64_t> bugChecksAnalyzed{0};
    TimePoint startTime = Clock::now();
    
    void Reset() noexcept;
    [[nodiscard]] std::string ToJson() const;
};

/**
 * @brief Configuration
 */
struct KernelExploitDetectorConfiguration {
    /// @brief Enable driver monitoring
    bool enableDriverMonitoring = true;
    
    /// @brief Block vulnerable drivers
    bool blockVulnerableDrivers = true;
    
    /// @brief Block unsigned drivers
    bool blockUnsignedDrivers = false;
    
    /// @brief Enable LOLDrivers database
    bool enableLOLDriversDatabase = true;
    
    /// @brief Enable Microsoft blocklist
    bool enableMicrosoftBlocklist = true;
    
    /// @brief Monitor IOCTL calls
    bool monitorIOCTL = true;
    
    /// @brief Block suspicious IOCTLs
    bool blockSuspiciousIOCTL = true;
    
    /// @brief Detect KASLR leaks
    bool detectKASLRLeaks = true;
    
    /// @brief Custom driver blacklist path
    std::wstring customBlacklistPath;
    
    /// @brief Driver whitelist
    std::vector<std::string> whitelistedDriverHashes;
    
    /// @brief Whitelisted driver signers
    std::vector<std::wstring> whitelistedSigners;
    
    /// @brief Analyze BSOD dumps
    bool analyzeBSODDumps = true;
    
    /// @brief Verbose logging
    bool verboseLogging = false;
    
    [[nodiscard]] bool IsValid() const noexcept;
};

// ============================================================================
// CALLBACK TYPES
// ============================================================================

using DriverLoadCallback = std::function<void(const DriverInfo&, DetectionAction)>;
using KernelExploitCallback = std::function<void(const KernelExploitEvent&)>;
using IOCTLCallback = std::function<void(const IOCTLEventInfo&)>;
using BugCheckCallback = std::function<void(const BugCheckAnalysis&)>;
using ErrorCallback = std::function<void(const std::string& message, int code)>;

// ============================================================================
// KERNEL EXPLOIT DETECTOR CLASS
// ============================================================================

/**
 * @class KernelExploitDetector
 * @brief Enterprise-grade kernel exploit detection (user-mode component)
 */
class KernelExploitDetector final {
public:
    [[nodiscard]] static KernelExploitDetector& Instance() noexcept;
    [[nodiscard]] static bool HasInstance() noexcept;
    
    KernelExploitDetector(const KernelExploitDetector&) = delete;
    KernelExploitDetector& operator=(const KernelExploitDetector&) = delete;
    KernelExploitDetector(KernelExploitDetector&&) = delete;
    KernelExploitDetector& operator=(KernelExploitDetector&&) = delete;

    // ========================================================================
    // LIFECYCLE
    // ========================================================================
    
    [[nodiscard]] bool Initialize(const KernelExploitDetectorConfiguration& config = {});
    void Shutdown();
    [[nodiscard]] bool IsInitialized() const noexcept;
    [[nodiscard]] ModuleStatus GetStatus() const noexcept;
    
    [[nodiscard]] bool Start();
    [[nodiscard]] bool Stop();
    void Pause();
    void Resume();
    
    [[nodiscard]] bool UpdateConfiguration(const KernelExploitDetectorConfiguration& config);
    [[nodiscard]] KernelExploitDetectorConfiguration GetConfiguration() const;

    // ========================================================================
    // DRIVER ANALYSIS
    // ========================================================================
    
    /// @brief Scan driver file for vulnerabilities
    [[nodiscard]] DriverInfo ScanDriver(const std::filesystem::path& driverPath);
    
    /// @brief Check if driver is vulnerable
    [[nodiscard]] bool IsVulnerableDriver(const std::string& sha256Hash);
    
    /// @brief Check if driver is on Microsoft blocklist
    [[nodiscard]] bool IsMicrosoftBlocked(const std::string& sha256Hash);
    
    /// @brief Check if driver is LOLDriver
    [[nodiscard]] bool IsLOLDriver(const std::string& sha256Hash);
    
    /// @brief Get CVEs for driver hash
    [[nodiscard]] std::vector<std::string> GetDriverCVEs(const std::string& sha256Hash);
    
    /// @brief Enumerate loaded drivers
    [[nodiscard]] std::vector<DriverInfo> EnumerateLoadedDrivers();
    
    /// @brief Find hidden drivers (rootkit detection)
    [[nodiscard]] std::vector<DriverInfo> FindHiddenDrivers();

    // ========================================================================
    // BLOCKLIST MANAGEMENT
    // ========================================================================
    
    /// @brief Update LOLDrivers database
    [[nodiscard]] bool UpdateLOLDriversDatabase();
    
    /// @brief Update Microsoft blocklist
    [[nodiscard]] bool UpdateMicrosoftBlocklist();
    
    /// @brief Add driver hash to custom blacklist
    void AddToBlacklist(const std::string& sha256Hash, const std::string& reason);
    
    /// @brief Remove from custom blacklist
    void RemoveFromBlacklist(const std::string& sha256Hash);
    
    /// @brief Add signer to whitelist
    void WhitelistSigner(const std::wstring& signerName);
    
    /// @brief Is signer whitelisted
    [[nodiscard]] bool IsSignerWhitelisted(const std::wstring& signerName) const;

    // ========================================================================
    // IOCTL MONITORING
    // ========================================================================
    
    /// @brief Analyze IOCTL event
    [[nodiscard]] IOCTLEventInfo AnalyzeIOCTL(
        uint32_t processId,
        const std::wstring& devicePath,
        uint32_t ioctlCode,
        std::span<const uint8_t> inputBuffer);
    
    /// @brief Check if IOCTL is suspicious
    [[nodiscard]] bool IsSuspiciousIOCTL(uint32_t ioctlCode);
    
    /// @brief Get recent IOCTL events
    [[nodiscard]] std::vector<IOCTLEventInfo> GetRecentIOCTLEvents(
        size_t maxCount = 100) const;

    // ========================================================================
    // KASLR ANALYSIS
    // ========================================================================
    
    /// @brief Detect potential KASLR leaks
    [[nodiscard]] bool DetectKASLRLeak(uint32_t processId);
    
    /// @brief Check if address looks like kernel address
    [[nodiscard]] static bool IsKernelAddress(uint64_t address) noexcept;

    // ========================================================================
    // BSOD ANALYSIS
    // ========================================================================
    
    /// @brief Analyze BSOD dump file
    [[nodiscard]] BugCheckAnalysis AnalyzeBSODDump(const std::filesystem::path& dumpPath);
    
    /// @brief Get recent BSOD analyses
    [[nodiscard]] std::vector<BugCheckAnalysis> GetRecentBSODAnalyses(
        size_t maxCount = 10) const;

    // ========================================================================
    // CALLBACKS
    // ========================================================================
    
    void RegisterDriverLoadCallback(DriverLoadCallback callback);
    void RegisterKernelExploitCallback(KernelExploitCallback callback);
    void RegisterIOCTLCallback(IOCTLCallback callback);
    void RegisterBugCheckCallback(BugCheckCallback callback);
    void RegisterErrorCallback(ErrorCallback callback);
    void UnregisterCallbacks();

    // ========================================================================
    // STATISTICS
    // ========================================================================
    
    [[nodiscard]] KernelExploitStatistics GetStatistics() const;
    void ResetStatistics();
    [[nodiscard]] std::vector<KernelExploitEvent> GetRecentDetections(size_t maxCount = 100) const;
    
    [[nodiscard]] bool SelfTest();
    [[nodiscard]] static std::string GetVersionString() noexcept;

private:
    KernelExploitDetector();
    ~KernelExploitDetector();
    
    std::unique_ptr<KernelExploitDetectorImpl> m_impl;
    static std::atomic<bool> s_instanceCreated;
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

[[nodiscard]] std::string_view GetKernelThreatTypeName(KernelThreatType type) noexcept;
[[nodiscard]] std::string_view GetDriverSignatureStatusName(DriverSignatureStatus status) noexcept;
[[nodiscard]] std::string_view GetVulnerabilityClassName(VulnerabilityClass vc) noexcept;
[[nodiscard]] std::string_view GetDetectionActionName(DetectionAction action) noexcept;
[[nodiscard]] std::string_view GetBugCheckCategoryName(BugCheckCategory cat) noexcept;
[[nodiscard]] std::string GetBugCheckCodeName(uint32_t bugCheckCode);
[[nodiscard]] bool IsKnownVulnerableIOCTL(uint32_t ioctlCode) noexcept;

}  // namespace Exploits
}  // namespace ShadowStrike

// ============================================================================
// MACROS
// ============================================================================

#define SS_SCAN_DRIVER(path) \
    ::ShadowStrike::Exploits::KernelExploitDetector::Instance().ScanDriver(path)

#define SS_IS_VULNERABLE_DRIVER(hash) \
    ::ShadowStrike::Exploits::KernelExploitDetector::Instance().IsVulnerableDriver(hash)

#define SS_ENUMERATE_DRIVERS() \
    ::ShadowStrike::Exploits::KernelExploitDetector::Instance().EnumerateLoadedDrivers()